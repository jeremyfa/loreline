// Generated by Haxe 4.3.6
using global::Loreline.Internal.Root;

#pragma warning disable 109, 114, 219, 429, 168, 162, IL2026, IL2070, IL2072, IL2060
namespace Loreline.Internal.Root {
	public class Std {
		
		public Std() {
		}
		
		
		public static bool isOfType(object v, object t) {
			unchecked {
				if (( v == null )) {
					return false;
				}
				
				if (( t == null )) {
					return false;
				}
				
				global::System.Type clt = ( t as global::System.Type );
				if (global::Loreline.Internal.Lang.Runtime.typeEq(clt, null)) {
					return false;
				}
				
				switch (clt.ToString()) {
					case "System.Boolean":
					{
						return v is bool;
					}
					
					
					case "System.Double":
					{
						return v is double || v is int;
					}
					
					
					case "System.Int32":
					{
						return global::Loreline.Internal.Lang.Runtime.isInt(v);
					}
					
					
					case "System.Object":
					{
						return true;
					}
					
					
				}
				
				global::System.Type vt = v.GetType();
				if (clt.IsAssignableFrom(((global::System.Type) (vt) ))) {
					return true;
				}
				
				{
					global::System.Type[] _g_arr = clt.GetInterfaces();
					uint _g_idx = ((uint) (0) );
					while (( _g_idx < ( _g_arr as global::System.Array ).Length )) {
						_g_idx += ((uint) (1) );
						global::System.Type iface = ((global::System.Type) (_g_arr[((int) (((uint) (( _g_idx - 1 )) )) )]) );
						global::Loreline.Internal.Lang.GenericInterface g = global::Loreline.Internal.Lang.Runtime.getGenericAttr(iface);
						if (( ( g != null ) && global::Loreline.Internal.Lang.Runtime.typeEq(g.generic, clt) )) {
							return iface.IsAssignableFrom(((global::System.Type) (vt) ));
						}
						
					}
					
				}
				
				return false;
			}
		}
		
		
		public static string @string(object s) {
			if (( s == null )) {
				return "null";
			}
			
			if (( s is bool )) {
				if (global::Loreline.Internal.Lang.Runtime.toBool(s)) {
					return "true";
				}
				else {
					return "false";
				}
				
			}
			
			return s.ToString();
		}
		
		
		public static int @int(double x) {
			return ((int) (x) );
		}
		
		
		public static global::Loreline.Internal.Lang.Null<int> parseInt(string x) {
			unchecked {
				if (( x == null )) {
					return default(global::Loreline.Internal.Lang.Null<int>);
				}
				
				int len = x.Length;
				int index = 0;
				while (( index < len )) {
					int code = ((int) (x[index]) );
					if ( ! ((( ( ( code > 8 ) && ( code < 14 ) ) || ( code == 32 ) ))) ) {
						break;
					}
					
					 ++ index;
				}
				
				bool isNegative = default(bool);
				if (( index < len )) {
					int sign = ((int) (x[index]) );
					if (( ( sign == 45 ) || ( sign == 43 ) )) {
						 ++ index;
					}
					
					isNegative = ( sign == 45 );
				}
				else {
					isNegative = false;
				}
				
				bool isHexadecimal = default(bool);
				if (( ( index + 1 ) < len )) {
					int next = ((int) (x[( index + 1 )]) );
					isHexadecimal = ( ( ((int) (x[index]) ) == 48 ) && (( ( next == 120 ) || ( next == 88 ) )) );
				}
				else {
					isHexadecimal = false;
				}
				
				if (isHexadecimal) {
					index += 2;
				}
				
				int cur = index;
				if (isHexadecimal) {
					while (( cur < len )) {
						int code1 = ((int) (x[cur]) );
						if ( ! ((( ( ( ( 48 <= code1 ) && ( code1 <= 57 ) ) || ( ( 97 <= code1 ) && ( code1 <= 102 ) ) ) || ( ( 65 <= code1 ) && ( code1 <= 70 ) ) ))) ) {
							break;
						}
						
						 ++ cur;
					}
					
				}
				else {
					while (( cur < len )) {
						int code2 = ((int) (x[cur]) );
						if ( ! ((( ( 48 <= code2 ) && ( code2 <= 57 ) ))) ) {
							break;
						}
						
						 ++ cur;
					}
					
				}
				
				int firstInvalidIndex = cur;
				if (( index == firstInvalidIndex )) {
					return default(global::Loreline.Internal.Lang.Null<int>);
				}
				
				int result = global::System.Convert.ToInt32(((string) (global::Loreline.Internal.Lang.StringExt.substring(x, index, new global::Loreline.Internal.Lang.Null<int>(firstInvalidIndex, true))) ), ((int) (( (isHexadecimal) ? (16) : (10) )) ));
				if (isNegative) {
					return new global::Loreline.Internal.Lang.Null<int>( - (result) , true);
				}
				else {
					return new global::Loreline.Internal.Lang.Null<int>(result, true);
				}
				
			}
		}
		
		
		public static double parseFloat(string x) {
			unchecked {
				if (( x == null )) {
					return global::Loreline.Internal.Root.Math.NaN;
				}
				
				x = x.TrimStart();
				bool found = false;
				bool hasDot = false;
				bool hasSign = false;
				bool hasE = false;
				bool hasESign = false;
				bool hasEData = false;
				int i = -1;
				while ((  ++ i < x.Length )) {
					int chr = ((int) (x[i]) );
					if (( ( chr >= 48 ) && ( chr <= 57 ) )) {
						if (hasE) {
							hasEData = true;
						}
						
						found = true;
					}
					else {
						switch (chr) {
							case 43:
							case 45:
							{
								if ((  ! (found)  &&  ! (hasSign)  )) {
									hasSign = true;
								}
								else if (( ( ( found &&  ! (hasESign)  ) && hasE ) &&  ! (hasEData)  )) {
									hasESign = true;
								}
								else {
									goto label1;
								}
								
								break;
							}
							
							
							case 46:
							{
								if ( ! (hasDot) ) {
									hasDot = true;
								}
								else {
									goto label1;
								}
								
								break;
							}
							
							
							case 69:
							case 101:
							{
								if ( ! (hasE) ) {
									hasE = true;
								}
								else {
									goto label1;
								}
								
								break;
							}
							
							
							default:
							{
								goto label1;
							}
							
						}
						
					}
					
				}
				label1: {};
				if (( hasE &&  ! (hasEData)  )) {
					 -- i;
					if (hasESign) {
						 -- i;
					}
					
				}
				
				if (( i != x.Length )) {
					x = global::Loreline.Internal.Lang.StringExt.substr(x, 0, new global::Loreline.Internal.Lang.Null<int>(i, true));
				}
				
				try {
					return global::System.Double.Parse(((string) (x) ), ((global::System.IFormatProvider) (global::System.Globalization.CultureInfo.InvariantCulture) ));
				}
				catch (global::System.Exception _g){
					return global::Loreline.Internal.Root.Math.NaN;
				}
				
				
			}
		}
		
		
	}
}


