#!/usr/bin/env node

import { execSync, spawn } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
import * as url from 'node:url';
const __dirname = url.fileURLToPath(new URL('.', import.meta.url));

async function command(cmd, args, options) {
    if (args == null) args = [];
    if (options == null) options = {};
    if (options.cwd == null) options.cwd = process.cwd();

    if (process.platform == 'win32') {
        options.shell = cmd.endsWith('.exe') ? false : true;
        if (options.shell) {
            args = [].concat(args);
            for (let i = 0; i < args.length; i++) {
                args[i] = '"' + args[i].replace(/"/g, '""') + '"';
            }
        }
    }

    console.log('\n> ' + cmd + ' ' + args.join(' '));

    return new Promise((resolve, reject) => {
        const child = spawn(cmd, args, {
            stdio: 'inherit',
            cwd: options.cwd,
            env: process.env,
            shell: options.shell
        });

        child.on('close', (code) => {
            if (code !== 0) {
                reject(new Error(`Child process exited with code ${code}`));
            } else {
                resolve(code);
            }
        });

        child.on('error', (error) => {
            reject(error);
        });
    });
}

function walkDirectory(dir, callback) {
    // Get the contents of the directory
    const entries = fs.readdirSync(dir);

    // Iterate through each entry
    for (const entry of entries) {
        // Create full path
        const fullPath = path.join(dir, entry);

        // Get file/directory stats
        const stats = fs.statSync(fullPath);

        if (stats.isDirectory()) {
            // Recursively walk through subdirectories
            walkDirectory(fullPath, callback);
        } else {
            // Call the callback with the file path
            callback(fullPath);
        }
    }
}

function extractCsNamespace(content) {
    // Match 'namespace' followed by any valid C# namespace characters
    // Handles optional whitespace and the opening brace
    const namespaceMatch = content.match(/namespace\s+([\w.]+)\s*{/);

    if (namespaceMatch) {
        return namespaceMatch[1];
    }

    return null; // Return null if no namespace found
}

function getDotnetRid() {
    const os = process.platform == 'darwin' ? 'osx'
             : process.platform == 'win32' ? 'win'
             : 'linux';
    const arch = process.arch == 'arm64' ? 'arm64' : 'x64';
    return os + '-' + arch;
}

function isLinuxArm64() {
    try {
        const arch = execSync('uname -m').toString().trim();
        return arch == 'aarch64';
    } catch (error) {
        console.error('Error detecting architecture:', error);
        return null;
    }
}

// Example usage with async/await
async function main() {

    process.chdir(__dirname);
    let rawArgs = process.argv.slice(2);

    var haxelib = process.platform == 'win32' ? 'haxelib.cmd' : './haxelib';
    var haxe = process.platform == 'win32' ? 'haxe.cmd' : './haxe';

    let haxeBuildArgs = [];
    let buildCpp = rawArgs.indexOf('--cpp-cli') != -1 || rawArgs.indexOf('--cpp') != -1;
    let buildCppLib = rawArgs.indexOf('--cpp-lib') != -1;
    let buildCppLibTest = rawArgs.indexOf('--cpp-lib-test') != -1;
    let buildCs = rawArgs.indexOf('--cs') != -1;
    let buildCsDll = rawArgs.indexOf('--cs-dll') != -1;
    let buildJs = rawArgs.indexOf('--js') != -1;
    let buildPython = rawArgs.indexOf('--python') != -1 || rawArgs.indexOf('--py') != -1;
    let buildLua = rawArgs.indexOf('--lua') != -1;
    let runTest = rawArgs.indexOf('--test') != -1;
    let debug = false;

    // --sample [web|unity|cpp|python|lua] — copy built files into sample projects
    let setupSample = rawArgs.indexOf('--sample') != -1;
    let sampleTarget = null; // null = all, 'web', 'unity', 'cpp', 'python', or 'lua'
    if (setupSample) {
        const idx = rawArgs.indexOf('--sample');
        if (idx + 1 < rawArgs.length && !rawArgs[idx + 1].startsWith('-')) {
            sampleTarget = rawArgs[idx + 1];
        }
    }

    let i = 0;
    while (i < rawArgs.length) {
        if (rawArgs[i].startsWith('-D')) {
            haxeBuildArgs.push('-D');
            haxeBuildArgs.push(rawArgs[i].substring(2));
        }
        else if (rawArgs[i] == '--debug') {
            debug = true;
            haxeBuildArgs.push('--debug');
        }
        i++;
    }

    // Install dependencies (only needed for build targets, not --sample or --test)
    if (buildCpp || buildCppLib || buildCs || buildJs || buildPython || buildLua) {
        var haxelibRepoPath = path.join(__dirname, '.haxelib');
        if (!fs.existsSync(haxelibRepoPath)) {
            fs.mkdirSync(haxelibRepoPath);
        }
        await command(haxelib, ['dev', 'hxcpp', 'git/hxcpp', '--quiet'], { cwd: __dirname });
        await command(haxelib, ['dev', 'hxcs', 'git/hxcs', '--quiet'], { cwd: __dirname });
        await command(haxelib, ['dev', 'hscript', 'git/hscript', '--quiet'], { cwd: __dirname });
        await command(haxelib, ['dev', 'yaml', 'git/yaml', '--quiet'], { cwd: __dirname });
    }

    if (buildCpp) {

        let haxeBuildCppArgs = [
            'build-cli.hxml',
            '--cpp', 'build/cpp',
            '-D', 'HXCPP_DEBUG_LINK',
            '-D', 'HXCPP_STACK_LINE',
            '-D', 'HXCPP_STACK_TRACE',
            '-D', 'HXCPP_CHECK_POINTER',
            '-D', 'HXCPP_CPP11',
            '-D', 'safeMode'
        ];

        if (process.platform == 'darwin') {
            console.log('Build loreline for mac');

            await command(haxe, haxeBuildCppArgs.concat(haxeBuildArgs).concat([
                '-D', 'mac', '-D', 'mac_arm64', '-D', 'no-compilation'
            ]));
            await command('../../haxelib', ['run', 'hxcpp', 'Build.xml', '-DHXCPP_ARM64'].concat(debug ? ['-Ddebug'] : []), { cwd: path.join(__dirname, 'build', 'cpp') });
            if (debug) {
                fs.renameSync(path.join(__dirname, 'build/cpp/Cli-debug'), path.join(__dirname, 'build/cpp/loreline-arm64'));
            }
            else {
                fs.renameSync(path.join(__dirname, 'build/cpp/Cli'), path.join(__dirname, 'build/cpp/loreline-arm64'));
            }

            await command(haxe, haxeBuildCppArgs.concat(haxeBuildArgs).concat([
                '-D', 'mac', '-D', 'mac_x86_64', '-D', 'no-compilation'
            ]));
            await command('../../haxelib', ['run', 'hxcpp', 'Build.xml', '-DHXCPP_M64', '-DHXCPP_X86_64'].concat(debug ? ['-Ddebug'] : []), { cwd: path.join(__dirname, 'build', 'cpp') });
            if (debug) {
                fs.renameSync(path.join(__dirname, 'build/cpp/Cli-debug'), path.join(__dirname, 'build/cpp/loreline-x86_64'));
            }
            else {
                fs.renameSync(path.join(__dirname, 'build/cpp/Cli'), path.join(__dirname, 'build/cpp/loreline-x86_64'));
            }

            if (fs.existsSync(path.join(__dirname, 'loreline'))) {
                fs.unlinkSync(path.join(__dirname, 'loreline'));
            }

            await command('lipo', [
                '-create', 'loreline-arm64', 'loreline-x86_64',
                '-output', '../../loreline'
            ], { cwd: path.join(__dirname, 'build', 'cpp') });
        }
        else if (process.platform == 'win32') {
            console.log("Build loreline for windows");

            await command(haxe, haxeBuildCppArgs.concat(haxeBuildArgs).concat([
                '-D', 'windows', '-D', 'no-compilation'
            ]));

            let haxelibCmd = fs.readFileSync(path.join(__dirname, 'haxelib.cmd'), 'utf8');
            haxelibCmd = haxelibCmd.split('/git/').join('/../../git/');
            fs.writeFileSync(path.join(__dirname, 'build', 'cpp', 'haxelib.cmd'), haxelibCmd);

            await command(haxelib, ['run', 'hxcpp', 'Build.xml', '-DHXCPP_M64', '-DHXCPP_X86_64'].concat(debug ? ['-Ddebug'] : []), { cwd: path.join(__dirname, 'build', 'cpp') });

            if (fs.existsSync(path.join(__dirname, 'loreline.exe'))) {
                fs.unlinkSync(path.join(__dirname, 'loreline.exe'));
            }

            if (debug) {
                fs.renameSync(path.join(__dirname, 'build/cpp/Cli-debug.exe'), path.join(__dirname, 'loreline.exe'));
            }
            else {
                fs.renameSync(path.join(__dirname, 'build/cpp/Cli.exe'), path.join(__dirname, 'loreline.exe'));
            }
        }
        else {
            console.log("Build loreline for linux");

            if (isLinuxArm64()) {
                await command(haxe, haxeBuildCppArgs.concat(haxeBuildArgs).concat([
                    '-D', 'linux', '-D', 'no-compilation', '-D', 'linux_arm64'
                ]));
                await command('../../haxelib', ['run', 'hxcpp', 'Build.xml', '-DHXCPP_ARM64'].concat(debug ? ['-Ddebug'] : []), { cwd: path.join(__dirname, 'build', 'cpp') });
            }
            else {
                await command(haxe, haxeBuildCppArgs.concat(haxeBuildArgs).concat([
                    '-D', 'linux', '-D', 'no-compilation', '-D', 'linux_x86_64'
                ]));
                await command('../../haxelib', ['run', 'hxcpp', 'Build.xml', '-DHXCPP_M64', '-DHXCPP_X86_64'].concat(debug ? ['-Ddebug'] : []), { cwd: path.join(__dirname, 'build', 'cpp') });
            }

            if (fs.existsSync(path.join(__dirname, 'loreline'))) {
                fs.unlinkSync(path.join(__dirname, 'loreline'));
            }

            if (debug) {
                fs.renameSync(path.join(__dirname, 'build/cpp/Cli-debug'), path.join(__dirname, 'loreline'));
            }
            else {
                fs.renameSync(path.join(__dirname, 'build/cpp/Cli'), path.join(__dirname, 'loreline'));
            }
        }
    }

    if (buildCppLib) {

        let haxeBuildCppLibArgs = [
            'build-cpp-lib.hxml',
            '-D', 'HXCPP_STACK_LINE',
            '-D', 'HXCPP_STACK_TRACE'
        ];

        if (process.platform == 'darwin') {
            console.log('Build loreline C++ library for mac');

            const buildDir = path.join(__dirname, 'build', 'cpp-lib', 'mac');

            // Build arm64
            await command(haxe, haxeBuildCppLibArgs.concat(haxeBuildArgs).concat([
                '--cpp', 'build/cpp-lib/mac',
                '-D', 'mac', '-D', 'mac_arm64'
            ]));
            await command('../../../haxelib', ['run', 'hxcpp', 'Build.xml', '-DHXCPP_ARM64'].concat(debug ? ['-Ddebug'] : []), { cwd: buildDir });

            // Rename intermediate static lib (hxcpp produces libLibrary.a on macOS)
            const staticLib = debug ? 'libLibrary-debug.a' : 'libLibrary.a';
            const armLib = path.join(buildDir, 'libLoreline-arm64.a');
            fs.renameSync(path.join(buildDir, staticLib), armLib);

            // Build x86_64
            await command(haxe, haxeBuildCppLibArgs.concat(haxeBuildArgs).concat([
                '--cpp', 'build/cpp-lib/mac',
                '-D', 'mac', '-D', 'mac_x86_64'
            ]));
            await command('../../../haxelib', ['run', 'hxcpp', 'Build.xml', '-DHXCPP_M64', '-DHXCPP_X86_64'].concat(debug ? ['-Ddebug'] : []), { cwd: buildDir });

            const x64Lib = path.join(buildDir, 'libLoreline-x86_64.a');
            fs.renameSync(path.join(buildDir, staticLib), x64Lib);

            // Link arm64 dylib
            const armDylib = path.join(buildDir, 'libLoreline-arm64.dylib');
            await command('clang++', [
                '-arch', 'arm64',
                '-shared', '-fvisibility=hidden',
                '-o', armDylib,
                '-Wl,-force_load,' + armLib,
                '-framework', 'Foundation', '-lpthread'
            ]);
            await command('install_name_tool', ['-id', '@rpath/libLoreline.dylib', armDylib]);

            // Link x86_64 dylib
            const x64Dylib = path.join(buildDir, 'libLoreline-x86_64.dylib');
            await command('clang++', [
                '-arch', 'x86_64',
                '-shared', '-fvisibility=hidden',
                '-o', x64Dylib,
                '-Wl,-force_load,' + x64Lib,
                '-framework', 'Foundation', '-lpthread'
            ]);
            await command('install_name_tool', ['-id', '@rpath/libLoreline.dylib', x64Dylib]);

            // Create universal dylib
            const outputDylib = path.join(buildDir, 'libLoreline.dylib');
            if (fs.existsSync(outputDylib)) fs.unlinkSync(outputDylib);
            await command('lipo', [
                '-create', armDylib, x64Dylib,
                '-output', outputDylib
            ]);

            console.log('Built: ' + outputDylib);
        }
        else if (process.platform == 'win32') {
            console.log('Build loreline C++ library for windows');

            const buildDir = path.join(__dirname, 'build', 'cpp-lib', 'windows');

            await command(haxe, haxeBuildCppLibArgs.concat(haxeBuildArgs).concat([
                '--cpp', 'build/cpp-lib/windows',
                '-D', 'windows'
            ]));

            let haxelibCmd = fs.readFileSync(path.join(__dirname, 'haxelib.cmd'), 'utf8');
            haxelibCmd = haxelibCmd.split('/git/').join('/../../../git/');
            fs.writeFileSync(path.join(buildDir, 'haxelib.cmd'), haxelibCmd);

            await command(haxelib, ['run', 'hxcpp', 'Build.xml', '-DHXCPP_M64', '-DHXCPP_X86_64'].concat(debug ? ['-Ddebug'] : []), { cwd: buildDir });

            // On Windows, hxcpp with static_link produces a .lib; link into DLL via cl /LD
            // Using cl instead of link directly ensures proper CRT DLL initialization
            const staticLib = debug ? 'libLibrary-debug.lib' : 'libLibrary.lib';
            const stubFile = path.join(buildDir, '_dll_stub.c');
            fs.writeFileSync(stubFile, '/* stub for DLL creation */\n');
            await command('cl', [
                '/LD', '/MT',
                stubFile,
                '/Fe:' + path.join(buildDir, 'Loreline.dll'),
                '/link',
                '/WHOLEARCHIVE:' + path.join(buildDir, staticLib),
                'ws2_32.lib', 'Crypt32.lib', 'user32.lib'
            ]);

            console.log('Built: ' + path.join(buildDir, 'Loreline.dll'));
        }
        else {
            console.log('Build loreline C++ library for linux');

            const buildDir = path.join(__dirname, 'build', 'cpp-lib', 'linux');

            if (isLinuxArm64()) {
                await command(haxe, haxeBuildCppLibArgs.concat(haxeBuildArgs).concat([
                    '--cpp', 'build/cpp-lib/linux',
                    '-D', 'linux', '-D', 'linux_arm64'
                ]));
                await command('../../../haxelib', ['run', 'hxcpp', 'Build.xml', '-DHXCPP_ARM64'].concat(debug ? ['-Ddebug'] : []), { cwd: buildDir });
            }
            else {
                await command(haxe, haxeBuildCppLibArgs.concat(haxeBuildArgs).concat([
                    '--cpp', 'build/cpp-lib/linux',
                    '-D', 'linux', '-D', 'linux_x86_64'
                ]));
                await command('../../../haxelib', ['run', 'hxcpp', 'Build.xml', '-DHXCPP_M64', '-DHXCPP_X86_64'].concat(debug ? ['-Ddebug'] : []), { cwd: buildDir });
            }

            // On Linux, hxcpp also produces libLibrary.a
            const staticLib = debug ? 'libLibrary-debug.a' : 'libLibrary.a';
            await command('g++', [
                '-shared', '-fvisibility=hidden',
                '-o', path.join(buildDir, 'libLoreline.so'),
                '-Wl,--whole-archive', path.join(buildDir, staticLib), '-Wl,--no-whole-archive',
                '-lpthread', '-ldl'
            ]);

            console.log('Built: ' + path.join(buildDir, 'libLoreline.so'));
        }
    }

    if (buildCppLibTest) {
        console.log('Test loreline C++ library');

        let buildDir;
        if (process.platform == 'darwin') {
            buildDir = path.join(__dirname, 'build', 'cpp-lib', 'mac');
            await command('clang++', [
                '-std=c++17',
                '-o', path.join(buildDir, 'test_runner'),
                'cpp/test/test_runner.cpp',
                '-Icpp/include',
                '-L' + buildDir,
                '-lLoreline',
                '-Wl,-rpath,@executable_path'
            ]);
        }
        else if (process.platform == 'win32') {
            buildDir = path.join(__dirname, 'build', 'cpp-lib', 'windows');
            await command('cl', [
                '/std:c++17', '/EHsc',
                '/I', 'cpp\\include',
                'cpp\\test\\test_runner.cpp',
                '/Fe:' + path.join(buildDir, 'test_runner.exe'),
                '/link', '/LIBPATH:' + buildDir, 'Loreline.lib'
            ]);
        }
        else {
            buildDir = path.join(__dirname, 'build', 'cpp-lib', 'linux');
            await command('g++', [
                '-std=c++17',
                '-o', path.join(buildDir, 'test_runner'),
                'cpp/test/test_runner.cpp',
                '-Icpp/include',
                '-L' + buildDir,
                '-lLoreline',
                "-Wl,-rpath,$ORIGIN"
            ]);
        }

        const testBin = path.join(buildDir, process.platform == 'win32' ? 'test_runner.exe' : 'test_runner');
        await command(testBin, ['./test']);
    }

    if (buildCs) {
        console.log('Export loreline for C#');

        if (fs.existsSync('build/cs/Loreline')) {
            fs.rmSync('build/cs/Loreline', { recursive: true, force: true });
        }

        let haxeBuildCsArgs = [
            '--class-path', 'src',
            '--cs', 'build/cs',
            '--library', 'hscript',
            '-D', 'no-compilation',
            '-D', 'no-root',
            '-D', 'real-position',
            '-D', 'loreline_use_cs_types',
            '-D', 'loreline_cs_api',
            '-D', 'hscriptPos',
            '-D', 'erase-generics',
            '--main', 'loreline.lib.Library'
        ];

        await command(haxe, haxeBuildCsArgs.concat(haxeBuildArgs).concat([]));

        // Remove the generated Library entry point (not part of the public API)
        for (const f of [
            'build/cs/src/loreline/lib/_Library/Library_Fields_.cs',
            'build/cs/src/loreline/lib/Library.cs'
        ]) {
            if (fs.existsSync(f)) fs.unlinkSync(f);
        }
        //fs.unlinkSync('build/cs/src/loreline/Loreline.cs');
        if (fs.existsSync('build/cs/hxcs_build.txt')) fs.unlinkSync('build/cs/hxcs_build.txt');

        if (fs.existsSync('cs/Loreline/Internal'))
            fs.rmSync('cs/Loreline/Internal', { recursive: true, force: true });
        if (fs.existsSync('cs/Loreline/Runtime'))
            fs.rmSync('cs/Loreline/Runtime', { recursive: true, force: true });

        walkDirectory('build/cs/src', (filePath) => {
            if (filePath.endsWith('.cs')) {
                const original = fs.readFileSync(filePath, 'utf8');
                let content = original;

                // Replace any haxe.X with Loreline.Hx.X (with X capitalized)
                content = content.replace(
                    /\bhaxe\.(\w+)\b/g,
                    (_, identifier) => `Loreline.Internal.${identifier.charAt(0).toUpperCase() + identifier.slice(1)}`
                );

                content = content.replace(/\bhaxe\b/g, 'Loreline.Internal');
                content = content.replace(/\bhscript\b/g, 'Loreline.Internal.Hscript');
                content = content.replace(/\b\.Loreline\.Internal\.Hscript\b/g, '.hscript');
                content = content.replace(/\bstring Loreline\.Internal\.Hscript\b/g, 'string hscript');
                content = content.replace(/\bnamespace cs\b/g, 'namespace Loreline.Internal.Cs');
                content = content.replace(/\bcs.\b/g, 'Loreline.Internal.Cs.');
                content = content.replace(/\bloreline\b/g, 'Loreline.Runtime');
                content = content.replace(/\bLoreline\.Internal\./g, 'global::Loreline.Internal.');
                content = content.replace(/\bnamespace global::Loreline\.Internal\./g, 'namespace Loreline.Internal.');
                content = content.replace(/\bglobal::global::Loreline\.Internal\./g, 'global::Loreline.Internal.');

                // Disable warnings related to AOT (the code is still expected to work in that
                // situation because it should not rely on actual C# reflection. Uses FieldLookup instead)
                content = content.split("#pragma warning disable 109, 114, 219, 429, 168, 162").join("#pragma warning disable 109, 114, 219, 429, 168, 162, IL2026, IL2070, IL2072, IL2060, CS0108");

                const namespace = extractCsNamespace(content);
                if (namespace == null) {
                    throw 'Failed to extract namespace for file: ' + filePath;
                }
                const namespaceParts = namespace.split('.');

                let newPath = path.join('cs', namespaceParts[0], namespaceParts[1], path.basename(filePath));

                if (namespaceParts.length > 2 && namespaceParts[2].charAt(0).toUpperCase() == namespaceParts[2].charAt(0) && namespaceParts[2].charAt(0) != '_' && namespaceParts[2] != 'Cs') {
                    newPath = path.join('cs', namespaceParts[0], namespaceParts[1], namespaceParts[2], path.basename(filePath));
                }

                if (!fs.existsSync(path.dirname(newPath))) {
                    fs.mkdirSync(path.dirname(newPath), { recursive: true });
                }
                if (fs.existsSync(newPath)) {
                    throw 'File path collision: ' + newPath;
                }
                fs.writeFileSync(newPath, content);
            }
        });

        fs.rmSync('build/cs/src', { recursive: true, force: true });

        // These identify Loreline
        const solutionGuid = '60F34EF9-0A9A-47B7-883F-8EC1F188C262';
        const projectGuid = 'F3DEFEF5-8B8F-4D6D-8C2C-1DD7F3E309D4';

        if (buildCsDll) {
            const csConfig = debug ? 'Debug' : 'Release';
            const csPlatform = 'netstandard2.1';
            const dllFiles = [
                'Loreline.deps.json',
                'Loreline.dll',
                'Loreline.pdb',
                'Loreline.xml'
            ];
            for (let name of dllFiles) {
                if (fs.existsSync('cs/' + name)) {
                    fs.rmSync('cs/' + name, { recursive: true, force: true });
                }
            }
            await command('dotnet', ['build', '-c', csConfig], { cwd: 'cs' });
            for (let name of dllFiles) {
                fs.copyFileSync(
                    'build/cs/bin/Loreline/' + csConfig + '/' + csPlatform + '/' + name,
                    'cs/' + name
                );
            }
        }

    }

    if (buildJs) {
        console.log('Export loreline for Javascript');

        let haxeBuildJsArgs = [
            '--class-path', 'src',
            '--js', 'js/loreline.js',
            '--library', 'hscript',
            '-D', 'js-es=6',
            '-D', 'loreline_use_js_types',
            '-D', 'loreline_typedef_options',
            '-D', 'loreline_functions_map_dynamic_access',
            '-D', 'loreline_node_id_class',
            '-D', 'hscriptPos',
            '--main', 'loreline.lib.Library'
        ];

        await command(haxe, haxeBuildJsArgs.concat(haxeBuildArgs).concat([]));

        let ln = process.platform == 'win32' ? '\r\n' : '\n';

        let js = fs.readFileSync('js/loreline.js', 'utf8');
        js = 'let runtime = {}; let globals = {}; ' + js;
        js = js.split('})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);').join('})(runtime, globals);');
        js += ln + 'export const Loreline = runtime.loreline.Loreline;';
        js += ln + 'export const Interpreter = runtime.loreline.Interpreter;';
        js += ln + 'export const Node = runtime.loreline.Node;';
        js += ln + 'export const Script = runtime.loreline.Script;';
        fs.writeFileSync('js/loreline.js', js);

        // Minify
        const esbuild = await import('esbuild');
        await esbuild.build({
            entryPoints: ['js/loreline.js'],
            outfile: 'js/loreline.min.js',
            minify: true,
            bundle: false,
        });

    }

    if (buildPython) {
        console.log('Export loreline for Python');

        fs.mkdirSync('py/loreline', { recursive: true });

        let haxeBuildPyArgs = [
            '--class-path', 'src',
            '--python', 'py/loreline/_core.py',
            '--library', 'hscript',
            '-D', 'hscriptPos',
            '-D', 'loreline_typedef_options',
            '-D', 'loreline_functions_map_dynamic_access',
            '-D', 'loreline_node_id_class',
            '--main', 'loreline.lib.Library'
        ];

        await command(haxe, haxeBuildPyArgs.concat(haxeBuildArgs).concat([]));

        // Post-process: guard the main() entry-point call
        let py = fs.readFileSync('py/loreline/_core.py', 'utf8');
        // Haxe generates a top-level main() call at the end — guard it
        py = py.replace(/\n(loreline_lib_Library\.main\(\))\s*$/, '\nif __name__ == "__main__":\n    $1\n');
        fs.writeFileSync('py/loreline/_core.py', py);
    }

    if (buildLua) {
        console.log('Export loreline for Lua');

        fs.mkdirSync('lua/loreline', { recursive: true });

        let haxeBuildLuaArgs = [
            'build-lua.hxml',
        ];

        await command(haxe, haxeBuildLuaArgs.concat(haxeBuildArgs));

        // Post-process the generated Lua
        let lua = fs.readFileSync('lua/loreline/core.lua', 'utf8');
        // Remove the main() xpcall at the end, keep static init
        lua = lua.replace(/\nlocal success, err = _G\.xpcall\(function\(\)[\s\S]*$/, '\n');
        // Remove unused external library references (rex_pcre2/EReg, luv)
        // — EReg is only used by hscript's XML metadata parser, never by loreline
        // — luv is only used by Sys.time/Sys.sleep, replaced below with vanilla Lua
        lua = lua.replace(/^__lua_lib_lrexlib_Rex = .*\n/m, '');
        lua = lua.replace(/^__lua_lib_luv_Misc = .*\n/m, '');
        lua = lua.replace(/^__lua_lib_luv_Thread = .*\n/m, '');
        lua = lua.replace(/^local EReg = _hx_e\(\)\n/m, '');
        // Remove entire EReg class definition (EReg.new through EReg.prototype.__class__)
        lua = lua.replace(/EReg\.new = function[\s\S]*?EReg\.prototype\.__class__ = +EReg\n/m, '');
        lua = lua.replace(/_hxClasses\["EReg"\] = EReg\nEReg\.__name__ = "EReg"\n/m, '');
        // Replace the single EReg usage (hscript XML metadata) with native Lua string.gsub
        lua = lua.replace(
            /EReg\.new\("[^"]*", "[^"]*"\):replace\((\w+), ""\)/g,
            '_G.string.gsub($1, "[\\n\\r\\t]+", "")'
        );
        // Stub _hx_safe_require for any remaining optional requires
        const safeRequire = [
            'local _hx_safe_require = function(m) local ok, mod = pcall(require, m); if ok then return mod end; return nil end',
            '-- Provide bit32 shim for Lua 5.4+ (native bitwise operators replace the bit32 library)',
            'if not pcall(require, "bit32") and not pcall(require, "bit") then',
            '  _G.package.preload["bit32"] = function()',
            '    return {',
            '      band = function(a, b) return a & b end,',
            '      bor = function(a, b) return a | b end,',
            '      bxor = function(a, b) return a ~ b end,',
            '      bnot = function(a) return ~a end,',
            '      lshift = function(a, n) return a << n end,',
            '      rshift = function(a, n) return a >> n end,',
            '      arshift = function(a, n) return a >> n end,',
            '      btest = function(a, b) return (a & b) ~= 0 end,',
            '    }',
            '  end',
            'end',
        ].join('\n') + '\n';
        lua = lua.replace(/-- Generated by Haxe[^\n]*\n/, '$&' + safeRequire);
        lua = lua.replace(/_G\.require\(/g, '_hx_safe_require(');
        // Remove EReg/Rex references in _hx_static_init
        lua = lua.replace(/if \(__lua_lib_lrexlib_Rex == nil\) then\s*_G\.error[^;]*;\s*end;/g, '');
        lua = lua.replace(/EReg\.FLAGS = __lua_lib_lrexlib_Rex\.flags\(\);/g, '');
        // Provide fallbacks for Sys.time/Sys.sleep when luv is unavailable
        lua = lua.replace(
            /Sys\.time = function\(\) *\n(?:.*\n)*?end\n/,
            'Sys.time = function()\n  return os.clock()\nend\n'
        );
        lua = lua.replace(
            /Sys\.sleep = function\(seconds\) *\n(?:.*\n)*?end\n/,
            'Sys.sleep = function(seconds)\n  -- No-op without luv\nend\n'
        );
        // Fix Lua 5.4 float formatting: tostring(13.0) gives "13.0" instead of "13".
        // Patch _hx_tostring to strip trailing .0 for integer-valued floats.
        lua = lua.replace(
            'else return _G.tostring(obj)\n        end',
            'else\n            local s = _G.tostring(obj)\n            if _G.math.type(obj) == "float" and obj == _G.math.floor(obj) then s = _G.string.format("%d", obj) end\n            return s\n        end'
        );
        // Fix hscript Parser nil comparison: Lua's string.byte returns nil at end-of-input,
        // which gets assigned to self.char; comparing nil < 0 is a Lua runtime error.
        // Replace with a nil-safe check (nil means "no char buffered", same as -1).
        lua = lua.replace(/self\.char < 0/g, '(not self.char or self.char < 0)');
        // Expose _hx_o globally so external code (test runner, wrapper) can create anon objects
        lua = lua.replace('local function _hx_o(obj)', '_G._hx_o = nil\nlocal function _hx_o(obj)');
        lua = lua.replace('_hx_static_init();', '_G._hx_o = _hx_o\n_hx_static_init();');
        fs.writeFileSync('lua/loreline/core.lua', lua);
    }

    // ── Set up sample projects ──────────────────────────────────────────────
    //
    // Copies built runtime files and story scripts into the sample directories.
    // Usage:
    //   node ./setup --sample          (all samples)
    //   node ./setup --sample web      (loreline-web only)
    //   node ./setup --sample unity    (loreline-unity only)
    //   node ./setup --sample cpp      (loreline-cpp only)
    //   node ./setup --sample python   (loreline-python only)
    //   node ./setup --sample lua      (loreline-lua only)

    if (setupSample) {

        // loreline-web: needs js/loreline.js (from --js) + story files
        if (sampleTarget == null || sampleTarget == 'web') {
            console.log('Set up sample: loreline-web');

            const webDir = path.join(__dirname, 'sample', 'loreline-web');
            const storyDir = path.join(webDir, 'story');

            // Copy loreline.js runtime
            const jsSrc = path.join(__dirname, 'js', 'loreline.js');
            if (!fs.existsSync(jsSrc)) {
                console.warn('  Warning: js/loreline.js not found — run --js first');
            } else {
                fs.copyFileSync(jsSrc, path.join(webDir, 'loreline.js'));
                console.log('  js/loreline.js → sample/loreline-web/loreline.js');
            }

            // Copy story files into story/ subfolder
            fs.mkdirSync(storyDir, { recursive: true });
            for (const name of ['CoffeeShop.lor', 'characters.lor']) {
                fs.copyFileSync(
                    path.join(__dirname, 'sample', name),
                    path.join(storyDir, name)
                );
                console.log('  sample/' + name + ' → sample/loreline-web/story/' + name);
            }
        }

        // loreline-unity: needs cs/Loreline/ (from --cs) + story files as .lor.txt
        if (sampleTarget == null || sampleTarget == 'unity') {
            console.log('Set up sample: loreline-unity');

            const unityPluginDir = path.join(__dirname, 'sample', 'loreline-unity', 'Assets', 'Plugins', 'Loreline');
            const unityResourceDir = path.join(__dirname, 'sample', 'loreline-unity', 'Assets', 'Resources');
            const csSrcDir = path.join(__dirname, 'cs', 'Loreline');

            // Copy C# plugin files
            if (!fs.existsSync(path.join(csSrcDir, 'Internal'))) {
                console.warn('  Warning: cs/Loreline/Internal/ not found — run --cs first');
            } else {
                // Clear stale plugin files, then copy fresh
                if (fs.existsSync(unityPluginDir)) {
                    fs.rmSync(unityPluginDir, { recursive: true, force: true });
                }
                fs.cpSync(csSrcDir, unityPluginDir, { recursive: true });
                console.log('  cs/Loreline/ → sample/loreline-unity/Assets/Plugins/Loreline/');
            }

            // Copy story files as .lor.txt (Unity convention)
            fs.mkdirSync(unityResourceDir, { recursive: true });
            for (const name of ['CoffeeShop.lor', 'characters.lor']) {
                fs.copyFileSync(
                    path.join(__dirname, 'sample', name),
                    path.join(unityResourceDir, name + '.txt')
                );
                console.log('  sample/' + name + ' → sample/loreline-unity/Assets/Resources/' + name + '.txt');
            }
        }

        // loreline-cpp: needs cpp/include/Loreline.h + libLoreline + story files
        if (sampleTarget == null || sampleTarget == 'cpp') {
            console.log('Set up sample: loreline-cpp');

            const cppDir = path.join(__dirname, 'sample', 'loreline-cpp');
            const storyDir = path.join(cppDir, 'story');
            const lorelineDir = path.join(cppDir, 'loreline');

            // Determine platform-specific library paths
            let buildLibDir, libFiles, platformSubdir;
            if (process.platform == 'darwin') {
                buildLibDir = path.join(__dirname, 'build', 'cpp-lib', 'mac');
                libFiles = ['libLoreline.dylib'];
                platformSubdir = 'mac';
            } else if (process.platform == 'win32') {
                buildLibDir = path.join(__dirname, 'build', 'cpp-lib', 'windows');
                libFiles = ['Loreline.dll', 'Loreline.lib'];
                platformSubdir = 'windows';
            } else {
                buildLibDir = path.join(__dirname, 'build', 'cpp-lib', 'linux');
                libFiles = ['libLoreline.so'];
                platformSubdir = isLinuxArm64() ? 'linux-aarch64' : 'linux-x86_64';
            }

            // Build the C++ library if it doesn't exist yet
            if (!fs.existsSync(path.join(buildLibDir, libFiles[0]))) {
                console.log('  C++ library not found, building with --cpp-lib...');
                await command('node', ['./setup', '--cpp-lib']);
            }

            // Copy header
            const includeDir = path.join(lorelineDir, 'include');
            fs.mkdirSync(includeDir, { recursive: true });
            fs.copyFileSync(
                path.join(__dirname, 'cpp', 'include', 'Loreline.h'),
                path.join(includeDir, 'Loreline.h')
            );
            console.log('  cpp/include/Loreline.h → sample/loreline-cpp/loreline/include/Loreline.h');

            // Copy platform library
            const platformDir = path.join(lorelineDir, platformSubdir);
            fs.mkdirSync(platformDir, { recursive: true });
            for (const libFile of libFiles) {
                fs.copyFileSync(
                    path.join(buildLibDir, libFile),
                    path.join(platformDir, libFile)
                );
                console.log('  ' + libFile + ' → sample/loreline-cpp/loreline/' + platformSubdir + '/' + libFile);
            }

            // Copy story files
            fs.mkdirSync(storyDir, { recursive: true });
            for (const name of ['CoffeeShop.lor', 'characters.lor']) {
                fs.copyFileSync(
                    path.join(__dirname, 'sample', name),
                    path.join(storyDir, name)
                );
                console.log('  sample/' + name + ' → sample/loreline-cpp/story/' + name);
            }
        }

        // loreline-python: needs py/loreline/ (from --py) + story files
        if (sampleTarget == null || sampleTarget == 'python') {
            console.log('Set up sample: loreline-python');

            const pyDir = path.join(__dirname, 'sample', 'loreline-python');
            const pyPkgDir = path.join(pyDir, 'loreline');
            const pyStoryDir = path.join(pyDir, 'story');

            fs.mkdirSync(pyPkgDir, { recursive: true });
            fs.mkdirSync(pyStoryDir, { recursive: true });

            // Copy loreline package files
            const pySrcDir = path.join(__dirname, 'py', 'loreline');
            for (const file of ['__init__.py', '_core.py', 'py.typed']) {
                const src = path.join(pySrcDir, file);
                if (fs.existsSync(src)) {
                    fs.copyFileSync(src, path.join(pyPkgDir, file));
                    console.log('  py/loreline/' + file + ' → sample/loreline-python/loreline/' + file);
                }
            }

            // Copy story files
            const storyFiles = ['CoffeeShop.lor', 'characters.lor'];
            for (const name of storyFiles) {
                fs.copyFileSync(
                    path.join(__dirname, 'sample', name),
                    path.join(pyStoryDir, name)
                );
                console.log('  sample/' + name + ' → sample/loreline-python/story/' + name);
            }
        }

        // loreline-lua: needs lua/loreline/ (from --lua) + story files
        if (sampleTarget == null || sampleTarget == 'lua') {
            console.log('Set up sample: loreline-lua');

            const luaDir = path.join(__dirname, 'sample', 'loreline-lua');
            const luaPkgDir = path.join(luaDir, 'loreline');
            const luaStoryDir = path.join(luaDir, 'story');

            fs.mkdirSync(luaPkgDir, { recursive: true });
            fs.mkdirSync(luaStoryDir, { recursive: true });

            // Copy loreline package files
            const luaSrcDir = path.join(__dirname, 'lua', 'loreline');
            for (const file of ['init.lua', 'core.lua']) {
                const src = path.join(luaSrcDir, file);
                if (fs.existsSync(src)) {
                    fs.copyFileSync(src, path.join(luaPkgDir, file));
                    console.log('  lua/loreline/' + file + ' → sample/loreline-lua/loreline/' + file);
                }
            }

            // Copy story files
            for (const name of ['CoffeeShop.lor', 'characters.lor']) {
                fs.copyFileSync(
                    path.join(__dirname, 'sample', name),
                    path.join(luaStoryDir, name)
                );
                console.log('  sample/' + name + ' → sample/loreline-lua/story/' + name);
            }
        }

    }

    // ── Run all test suites ─────────────────────────────────────────────────
    //
    // Replicates test-all.sh in cross-platform Node.js:
    //   1. Neko tests (via node run)
    //   2. C# build + dotnet tests
    //   3. C# AOT publish + tests (auto-detects platform RID)
    //   4. JS build + tests
    //   5. C++ lib build + tests

    if (runTest) {

        // 1. Neko tests
        console.log('\n=== Neko tests ===');
        await command('node', ['run', 'test', './test']);

        // 2. C# build + tests
        console.log('\n=== C# build + tests ===');
        await command('node', ['./setup', '--cs', '--cs-dll']);
        await command('dotnet', ['run', '--project', 'cs/TestRunner', '--', './test']);

        // 3. C# AOT build + tests
        console.log('\n=== C# AOT build + tests ===');
        const rid = getDotnetRid();
        const aotPublishDir = path.join('build', 'cs', 'bin', 'TestRunner', 'Release', 'net8.0', rid, 'publish');
        await command('dotnet', [
            'publish', 'cs/TestRunner', '-c', 'Release',
            '-r', rid, '-p:AotBuild=true'
        ]);
        const aotBin = path.join(aotPublishDir, process.platform == 'win32' ? 'TestRunner.exe' : 'TestRunner');
        await command(aotBin, ['./test']);

        // 4. JS build + tests
        console.log('\n=== JS build + tests ===');
        await command('node', ['./setup', '--js']);
        await command('npx', ['tsx', 'js/test-runner.ts', './test']);

        // 5. C++ lib build + tests
        console.log('\n=== C++ lib build + test ===');
        await command('node', ['./setup', '--cpp-lib']);
        await command('node', ['./setup', '--cpp-lib-test']);

        // 6. Python build + tests
        console.log('\n=== Python build + tests ===');
        await command('node', ['./setup', '--py']);
        await command('python3', ['py/test-runner.py', './test']);

        // 7. Lua build + tests
        console.log('\n=== Lua build + tests ===');
        await command('node', ['./setup', '--lua']);
        await command('lua', ['lua/test-runner.lua', './test']);

    }

}

(async () => {
    try {
        await main();
    } catch (error) {
        console.error(error);
        process.exit(1);
    }
})();
