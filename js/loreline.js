let runtime = {}; let globals = {}; // Generated by Haxe 4.3.6
(function ($hx_exports, $global) { "use strict";
$hx_exports["loreline"] = $hx_exports["loreline"] || {};
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
class IntIterator {
	constructor(min,max) {
		this.min = min;
		this.max = max;
	}
	hasNext() {
		return this.min < this.max;
	}
	next() {
		return this.min++;
	}
}
$hxClasses["IntIterator"] = IntIterator;
IntIterator.__name__ = "IntIterator";
Object.assign(IntIterator.prototype, {
	__class__: IntIterator
});
class Lambda {
	static exists(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(f(x1)) {
				return true;
			}
		}
		return false;
	}
}
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = "Lambda";
Math.__name__ = "Math";
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			return null;
		}
	}
	static getProperty(o,field) {
		let tmp;
		if(o == null) {
			return null;
		} else {
			let tmp1;
			if(o.__properties__) {
				tmp = o.__properties__["get_" + field];
				tmp1 = tmp;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				return o[tmp]();
			} else {
				return o[field];
			}
		}
	}
	static setProperty(o,field,value) {
		let tmp;
		let tmp1;
		if(o.__properties__) {
			tmp = o.__properties__["set_" + field];
			tmp1 = tmp;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			o[tmp](value);
		} else {
			o[field] = value;
		}
	}
	static fields(o) {
		let a = [];
		if(o != null) {
			let hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
	static isFunction(f) {
		if(typeof(f) == "function") {
			return !(f.__name__ || f.__ename__);
		} else {
			return false;
		}
	}
	static compare(a,b) {
		if(a == b) {
			return 0;
		} else if(a > b) {
			return 1;
		} else {
			return -1;
		}
	}
	static isObject(v) {
		if(v == null) {
			return false;
		}
		let t = typeof(v);
		if(!(t == "string" || t == "object" && v.__enum__ == null)) {
			if(t == "function") {
				return (v.__name__ || v.__ename__) != null;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static isEnumValue(v) {
		if(v != null) {
			return v.__enum__ != null;
		} else {
			return false;
		}
	}
	static makeVarArgs(f) {
		return function() {
			let a = Array.prototype.slice;
			let a1 = arguments;
			let a2 = a.call(a1);
			return f(a2);
		};
	}
}
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		let v = parseInt(x);
		if(isNaN(v)) {
			return null;
		}
		return v;
	}
}
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
class StringBuf {
	constructor() {
		this.b = "";
	}
}
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
Object.assign(StringBuf.prototype, {
	__class__: StringBuf
});
class StringTools {
	static htmlEscape(s,quotes) {
		let buf_b = "";
		let _g_offset = 0;
		let _g_s = s;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let code = c1;
			switch(code) {
			case 34:
				if(quotes) {
					buf_b += "&quot;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 38:
				buf_b += "&amp;";
				break;
			case 39:
				if(quotes) {
					buf_b += "&#039;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 60:
				buf_b += "&lt;";
				break;
			case 62:
				buf_b += "&gt;";
				break;
			default:
				buf_b += String.fromCodePoint(code);
			}
		}
		return buf_b;
	}
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = "StringTools";
var ValueType = $hxEnums["ValueType"] = { __ename__:"ValueType",__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
class Type {
	static createInstance(cl,args) {
		let ctor = Function.prototype.bind.apply(cl,[null].concat(args));
		return new (ctor);
	}
	static typeof(v) {
		switch(typeof(v)) {
		case "boolean":
			return ValueType.TBool;
		case "function":
			if(v.__name__ || v.__ename__) {
				return ValueType.TObject;
			}
			return ValueType.TFunction;
		case "number":
			if(Math.ceil(v) == v % 2147483648.0) {
				return ValueType.TInt;
			}
			return ValueType.TFloat;
		case "object":
			if(v == null) {
				return ValueType.TNull;
			}
			let e = v.__enum__;
			if(e != null) {
				return ValueType.TEnum($hxEnums[e]);
			}
			let c = js_Boot.getClass(v);
			if(c != null) {
				return ValueType.TClass(c);
			}
			return ValueType.TObject;
		case "string":
			return ValueType.TClass(String);
		case "undefined":
			return ValueType.TNull;
		default:
			return ValueType.TUnknown;
		}
	}
	static enumEq(a,b) {
		if(a == b) {
			return true;
		}
		try {
			let e = a.__enum__;
			if(e == null || e != b.__enum__) {
				return false;
			}
			if(a._hx_index != b._hx_index) {
				return false;
			}
			let enm = $hxEnums[e];
			let params = enm.__constructs__[a._hx_index].__params__;
			let _g = 0;
			while(_g < params.length) {
				let f = params[_g];
				++_g;
				if(!Type.enumEq(a[f],b[f])) {
					return false;
				}
			}
		} catch( _g ) {
			return false;
		}
		return true;
	}
	static enumParameters(e) {
		let enm = $hxEnums[e.__enum__];
		let params = enm.__constructs__[e._hx_index].__params__;
		if(params != null) {
			let _g = [];
			let _g1 = 0;
			while(_g1 < params.length) {
				let p = params[_g1];
				++_g1;
				_g.push(e[p]);
			}
			return _g;
		} else {
			return [];
		}
	}
}
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
class XmlType {
	static toString(this1) {
		switch(this1) {
		case 0:
			return "Element";
		case 1:
			return "PCData";
		case 2:
			return "CData";
		case 3:
			return "Comment";
		case 4:
			return "DocType";
		case 5:
			return "ProcessingInstruction";
		case 6:
			return "Document";
		}
	}
}
class Xml {
	constructor(nodeType) {
		this.nodeType = nodeType;
		this.children = [];
		this.attributeMap = new haxe_ds_StringMap();
	}
	get(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	exists(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return Object.prototype.hasOwnProperty.call(this.attributeMap.h,att);
	}
	attributes() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.attributeMap.h);
	}
	elements() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = this.children;
		while(_g1 < _g2.length) {
			let child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		let ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	elementsNamed(name) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = this.children;
		while(_g1 < _g2.length) {
			let child = _g2[_g1];
			++_g1;
			let tmp;
			if(child.nodeType == Xml.Element) {
				if(child.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				tmp = child.nodeName == name;
			} else {
				tmp = false;
			}
			if(tmp) {
				_g.push(child);
			}
		}
		let ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	firstElement() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	toString() {
		return haxe_xml_Printer.print(this);
	}
}
$hxClasses["Xml"] = Xml;
Xml.__name__ = "Xml";
Object.assign(Xml.prototype, {
	__class__: Xml
});
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:"haxe.StackItem",__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
class haxe_CallStack {
	static callStack() {
		return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
	}
}
class haxe_IMap {
}
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
Object.assign(haxe_IMap.prototype, {
	__class__: haxe_IMap
});
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	unwrap() {
		return this.__nativeException;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.__super__ = Error;
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
	,__properties__: {get_native: "get_native"}
});
class haxe__$Int64__$_$_$Int64 {
	constructor(high,low) {
		this.high = high;
		this.low = low;
	}
}
$hxClasses["haxe._Int64.___Int64"] = haxe__$Int64__$_$_$Int64;
haxe__$Int64__$_$_$Int64.__name__ = "haxe._Int64.___Int64";
Object.assign(haxe__$Int64__$_$_$Int64.prototype, {
	__class__: haxe__$Int64__$_$_$Int64
});
class haxe_Log {
	static formatOutput(v,infos) {
		let str = Std.string(v);
		if(infos == null) {
			return str;
		}
		let pstr = infos.fileName + ":" + infos.lineNumber;
		if(infos.customParams != null) {
			let _g = 0;
			let _g1 = infos.customParams;
			while(_g < _g1.length) {
				let v = _g1[_g];
				++_g;
				str += ", " + Std.string(v);
			}
		}
		return pstr + ": " + str;
	}
	static trace(v,infos) {
		let str = haxe_Log.formatOutput(v,infos);
		if(typeof(console) != "undefined" && console.log != null) {
			console.log(str);
		}
	}
}
$hxClasses["haxe.Log"] = haxe_Log;
haxe_Log.__name__ = "haxe.Log";
class haxe_NativeStackTrace {
	static callStack() {
		let e = new Error("");
		let stack = haxe_NativeStackTrace.tryHaxeStack(e);
		if(typeof(stack) == "undefined") {
			try {
				throw e;
			} catch( _g ) {
			}
			stack = e.stack;
		}
		return haxe_NativeStackTrace.normalize(stack,2);
	}
	static toHaxe(s,skip) {
		if(skip == null) {
			skip = 0;
		}
		if(s == null) {
			return [];
		} else if(typeof(s) == "string") {
			let stack = s.split("\n");
			if(stack[0] == "Error") {
				stack.shift();
			}
			let m = [];
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) {
				let i = _g++;
				if(skip > i) {
					continue;
				}
				let line = stack[i];
				let matched = line.match(/^    at ([$A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
				if(matched != null) {
					let path = matched[1].split(".");
					if(path[0] == "$hxClasses") {
						path.shift();
					}
					let meth = path.pop();
					let file = matched[2];
					let line = Std.parseInt(matched[3]);
					let column = Std.parseInt(matched[4]);
					m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line,column));
				} else {
					m.push(haxe_StackItem.Module(StringTools.trim(line)));
				}
			}
			return m;
		} else if(skip > 0 && Array.isArray(s)) {
			return s.slice(skip);
		} else {
			return s;
		}
	}
	static tryHaxeStack(e) {
		if(e == null) {
			return [];
		}
		let oldValue = Error.prepareStackTrace;
		Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
		let stack = e.stack;
		Error.prepareStackTrace = oldValue;
		return stack;
	}
	static prepareHxStackTrace(e,callsites) {
		let stack = [];
		let _g = 0;
		while(_g < callsites.length) {
			let site = callsites[_g];
			++_g;
			if(haxe_NativeStackTrace.wrapCallSite != null) {
				site = haxe_NativeStackTrace.wrapCallSite(site);
			}
			let method = null;
			let fullName = site.getFunctionName();
			if(fullName != null) {
				let idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					let className = fullName.substring(0,idx);
					let methodName = fullName.substring(idx + 1);
					method = haxe_StackItem.Method(className,methodName);
				} else {
					method = haxe_StackItem.Method(null,fullName);
				}
			}
			let fileName = site.getFileName();
			let fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
			if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
				fileName = fileName.substring(fileAddr + 6);
			}
			stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
		}
		return stack;
	}
	static normalize(stack,skipItems) {
		if(skipItems == null) {
			skipItems = 0;
		}
		if(Array.isArray(stack) && skipItems > 0) {
			return stack.slice(skipItems);
		} else if(typeof(stack) == "string") {
			switch(stack.substring(0,6)) {
			case "Error\n":case "Error:":
				++skipItems;
				break;
			default:
			}
			return haxe_NativeStackTrace.skipLines(stack,skipItems);
		} else {
			return stack;
		}
	}
	static skipLines(stack,skip,pos) {
		if(pos == null) {
			pos = 0;
		}
		if(skip > 0) {
			pos = stack.indexOf("\n",pos);
			if(pos < 0) {
				return "";
			} else {
				return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
			}
		} else {
			return stack.substring(pos);
		}
	}
}
$hxClasses["haxe.NativeStackTrace"] = haxe_NativeStackTrace;
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
	unwrap() {
		return this.value;
	}
}
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
});
class haxe_ds_BalancedTree {
	constructor() {
	}
	set(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	get(key) {
		let node = this.root;
		while(node != null) {
			let c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	keys() {
		let ret = [];
		this.keysLoop(this.root,ret);
		return new haxe_iterators_ArrayIterator(ret);
	}
	setLoop(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		let c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			let nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			let nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	keysLoop(node,acc) {
		if(node != null) {
			this.keysLoop(node.left,acc);
			acc.push(node.key);
			this.keysLoop(node.right,acc);
		}
	}
	balance(l,k,v,r) {
		let hl = l == null ? 0 : l._height;
		let hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			let _this = l.left;
			let _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			let _this = r.right;
			let _this1 = r.left;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	compare(k1,k2) {
		return Reflect.compare(k1,k2);
	}
}
$hxClasses["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree;
haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree";
haxe_ds_BalancedTree.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_BalancedTree.prototype, {
	__class__: haxe_ds_BalancedTree
});
class haxe_ds_TreeNode {
	constructor(l,k,v,r,h) {
		if(h == null) {
			h = -1;
		}
		this.left = l;
		this.key = k;
		this.value = v;
		this.right = r;
		if(h == -1) {
			let tmp;
			let _this = this.left;
			let _this1 = this.right;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				let _this = this.left;
				tmp = _this == null ? 0 : _this._height;
			} else {
				let _this = this.right;
				tmp = _this == null ? 0 : _this._height;
			}
			this._height = tmp + 1;
		} else {
			this._height = h;
		}
	}
}
$hxClasses["haxe.ds.TreeNode"] = haxe_ds_TreeNode;
haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode";
Object.assign(haxe_ds_TreeNode.prototype, {
	__class__: haxe_ds_TreeNode
});
class haxe_ds_EnumValueMap extends haxe_ds_BalancedTree {
	constructor() {
		super();
	}
	compare(k1,k2) {
		let d = k1._hx_index - k2._hx_index;
		if(d != 0) {
			return d;
		}
		let p1 = Type.enumParameters(k1);
		let p2 = Type.enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	compareArgs(a1,a2) {
		let ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		let _g = 0;
		let _g1 = a1.length;
		while(_g < _g1) {
			let i = _g++;
			let d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	compareArg(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
}
$hxClasses["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap;
haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap";
haxe_ds_EnumValueMap.__interfaces__ = [haxe_IMap];
haxe_ds_EnumValueMap.__super__ = haxe_ds_BalancedTree;
Object.assign(haxe_ds_EnumValueMap.prototype, {
	__class__: haxe_ds_EnumValueMap
});
class haxe_ds_IntMap {
	constructor() {
		this.h = { };
	}
	set(key,value) {
		this.h[key] = value;
	}
	get(key) {
		return this.h[key];
	}
	keys() {
		let a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
		return new haxe_iterators_ArrayIterator(a);
	}
}
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_IntMap.prototype, {
	__class__: haxe_ds_IntMap
});
class haxe_ds_List {
	constructor() {
		this.length = 0;
	}
	add(item) {
		let x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	push(item) {
		let x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	pop() {
		if(this.h == null) {
			return null;
		}
		let x = this.h.item;
		this.h = this.h.next;
		if(this.h == null) {
			this.q = null;
		}
		this.length--;
		return x;
	}
}
$hxClasses["haxe.ds.List"] = haxe_ds_List;
haxe_ds_List.__name__ = "haxe.ds.List";
Object.assign(haxe_ds_List.prototype, {
	__class__: haxe_ds_List
});
class haxe_ds__$List_ListNode {
	constructor(item,next) {
		this.item = item;
		this.next = next;
	}
}
$hxClasses["haxe.ds._List.ListNode"] = haxe_ds__$List_ListNode;
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
Object.assign(haxe_ds__$List_ListNode.prototype, {
	__class__: haxe_ds__$List_ListNode
});
class haxe_ds_ObjectMap {
	constructor() {
		this.h = { __keys__ : { }};
	}
	set(key,value) {
		let id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	get(key) {
		return this.h[key.__id__];
	}
	keys() {
		let a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
}
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_ObjectMap.prototype, {
	__class__: haxe_ds_ObjectMap
});
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
	get(key) {
		return this.h[key];
	}
	set(key,value) {
		this.h[key] = value;
	}
	keys() {
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.h);
	}
}
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
});
class haxe_ds__$StringMap_StringMapKeyIterator {
	constructor(h) {
		this.h = h;
		this.keys = Object.keys(h);
		this.length = this.keys.length;
		this.current = 0;
	}
	hasNext() {
		return this.current < this.length;
	}
	next() {
		return this.keys[this.current++];
	}
}
$hxClasses["haxe.ds._StringMap.StringMapKeyIterator"] = haxe_ds__$StringMap_StringMapKeyIterator;
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
Object.assign(haxe_ds__$StringMap_StringMapKeyIterator.prototype, {
	__class__: haxe_ds__$StringMap_StringMapKeyIterator
});
class haxe_ds_Vector {
	static blit(src,srcPos,dest,destPos,len) {
		if(src == dest) {
			if(srcPos < destPos) {
				let i = srcPos + len;
				let j = destPos + len;
				let _g = 0;
				let _g1 = len;
				while(_g < _g1) {
					let k = _g++;
					--i;
					--j;
					src[j] = src[i];
				}
			} else if(srcPos > destPos) {
				let i = srcPos;
				let j = destPos;
				let _g = 0;
				let _g1 = len;
				while(_g < _g1) {
					let k = _g++;
					src[j] = src[i];
					++i;
					++j;
				}
			}
		} else {
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				dest[destPos + i] = src[srcPos + i];
			}
		}
	}
}
class haxe_io_Path {
	constructor(path) {
		switch(path) {
		case ".":case "..":
			this.dir = path;
			this.file = "";
			return;
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			this.dir = HxOverrides.substr(path,0,c2);
			path = HxOverrides.substr(path,c2 + 1,null);
			this.backslash = true;
		} else if(c2 < c1) {
			this.dir = HxOverrides.substr(path,0,c1);
			path = HxOverrides.substr(path,c1 + 1,null);
		} else {
			this.dir = null;
		}
		let cp = path.lastIndexOf(".");
		if(cp != -1) {
			this.ext = HxOverrides.substr(path,cp + 1,null);
			this.file = HxOverrides.substr(path,0,cp);
		} else {
			this.ext = null;
			this.file = path;
		}
	}
	static directory(path) {
		let s = new haxe_io_Path(path);
		if(s.dir == null) {
			return "";
		}
		return s.dir;
	}
	static join(paths) {
		let _g = [];
		let _g1 = 0;
		let _g2 = paths;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if(v != null && v != "") {
				_g.push(v);
			}
		}
		let paths1 = _g;
		if(paths1.length == 0) {
			return "";
		}
		let path = paths1[0];
		let _g3 = 1;
		let _g4 = paths1.length;
		while(_g3 < _g4) {
			let i = _g3++;
			path = haxe_io_Path.addTrailingSlash(path);
			path += paths1[i];
		}
		return haxe_io_Path.normalize(path);
	}
	static normalize(path) {
		let slash = "/";
		path = path.split("\\").join(slash);
		if(path == slash) {
			return slash;
		}
		let target = [];
		let _g = 0;
		let _g1 = path.split(slash);
		while(_g < _g1.length) {
			let token = _g1[_g];
			++_g;
			if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
				target.pop();
			} else if(token == "") {
				if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
					target.push(token);
				}
			} else if(token != ".") {
				target.push(token);
			}
		}
		let tmp = target.join(slash);
		let acc_b = "";
		let colon = false;
		let slashes = false;
		let _g_offset = 0;
		let _g_s = tmp;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let c2 = c1;
			switch(c2) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					let i = c2;
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += String.fromCodePoint(i);
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				let i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
		}
		return acc_b;
	}
	static addTrailingSlash(path) {
		if(path.length == 0) {
			return "/";
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			if(c2 != path.length - 1) {
				return path + "\\";
			} else {
				return path;
			}
		} else if(c1 != path.length - 1) {
			return path + "/";
		} else {
			return path;
		}
	}
	static isAbsolute(path) {
		if(path.startsWith("/")) {
			return true;
		}
		if(path.charAt(1) == ":") {
			return true;
		}
		if(path.startsWith("\\\\")) {
			return true;
		}
		return false;
	}
}
$hxClasses["haxe.io.Path"] = haxe_io_Path;
haxe_io_Path.__name__ = "haxe.io.Path";
Object.assign(haxe_io_Path.prototype, {
	__class__: haxe_io_Path
});
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
});
var haxe_rtti_CType = $hxEnums["haxe.rtti.CType"] = { __ename__:"haxe.rtti.CType",__constructs__:null
	,CUnknown: {_hx_name:"CUnknown",_hx_index:0,__enum__:"haxe.rtti.CType",toString:$estr}
	,CEnum: ($_=function(name,params) { return {_hx_index:1,name:name,params:params,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CEnum",$_.__params__ = ["name","params"],$_)
	,CClass: ($_=function(name,params) { return {_hx_index:2,name:name,params:params,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CClass",$_.__params__ = ["name","params"],$_)
	,CTypedef: ($_=function(name,params) { return {_hx_index:3,name:name,params:params,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CTypedef",$_.__params__ = ["name","params"],$_)
	,CFunction: ($_=function(args,ret) { return {_hx_index:4,args:args,ret:ret,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CFunction",$_.__params__ = ["args","ret"],$_)
	,CAnonymous: ($_=function(fields) { return {_hx_index:5,fields:fields,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CAnonymous",$_.__params__ = ["fields"],$_)
	,CDynamic: ($_=function(t) { return {_hx_index:6,t:t,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CDynamic",$_.__params__ = ["t"],$_)
	,CAbstract: ($_=function(name,params) { return {_hx_index:7,name:name,params:params,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CAbstract",$_.__params__ = ["name","params"],$_)
};
haxe_rtti_CType.__constructs__ = [haxe_rtti_CType.CUnknown,haxe_rtti_CType.CEnum,haxe_rtti_CType.CClass,haxe_rtti_CType.CTypedef,haxe_rtti_CType.CFunction,haxe_rtti_CType.CAnonymous,haxe_rtti_CType.CDynamic,haxe_rtti_CType.CAbstract];
var haxe_rtti_Rights = $hxEnums["haxe.rtti.Rights"] = { __ename__:"haxe.rtti.Rights",__constructs__:null
	,RNormal: {_hx_name:"RNormal",_hx_index:0,__enum__:"haxe.rtti.Rights",toString:$estr}
	,RNo: {_hx_name:"RNo",_hx_index:1,__enum__:"haxe.rtti.Rights",toString:$estr}
	,RCall: ($_=function(m) { return {_hx_index:2,m:m,__enum__:"haxe.rtti.Rights",toString:$estr}; },$_._hx_name="RCall",$_.__params__ = ["m"],$_)
	,RMethod: {_hx_name:"RMethod",_hx_index:3,__enum__:"haxe.rtti.Rights",toString:$estr}
	,RDynamic: {_hx_name:"RDynamic",_hx_index:4,__enum__:"haxe.rtti.Rights",toString:$estr}
	,RInline: {_hx_name:"RInline",_hx_index:5,__enum__:"haxe.rtti.Rights",toString:$estr}
};
haxe_rtti_Rights.__constructs__ = [haxe_rtti_Rights.RNormal,haxe_rtti_Rights.RNo,haxe_rtti_Rights.RCall,haxe_rtti_Rights.RMethod,haxe_rtti_Rights.RDynamic,haxe_rtti_Rights.RInline];
var haxe_rtti_TypeTree = $hxEnums["haxe.rtti.TypeTree"] = { __ename__:"haxe.rtti.TypeTree",__constructs__:null
	,TPackage: ($_=function(name,full,subs) { return {_hx_index:0,name:name,full:full,subs:subs,__enum__:"haxe.rtti.TypeTree",toString:$estr}; },$_._hx_name="TPackage",$_.__params__ = ["name","full","subs"],$_)
	,TClassdecl: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"haxe.rtti.TypeTree",toString:$estr}; },$_._hx_name="TClassdecl",$_.__params__ = ["c"],$_)
	,TEnumdecl: ($_=function(e) { return {_hx_index:2,e:e,__enum__:"haxe.rtti.TypeTree",toString:$estr}; },$_._hx_name="TEnumdecl",$_.__params__ = ["e"],$_)
	,TTypedecl: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxe.rtti.TypeTree",toString:$estr}; },$_._hx_name="TTypedecl",$_.__params__ = ["t"],$_)
	,TAbstractdecl: ($_=function(a) { return {_hx_index:4,a:a,__enum__:"haxe.rtti.TypeTree",toString:$estr}; },$_._hx_name="TAbstractdecl",$_.__params__ = ["a"],$_)
};
haxe_rtti_TypeTree.__constructs__ = [haxe_rtti_TypeTree.TPackage,haxe_rtti_TypeTree.TClassdecl,haxe_rtti_TypeTree.TEnumdecl,haxe_rtti_TypeTree.TTypedecl,haxe_rtti_TypeTree.TAbstractdecl];
class haxe_rtti_TypeApi {
	static typeInfos(t) {
		let inf;
		switch(t._hx_index) {
		case 0:
			let _g = t.name;
			let _g1 = t.full;
			let _g2 = t.subs;
			throw haxe_Exception.thrown("Unexpected Package");
		case 1:
			let c = t.c;
			inf = c;
			break;
		case 2:
			let e = t.e;
			inf = e;
			break;
		case 3:
			let t1 = t.t;
			inf = t1;
			break;
		case 4:
			let a = t.a;
			inf = a;
			break;
		}
		return inf;
	}
	static leq(f,l1,l2) {
		let it_current = 0;
		let it_array = l2;
		let _g = 0;
		while(_g < l1.length) {
			let e1 = l1[_g];
			++_g;
			if(it_current >= it_array.length) {
				return false;
			}
			let e2 = it_array[it_current++];
			if(!f(e1,e2)) {
				return false;
			}
		}
		if(it_current < it_array.length) {
			return false;
		}
		return true;
	}
	static rightsEq(r1,r2) {
		if(r1 == r2) {
			return true;
		}
		if(r1._hx_index == 2) {
			let m1 = r1.m;
			if(r2._hx_index == 2) {
				let m2 = r2.m;
				return m1 == m2;
			}
		}
		return false;
	}
	static typeEq(t1,t2) {
		switch(t1._hx_index) {
		case 0:
			return t2 == haxe_rtti_CType.CUnknown;
		case 1:
			let name = t1.name;
			let params = t1.params;
			if(t2._hx_index == 1) {
				let name2 = t2.name;
				let params2 = t2.params;
				if(name == name2) {
					return haxe_rtti_TypeApi.leq(haxe_rtti_TypeApi.typeEq,params,params2);
				} else {
					return false;
				}
			}
			break;
		case 2:
			let name1 = t1.name;
			let params1 = t1.params;
			if(t2._hx_index == 2) {
				let name2 = t2.name;
				let params2 = t2.params;
				if(name1 == name2) {
					return haxe_rtti_TypeApi.leq(haxe_rtti_TypeApi.typeEq,params1,params2);
				} else {
					return false;
				}
			}
			break;
		case 3:
			let name2 = t1.name;
			let params2 = t1.params;
			if(t2._hx_index == 3) {
				let name21 = t2.name;
				let params21 = t2.params;
				if(name2 == name21) {
					return haxe_rtti_TypeApi.leq(haxe_rtti_TypeApi.typeEq,params2,params21);
				} else {
					return false;
				}
			}
			break;
		case 4:
			let args = t1.args;
			let ret = t1.ret;
			if(t2._hx_index == 4) {
				let args2 = t2.args;
				let ret2 = t2.ret;
				if(haxe_rtti_TypeApi.leq(function(a,b) {
					if(a.name == b.name && a.opt == b.opt) {
						return haxe_rtti_TypeApi.typeEq(a.t,b.t);
					} else {
						return false;
					}
				},args,args2)) {
					return haxe_rtti_TypeApi.typeEq(ret,ret2);
				} else {
					return false;
				}
			}
			break;
		case 5:
			let fields = t1.fields;
			if(t2._hx_index == 5) {
				let fields2 = t2.fields;
				return haxe_rtti_TypeApi.leq(function(a,b) {
					return haxe_rtti_TypeApi.fieldEq(a,b);
				},fields,fields2);
			}
			break;
		case 6:
			let t = t1.t;
			if(t2._hx_index == 6) {
				let t21 = t2.t;
				if(t == null != (t21 == null)) {
					return false;
				}
				if(t != null) {
					return haxe_rtti_TypeApi.typeEq(t,t21);
				} else {
					return true;
				}
			}
			break;
		case 7:
			let name3 = t1.name;
			let params3 = t1.params;
			if(t2._hx_index == 7) {
				let name2 = t2.name;
				let params2 = t2.params;
				if(name3 == name2) {
					return haxe_rtti_TypeApi.leq(haxe_rtti_TypeApi.typeEq,params3,params2);
				} else {
					return false;
				}
			}
			break;
		}
		return false;
	}
	static fieldEq(f1,f2) {
		if(f1.name != f2.name) {
			return false;
		}
		if(!haxe_rtti_TypeApi.typeEq(f1.type,f2.type)) {
			return false;
		}
		if(f1.isPublic != f2.isPublic) {
			return false;
		}
		if(f1.doc != f2.doc) {
			return false;
		}
		if(!haxe_rtti_TypeApi.rightsEq(f1.get,f2.get)) {
			return false;
		}
		if(!haxe_rtti_TypeApi.rightsEq(f1.set,f2.set)) {
			return false;
		}
		if(f1.params == null != (f2.params == null)) {
			return false;
		}
		if(f1.params != null && f1.params.join(":") != f2.params.join(":")) {
			return false;
		}
		return true;
	}
	static constructorEq(c1,c2) {
		if(c1.name != c2.name) {
			return false;
		}
		if(c1.doc != c2.doc) {
			return false;
		}
		if(c1.args == null != (c2.args == null)) {
			return false;
		}
		if(c1.args != null && !haxe_rtti_TypeApi.leq(function(a,b) {
			if(a.name == b.name && a.opt == b.opt) {
				return haxe_rtti_TypeApi.typeEq(a.t,b.t);
			} else {
				return false;
			}
		},c1.args,c2.args)) {
			return false;
		}
		return true;
	}
}
$hxClasses["haxe.rtti.TypeApi"] = haxe_rtti_TypeApi;
haxe_rtti_TypeApi.__name__ = "haxe.rtti.TypeApi";
class haxe_rtti_XmlParser {
	constructor() {
		this.root = [];
	}
	process(x,platform) {
		this.curplatform = platform;
		if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		this.xroot(x);
	}
	mergeRights(f1,f2) {
		if(f1.get == haxe_rtti_Rights.RInline && f1.set == haxe_rtti_Rights.RNo && f2.get == haxe_rtti_Rights.RNormal && f2.set == haxe_rtti_Rights.RMethod) {
			f1.get = haxe_rtti_Rights.RNormal;
			f1.set = haxe_rtti_Rights.RMethod;
			return true;
		}
		if(Type.enumEq(f1.get,f2.get)) {
			return Type.enumEq(f1.set,f2.set);
		} else {
			return false;
		}
	}
	mergeDoc(f1,f2) {
		if(f1.doc == null) {
			f1.doc = f2.doc;
		} else if(f2.doc == null) {
			f2.doc = f1.doc;
		}
		return true;
	}
	mergeFields(f,f2) {
		if(!haxe_rtti_TypeApi.fieldEq(f,f2)) {
			if(f.name == f2.name && (this.mergeRights(f,f2) || this.mergeRights(f2,f)) && this.mergeDoc(f,f2)) {
				return haxe_rtti_TypeApi.fieldEq(f,f2);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	newField(c,f) {
	}
	mergeClasses(c,c2) {
		if(c.isInterface != c2.isInterface) {
			return false;
		}
		if(this.curplatform != null) {
			c.platforms.push(this.curplatform);
		}
		if(c.isExtern != c2.isExtern) {
			c.isExtern = false;
		}
		let _g = 0;
		let _g1 = c2.fields;
		while(_g < _g1.length) {
			let f2 = _g1[_g];
			++_g;
			let found = null;
			let _g2 = 0;
			let _g3 = c.fields;
			while(_g2 < _g3.length) {
				let f = _g3[_g2];
				++_g2;
				if(this.mergeFields(f,f2)) {
					found = f;
					break;
				}
			}
			if(found == null) {
				this.newField(c,f2);
				c.fields.push(f2);
			} else if(this.curplatform != null) {
				found.platforms.push(this.curplatform);
			}
		}
		let _g2 = 0;
		let _g3 = c2.statics;
		while(_g2 < _g3.length) {
			let f2 = _g3[_g2];
			++_g2;
			let found = null;
			let _g = 0;
			let _g1 = c.statics;
			while(_g < _g1.length) {
				let f = _g1[_g];
				++_g;
				if(this.mergeFields(f,f2)) {
					found = f;
					break;
				}
			}
			if(found == null) {
				this.newField(c,f2);
				c.statics.push(f2);
			} else if(this.curplatform != null) {
				found.platforms.push(this.curplatform);
			}
		}
		return true;
	}
	mergeEnums(e,e2) {
		if(e.isExtern != e2.isExtern) {
			return false;
		}
		if(this.curplatform != null) {
			e.platforms.push(this.curplatform);
		}
		let _g = 0;
		let _g1 = e2.constructors;
		while(_g < _g1.length) {
			let c2 = _g1[_g];
			++_g;
			let found = null;
			let _g2 = 0;
			let _g3 = e.constructors;
			while(_g2 < _g3.length) {
				let c = _g3[_g2];
				++_g2;
				if(haxe_rtti_TypeApi.constructorEq(c,c2)) {
					found = c;
					break;
				}
			}
			if(found == null) {
				e.constructors.push(c2);
			} else if(this.curplatform != null) {
				found.platforms.push(this.curplatform);
			}
		}
		return true;
	}
	mergeTypedefs(t,t2) {
		if(this.curplatform == null) {
			return false;
		}
		t.platforms.push(this.curplatform);
		t.types.h[this.curplatform] = t2.type;
		return true;
	}
	mergeAbstracts(a,a2) {
		if(this.curplatform == null) {
			return false;
		}
		if(a.to.length != a2.to.length || a.from.length != a2.from.length) {
			return false;
		}
		let _g = 0;
		let _g1 = a.to.length;
		while(_g < _g1) {
			let i = _g++;
			if(!haxe_rtti_TypeApi.typeEq(a.to[i].t,a2.to[i].t)) {
				return false;
			}
		}
		let _g2 = 0;
		let _g3 = a.from.length;
		while(_g2 < _g3) {
			let i = _g2++;
			if(!haxe_rtti_TypeApi.typeEq(a.from[i].t,a2.from[i].t)) {
				return false;
			}
		}
		if(a2.impl != null) {
			this.mergeClasses(a.impl,a2.impl);
		}
		a.platforms.push(this.curplatform);
		return true;
	}
	merge(t) {
		let inf = haxe_rtti_TypeApi.typeInfos(t);
		let pack = inf.path.split(".");
		let cur = this.root;
		let curpack = [];
		pack.pop();
		let _g = 0;
		while(_g < pack.length) {
			let p = pack[_g];
			++_g;
			let found = false;
			let _g1 = 0;
			while(_g1 < cur.length) {
				let pk = cur[_g1];
				++_g1;
				if(pk._hx_index == 0) {
					let _g = pk.full;
					let pname = pk.name;
					let subs = pk.subs;
					if(pname == p) {
						found = true;
						cur = subs;
						break;
					}
				}
			}
			curpack.push(p);
			if(!found) {
				let pk = [];
				cur.push(haxe_rtti_TypeTree.TPackage(p,curpack.join("."),pk));
				cur = pk;
			}
		}
		let _g1 = 0;
		while(_g1 < cur.length) {
			let ct = cur[_g1];
			++_g1;
			let tmp;
			if(ct._hx_index == 0) {
				let _g = ct.name;
				let _g1 = ct.full;
				let _g2 = ct.subs;
				tmp = true;
			} else {
				tmp = false;
			}
			if(tmp) {
				continue;
			}
			let tinf = haxe_rtti_TypeApi.typeInfos(ct);
			if(tinf.path == inf.path) {
				let sameType = true;
				if(tinf.doc == null != (inf.doc == null)) {
					if(inf.doc == null) {
						inf.doc = tinf.doc;
					} else {
						tinf.doc = inf.doc;
					}
				}
				if(tinf.path == "haxe._Int64.NativeInt64") {
					continue;
				}
				if(tinf.module == inf.module && tinf.doc == inf.doc && tinf.isPrivate == inf.isPrivate) {
					switch(ct._hx_index) {
					case 0:
						let _g = ct.name;
						let _g1 = ct.full;
						let _g2 = ct.subs;
						sameType = false;
						break;
					case 1:
						let c = ct.c;
						if(t._hx_index == 1) {
							let c2 = t.c;
							if(this.mergeClasses(c,c2)) {
								return;
							}
						} else {
							sameType = false;
						}
						break;
					case 2:
						let e = ct.e;
						if(t._hx_index == 2) {
							let e2 = t.e;
							if(this.mergeEnums(e,e2)) {
								return;
							}
						} else {
							sameType = false;
						}
						break;
					case 3:
						let td = ct.t;
						if(t._hx_index == 3) {
							let td2 = t.t;
							if(this.mergeTypedefs(td,td2)) {
								return;
							}
						}
						break;
					case 4:
						let a = ct.a;
						if(t._hx_index == 4) {
							let a2 = t.a;
							if(this.mergeAbstracts(a,a2)) {
								return;
							}
						} else {
							sameType = false;
						}
						break;
					}
				}
				let msg = tinf.module != inf.module ? "module " + inf.module + " should be " + tinf.module : tinf.doc != inf.doc ? "documentation is different" : tinf.isPrivate != inf.isPrivate ? "private flag is different" : !sameType ? "type kind is different" : "could not merge definition";
				throw haxe_Exception.thrown("Incompatibilities between " + tinf.path + " in " + tinf.platforms.join(",") + " and " + this.curplatform + " (" + msg + ")");
			}
		}
		cur.push(t);
	}
	mkPath(p) {
		return p;
	}
	mkTypeParams(p) {
		let pl = p.split(":");
		if(pl[0] == "") {
			return [];
		}
		return pl;
	}
	mkRights(r) {
		switch(r) {
		case "dynamic":
			return haxe_rtti_Rights.RDynamic;
		case "inline":
			return haxe_rtti_Rights.RInline;
		case "method":
			return haxe_rtti_Rights.RMethod;
		case "null":
			return haxe_rtti_Rights.RNo;
		default:
			return haxe_rtti_Rights.RCall(r);
		}
	}
	xerror(c) {
		let tmp;
		if(c.nodeType == Xml.Document) {
			tmp = "Document";
		} else {
			if(c.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c.nodeType == null ? "null" : XmlType.toString(c.nodeType)));
			}
			tmp = c.nodeName;
		}
		throw haxe_Exception.thrown("Invalid " + tmp);
	}
	xroot(x) {
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			this.merge(this.processElement(c1));
		}
	}
	processElement(x) {
		if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		let c = x;
		let _g;
		if(c.nodeType == Xml.Document) {
			_g = "Document";
		} else {
			if(c.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c.nodeType == null ? "null" : XmlType.toString(c.nodeType)));
			}
			_g = c.nodeName;
		}
		switch(_g) {
		case "abstract":
			return haxe_rtti_TypeTree.TAbstractdecl(this.xabstract(c));
		case "class":
			return haxe_rtti_TypeTree.TClassdecl(this.xclass(c));
		case "enum":
			return haxe_rtti_TypeTree.TEnumdecl(this.xenum(c));
		case "typedef":
			return haxe_rtti_TypeTree.TTypedecl(this.xtypedef(c));
		default:
			return this.xerror(c);
		}
	}
	xmeta(x) {
		let ml = [];
		let _g = 0;
		let _g1 = haxe_xml__$Access_NodeListAccess.resolve(x,"m");
		while(_g < _g1.length) {
			let m = _g1[_g];
			++_g;
			let pl = [];
			let _g2 = 0;
			let _g3 = haxe_xml__$Access_NodeListAccess.resolve(m,"e");
			while(_g2 < _g3.length) {
				let p = _g3[_g2];
				++_g2;
				pl.push(haxe_xml_Access.get_innerHTML(p));
			}
			ml.push({ name : haxe_xml__$Access_AttribAccess.resolve(m,"n"), params : pl});
		}
		return ml;
	}
	xoverloads(x) {
		let l = [];
		let m = x.elements();
		while(m.hasNext()) {
			let m1 = m.next();
			l.push(this.xclassfield(m1));
		}
		return l;
	}
	xpath(x) {
		let path = this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path"));
		let params = [];
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			params.push(this.xtype(c1));
		}
		return { path : path, params : params};
	}
	xclass(x) {
		let csuper = null;
		let doc = null;
		let tdynamic = null;
		let interfaces = [];
		let fields = [];
		let statics = [];
		let meta = [];
		let isInterface = x.exists("interface");
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			let _g;
			if(c1.nodeType == Xml.Document) {
				_g = "Document";
			} else {
				if(c1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
				}
				_g = c1.nodeName;
			}
			switch(_g) {
			case "extends":
				if(isInterface) {
					interfaces.push(this.xpath(c1));
				} else {
					csuper = this.xpath(c1);
				}
				break;
			case "haxe_doc":
				doc = haxe_xml_Access.get_innerData(c1);
				break;
			case "haxe_dynamic":
				let x = c1.firstElement();
				if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
				}
				tdynamic = this.xtype(x);
				break;
			case "implements":
				interfaces.push(this.xpath(c1));
				break;
			case "meta":
				meta = this.xmeta(c1);
				break;
			default:
				if(c1.exists("static")) {
					statics.push(this.xclassfield(c1));
				} else {
					fields.push(this.xclassfield(c1));
				}
			}
		}
		return { file : haxe_xml__$Access_HasAttribAccess.resolve(x,"file") ? haxe_xml__$Access_AttribAccess.resolve(x,"file") : null, path : this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")), module : haxe_xml__$Access_HasAttribAccess.resolve(x,"module") ? this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"module")) : null, doc : doc, isPrivate : x.exists("private"), isExtern : x.exists("extern"), isFinal : x.exists("final"), isInterface : isInterface, params : this.mkTypeParams(haxe_xml__$Access_AttribAccess.resolve(x,"params")), superClass : csuper, interfaces : interfaces, fields : fields, statics : statics, tdynamic : tdynamic, platforms : this.defplat(), meta : meta};
	}
	xclassfield(x,defPublic) {
		if(defPublic == null) {
			defPublic = false;
		}
		let e = x.elements();
		let t = this.xtype(e.next());
		let doc = null;
		let meta = [];
		let overloads = null;
		let c = e;
		while(c.hasNext()) {
			let c1 = c.next();
			let _g;
			if(c1.nodeType == Xml.Document) {
				_g = "Document";
			} else {
				if(c1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
				}
				_g = c1.nodeName;
			}
			switch(_g) {
			case "haxe_doc":
				doc = haxe_xml_Access.get_innerData(c1);
				break;
			case "meta":
				meta = this.xmeta(c1);
				break;
			case "overloads":
				overloads = this.xoverloads(c1);
				break;
			default:
				this.xerror(c1);
			}
		}
		let tmp;
		if(x.nodeType == Xml.Document) {
			tmp = "Document";
		} else {
			if(x.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
			}
			tmp = x.nodeName;
		}
		return { name : tmp, type : t, isPublic : x.exists("public") || defPublic, isFinal : x.exists("final"), isOverride : x.exists("override"), line : haxe_xml__$Access_HasAttribAccess.resolve(x,"line") ? Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(x,"line")) : null, doc : doc, get : haxe_xml__$Access_HasAttribAccess.resolve(x,"get") ? this.mkRights(haxe_xml__$Access_AttribAccess.resolve(x,"get")) : haxe_rtti_Rights.RNormal, set : haxe_xml__$Access_HasAttribAccess.resolve(x,"set") ? this.mkRights(haxe_xml__$Access_AttribAccess.resolve(x,"set")) : haxe_rtti_Rights.RNormal, params : haxe_xml__$Access_HasAttribAccess.resolve(x,"params") ? this.mkTypeParams(haxe_xml__$Access_AttribAccess.resolve(x,"params")) : [], platforms : this.defplat(), meta : meta, overloads : overloads, expr : haxe_xml__$Access_HasAttribAccess.resolve(x,"expr") ? haxe_xml__$Access_AttribAccess.resolve(x,"expr") : null};
	}
	xenum(x) {
		let cl = [];
		let doc = null;
		let meta = [];
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			let tmp;
			if(c1.nodeType == Xml.Document) {
				tmp = "Document";
			} else {
				if(c1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
				}
				tmp = c1.nodeName;
			}
			if(tmp == "haxe_doc") {
				doc = haxe_xml_Access.get_innerData(c1);
			} else {
				let tmp;
				if(c1.nodeType == Xml.Document) {
					tmp = "Document";
				} else {
					if(c1.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
					}
					tmp = c1.nodeName;
				}
				if(tmp == "meta") {
					meta = this.xmeta(c1);
				} else {
					cl.push(this.xenumfield(c1));
				}
			}
		}
		return { file : haxe_xml__$Access_HasAttribAccess.resolve(x,"file") ? haxe_xml__$Access_AttribAccess.resolve(x,"file") : null, path : this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")), module : haxe_xml__$Access_HasAttribAccess.resolve(x,"module") ? this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"module")) : null, doc : doc, isPrivate : x.exists("private"), isExtern : x.exists("extern"), params : this.mkTypeParams(haxe_xml__$Access_AttribAccess.resolve(x,"params")), constructors : cl, platforms : this.defplat(), meta : meta};
	}
	xenumfield(x) {
		let args = null;
		let docElements = x.elementsNamed("haxe_doc");
		let xdoc = docElements.hasNext() ? docElements.next() : null;
		let meta = haxe_xml__$Access_HasNodeAccess.resolve(x,"meta") ? this.xmeta(haxe_xml__$Access_NodeAccess.resolve(x,"meta")) : [];
		if(haxe_xml__$Access_HasAttribAccess.resolve(x,"a")) {
			let names = haxe_xml__$Access_AttribAccess.resolve(x,"a").split(":");
			let elts = x.elements();
			args = [];
			let _g = 0;
			while(_g < names.length) {
				let c = names[_g];
				++_g;
				let opt = false;
				if(c.charAt(0) == "?") {
					opt = true;
					c = HxOverrides.substr(c,1,null);
				}
				args.push({ name : c, opt : opt, t : this.xtype(elts.next())});
			}
		}
		let tmp;
		if(x.nodeType == Xml.Document) {
			tmp = "Document";
		} else {
			if(x.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
			}
			tmp = x.nodeName;
		}
		let tmp1;
		if(xdoc == null) {
			tmp1 = null;
		} else {
			if(xdoc.nodeType != Xml.Document && xdoc.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Invalid nodeType " + (xdoc.nodeType == null ? "null" : XmlType.toString(xdoc.nodeType)));
			}
			tmp1 = haxe_xml_Access.get_innerData(xdoc);
		}
		return { name : tmp, args : args, doc : tmp1, meta : meta, platforms : this.defplat()};
	}
	xabstract(x) {
		let doc = null;
		let impl = null;
		let athis = null;
		let meta = [];
		let to = [];
		let from = [];
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			let _g;
			if(c1.nodeType == Xml.Document) {
				_g = "Document";
			} else {
				if(c1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
				}
				_g = c1.nodeName;
			}
			switch(_g) {
			case "from":
				let t = c1.elements();
				while(t.hasNext()) {
					let t1 = t.next();
					let x = t1.firstElement();
					if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
					}
					from.push({ t : this.xtype(x), field : haxe_xml__$Access_HasAttribAccess.resolve(t1,"field") ? haxe_xml__$Access_AttribAccess.resolve(t1,"field") : null});
				}
				break;
			case "haxe_doc":
				doc = haxe_xml_Access.get_innerData(c1);
				break;
			case "impl":
				impl = this.xclass(haxe_xml__$Access_NodeAccess.resolve(c1,"class"));
				break;
			case "meta":
				meta = this.xmeta(c1);
				break;
			case "this":
				let x = c1.firstElement();
				if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
				}
				athis = this.xtype(x);
				break;
			case "to":
				let t1 = c1.elements();
				while(t1.hasNext()) {
					let t = t1.next();
					let x = t.firstElement();
					if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
					}
					to.push({ t : this.xtype(x), field : haxe_xml__$Access_HasAttribAccess.resolve(t,"field") ? haxe_xml__$Access_AttribAccess.resolve(t,"field") : null});
				}
				break;
			default:
				this.xerror(c1);
			}
		}
		return { file : haxe_xml__$Access_HasAttribAccess.resolve(x,"file") ? haxe_xml__$Access_AttribAccess.resolve(x,"file") : null, path : this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")), module : haxe_xml__$Access_HasAttribAccess.resolve(x,"module") ? this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"module")) : null, doc : doc, isPrivate : x.exists("private"), params : this.mkTypeParams(haxe_xml__$Access_AttribAccess.resolve(x,"params")), platforms : this.defplat(), meta : meta, athis : athis, to : to, from : from, impl : impl};
	}
	xtypedef(x) {
		let doc = null;
		let t = null;
		let meta = [];
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			let tmp;
			if(c1.nodeType == Xml.Document) {
				tmp = "Document";
			} else {
				if(c1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
				}
				tmp = c1.nodeName;
			}
			if(tmp == "haxe_doc") {
				doc = haxe_xml_Access.get_innerData(c1);
			} else {
				let tmp;
				if(c1.nodeType == Xml.Document) {
					tmp = "Document";
				} else {
					if(c1.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
					}
					tmp = c1.nodeName;
				}
				if(tmp == "meta") {
					meta = this.xmeta(c1);
				} else {
					t = this.xtype(c1);
				}
			}
		}
		let types = new haxe_ds_StringMap();
		if(this.curplatform != null) {
			types.h[this.curplatform] = t;
		}
		return { file : haxe_xml__$Access_HasAttribAccess.resolve(x,"file") ? haxe_xml__$Access_AttribAccess.resolve(x,"file") : null, path : this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")), module : haxe_xml__$Access_HasAttribAccess.resolve(x,"module") ? this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"module")) : null, doc : doc, isPrivate : x.exists("private"), params : this.mkTypeParams(haxe_xml__$Access_AttribAccess.resolve(x,"params")), type : t, types : types, platforms : this.defplat(), meta : meta};
	}
	xtype(x) {
		let _g;
		if(x.nodeType == Xml.Document) {
			_g = "Document";
		} else {
			if(x.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
			}
			_g = x.nodeName;
		}
		switch(_g) {
		case "a":
			let fields = [];
			let f = x.elements();
			while(f.hasNext()) {
				let f1 = f.next();
				let f2 = this.xclassfield(f1,true);
				f2.platforms = [];
				fields.push(f2);
			}
			return haxe_rtti_CType.CAnonymous(fields);
		case "c":
			return haxe_rtti_CType.CClass(this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")),this.xtypeparams(x));
		case "d":
			let t = null;
			let tx = x.firstElement();
			if(tx != null) {
				if(tx.nodeType != Xml.Document && tx.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Invalid nodeType " + (tx.nodeType == null ? "null" : XmlType.toString(tx.nodeType)));
				}
				t = this.xtype(tx);
			}
			return haxe_rtti_CType.CDynamic(t);
		case "e":
			return haxe_rtti_CType.CEnum(this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")),this.xtypeparams(x));
		case "f":
			let args = [];
			let aname = haxe_xml__$Access_AttribAccess.resolve(x,"a").split(":");
			let eargs_current = 0;
			let eargs_array = aname;
			let evalues = haxe_xml__$Access_HasAttribAccess.resolve(x,"v") ? new haxe_iterators_ArrayIterator(haxe_xml__$Access_AttribAccess.resolve(x,"v").split(":")) : null;
			let e = x.elements();
			while(e.hasNext()) {
				let e1 = e.next();
				let opt = false;
				let a = eargs_current < eargs_array.length ? eargs_array[eargs_current++] : null;
				if(a == null) {
					a = "";
				}
				if(a.charAt(0) == "?") {
					opt = true;
					a = HxOverrides.substr(a,1,null);
				}
				let v = evalues == null || evalues.current >= evalues.array.length ? null : evalues.array[evalues.current++];
				args.push({ name : a, opt : opt, t : this.xtype(e1), value : v == "" ? null : v});
			}
			let ret = args[args.length - 1];
			HxOverrides.remove(args,ret);
			return haxe_rtti_CType.CFunction(args,ret.t);
		case "t":
			return haxe_rtti_CType.CTypedef(this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")),this.xtypeparams(x));
		case "unknown":
			return haxe_rtti_CType.CUnknown;
		case "x":
			return haxe_rtti_CType.CAbstract(this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")),this.xtypeparams(x));
		default:
			return this.xerror(x);
		}
	}
	xtypeparams(x) {
		let p = [];
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			p.push(this.xtype(c1));
		}
		return p;
	}
	defplat() {
		let l = [];
		if(this.curplatform != null) {
			l.push(this.curplatform);
		}
		return l;
	}
}
$hxClasses["haxe.rtti.XmlParser"] = haxe_rtti_XmlParser;
haxe_rtti_XmlParser.__name__ = "haxe.rtti.XmlParser";
Object.assign(haxe_rtti_XmlParser.prototype, {
	__class__: haxe_rtti_XmlParser
});
class haxe_xml__$Access_NodeAccess {
	static resolve(this1,name) {
		let x = this1.elementsNamed(name).next();
		if(x == null) {
			let xname;
			if(this1.nodeType == Xml.Document) {
				xname = "Document";
			} else {
				if(this1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
				}
				xname = this1.nodeName;
			}
			throw haxe_Exception.thrown(xname + " is missing element " + name);
		}
		if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		return x;
	}
}
class haxe_xml__$Access_AttribAccess {
	static resolve(this1,name) {
		if(this1.nodeType == Xml.Document) {
			throw haxe_Exception.thrown("Cannot access document attribute " + name);
		}
		let v = this1.get(name);
		if(v == null) {
			if(this1.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
			}
			throw haxe_Exception.thrown(this1.nodeName + " is missing attribute " + name);
		}
		return v;
	}
}
class haxe_xml__$Access_HasAttribAccess {
	static resolve(this1,name) {
		if(this1.nodeType == Xml.Document) {
			throw haxe_Exception.thrown("Cannot access document attribute " + name);
		}
		return this1.exists(name);
	}
}
class haxe_xml__$Access_HasNodeAccess {
	static resolve(this1,name) {
		return this1.elementsNamed(name).hasNext();
	}
}
class haxe_xml__$Access_NodeListAccess {
	static resolve(this1,name) {
		let l = [];
		let x = this1.elementsNamed(name);
		while(x.hasNext()) {
			let x1 = x.next();
			if(x1.nodeType != Xml.Document && x1.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Invalid nodeType " + (x1.nodeType == null ? "null" : XmlType.toString(x1.nodeType)));
			}
			l.push(x1);
		}
		return l;
	}
}
class haxe_xml_Access {
	static get_innerData(this1) {
		if(this1.nodeType != Xml.Document && this1.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
		}
		let it_current = 0;
		let it_array = this1.children;
		if(it_current >= it_array.length) {
			let tmp;
			if(this1.nodeType == Xml.Document) {
				tmp = "Document";
			} else {
				if(this1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
				}
				tmp = this1.nodeName;
			}
			throw haxe_Exception.thrown(tmp + " does not have data");
		}
		let v = it_array[it_current++];
		if(it_current < it_array.length) {
			let n = it_array[it_current++];
			let tmp;
			if(v.nodeType == Xml.PCData && n.nodeType == Xml.CData) {
				if(v.nodeType == Xml.Document || v.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (v.nodeType == null ? "null" : XmlType.toString(v.nodeType)));
				}
				tmp = StringTools.trim(v.nodeValue) == "";
			} else {
				tmp = false;
			}
			if(tmp) {
				if(it_current >= it_array.length) {
					if(n.nodeType == Xml.Document || n.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (n.nodeType == null ? "null" : XmlType.toString(n.nodeType)));
					}
					return n.nodeValue;
				}
				let n2 = it_array[it_current++];
				let tmp;
				if(n2.nodeType == Xml.PCData) {
					if(n2.nodeType == Xml.Document || n2.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (n2.nodeType == null ? "null" : XmlType.toString(n2.nodeType)));
					}
					tmp = StringTools.trim(n2.nodeValue) == "";
				} else {
					tmp = false;
				}
				if(tmp && it_current >= it_array.length) {
					if(n.nodeType == Xml.Document || n.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (n.nodeType == null ? "null" : XmlType.toString(n.nodeType)));
					}
					return n.nodeValue;
				}
			}
			let tmp1;
			if(this1.nodeType == Xml.Document) {
				tmp1 = "Document";
			} else {
				if(this1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
				}
				tmp1 = this1.nodeName;
			}
			throw haxe_Exception.thrown(tmp1 + " does not only have data");
		}
		if(v.nodeType != Xml.PCData && v.nodeType != Xml.CData) {
			let tmp;
			if(this1.nodeType == Xml.Document) {
				tmp = "Document";
			} else {
				if(this1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
				}
				tmp = this1.nodeName;
			}
			throw haxe_Exception.thrown(tmp + " does not have data");
		}
		if(v.nodeType == Xml.Document || v.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (v.nodeType == null ? "null" : XmlType.toString(v.nodeType)));
		}
		return v.nodeValue;
	}
	static get_innerHTML(this1) {
		let s_b = "";
		if(this1.nodeType != Xml.Document && this1.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
		}
		let _g_current = 0;
		let _g_array = this1.children;
		while(_g_current < _g_array.length) {
			let x = _g_array[_g_current++];
			s_b += Std.string(haxe_xml_Printer.print(x));
		}
		return s_b;
	}
}
haxe_xml_Access.__properties__ = {get_innerHTML: "get_innerHTML",get_innerData: "get_innerData"};
class haxe_xml_Printer {
	constructor(pretty) {
		this.output = new StringBuf();
		this.pretty = pretty;
	}
	writeNode(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			let attribute = value.attributes();
			while(attribute.hasNext()) {
				let attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				let input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				let _g_current = 0;
				let _g_array = value.children;
				while(_g_current < _g_array.length) {
					let child = _g_array[_g_current++];
					this.writeNode(child,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				let input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let commentContent = value.nodeValue;
			let _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			let input = StringTools.trim(commentContent);
			this.output.b += Std.string(input);
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let _g_current = 0;
			let _g_array = value.children;
			while(_g_current < _g_array.length) {
				let child = _g_array[_g_current++];
				this.writeNode(child,tabs);
			}
			break;
		}
	}
	hasChildren(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		let _g_current = 0;
		let _g_array = value.children;
		while(_g_current < _g_array.length) {
			let child = _g_array[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	static print(xml,pretty) {
		if(pretty == null) {
			pretty = false;
		}
		let printer = new haxe_xml_Printer(pretty);
		printer.writeNode(xml,"");
		return printer.output.b;
	}
}
$hxClasses["haxe.xml.Printer"] = haxe_xml_Printer;
haxe_xml_Printer.__name__ = "haxe.xml.Printer";
Object.assign(haxe_xml_Printer.prototype, {
	__class__: haxe_xml_Printer
});
var hscript_TType = $hxEnums["hscript.TType"] = { __ename__:"hscript.TType",__constructs__:null
	,TMono: ($_=function(r) { return {_hx_index:0,r:r,__enum__:"hscript.TType",toString:$estr}; },$_._hx_name="TMono",$_.__params__ = ["r"],$_)
	,TVoid: {_hx_name:"TVoid",_hx_index:1,__enum__:"hscript.TType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:2,__enum__:"hscript.TType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:3,__enum__:"hscript.TType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:4,__enum__:"hscript.TType",toString:$estr}
	,TDynamic: {_hx_name:"TDynamic",_hx_index:5,__enum__:"hscript.TType",toString:$estr}
	,TParam: ($_=function(name) { return {_hx_index:6,name:name,__enum__:"hscript.TType",toString:$estr}; },$_._hx_name="TParam",$_.__params__ = ["name"],$_)
	,TUnresolved: ($_=function(name) { return {_hx_index:7,name:name,__enum__:"hscript.TType",toString:$estr}; },$_._hx_name="TUnresolved",$_.__params__ = ["name"],$_)
	,TNull: ($_=function(t) { return {_hx_index:8,t:t,__enum__:"hscript.TType",toString:$estr}; },$_._hx_name="TNull",$_.__params__ = ["t"],$_)
	,TInst: ($_=function(c,args) { return {_hx_index:9,c:c,args:args,__enum__:"hscript.TType",toString:$estr}; },$_._hx_name="TInst",$_.__params__ = ["c","args"],$_)
	,TEnum: ($_=function(e,args) { return {_hx_index:10,e:e,args:args,__enum__:"hscript.TType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e","args"],$_)
	,TType: ($_=function(t,args) { return {_hx_index:11,t:t,args:args,__enum__:"hscript.TType",toString:$estr}; },$_._hx_name="TType",$_.__params__ = ["t","args"],$_)
	,TAbstract: ($_=function(a,args) { return {_hx_index:12,a:a,args:args,__enum__:"hscript.TType",toString:$estr}; },$_._hx_name="TAbstract",$_.__params__ = ["a","args"],$_)
	,TFun: ($_=function(args,ret) { return {_hx_index:13,args:args,ret:ret,__enum__:"hscript.TType",toString:$estr}; },$_._hx_name="TFun",$_.__params__ = ["args","ret"],$_)
	,TAnon: ($_=function(fields) { return {_hx_index:14,fields:fields,__enum__:"hscript.TType",toString:$estr}; },$_._hx_name="TAnon",$_.__params__ = ["fields"],$_)
	,TLazy: ($_=function(f) { return {_hx_index:15,f:f,__enum__:"hscript.TType",toString:$estr}; },$_._hx_name="TLazy",$_.__params__ = ["f"],$_)
};
hscript_TType.__constructs__ = [hscript_TType.TMono,hscript_TType.TVoid,hscript_TType.TInt,hscript_TType.TFloat,hscript_TType.TBool,hscript_TType.TDynamic,hscript_TType.TParam,hscript_TType.TUnresolved,hscript_TType.TNull,hscript_TType.TInst,hscript_TType.TEnum,hscript_TType.TType,hscript_TType.TAbstract,hscript_TType.TFun,hscript_TType.TAnon,hscript_TType.TLazy];
var hscript__$Checker_WithType = $hxEnums["hscript._Checker.WithType"] = { __ename__:"hscript._Checker.WithType",__constructs__:null
	,NoValue: {_hx_name:"NoValue",_hx_index:0,__enum__:"hscript._Checker.WithType",toString:$estr}
	,Value: {_hx_name:"Value",_hx_index:1,__enum__:"hscript._Checker.WithType",toString:$estr}
	,WithType: ($_=function(t) { return {_hx_index:2,t:t,__enum__:"hscript._Checker.WithType",toString:$estr}; },$_._hx_name="WithType",$_.__params__ = ["t"],$_)
};
hscript__$Checker_WithType.__constructs__ = [hscript__$Checker_WithType.NoValue,hscript__$Checker_WithType.Value,hscript__$Checker_WithType.WithType];
var hscript_CTypedecl = $hxEnums["hscript.CTypedecl"] = { __ename__:"hscript.CTypedecl",__constructs__:null
	,CTClass: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"hscript.CTypedecl",toString:$estr}; },$_._hx_name="CTClass",$_.__params__ = ["c"],$_)
	,CTEnum: ($_=function(e) { return {_hx_index:1,e:e,__enum__:"hscript.CTypedecl",toString:$estr}; },$_._hx_name="CTEnum",$_.__params__ = ["e"],$_)
	,CTTypedef: ($_=function(t) { return {_hx_index:2,t:t,__enum__:"hscript.CTypedecl",toString:$estr}; },$_._hx_name="CTTypedef",$_.__params__ = ["t"],$_)
	,CTAlias: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"hscript.CTypedecl",toString:$estr}; },$_._hx_name="CTAlias",$_.__params__ = ["t"],$_)
	,CTAbstract: ($_=function(a) { return {_hx_index:4,a:a,__enum__:"hscript.CTypedecl",toString:$estr}; },$_._hx_name="CTAbstract",$_.__params__ = ["a"],$_)
};
hscript_CTypedecl.__constructs__ = [hscript_CTypedecl.CTClass,hscript_CTypedecl.CTEnum,hscript_CTypedecl.CTTypedef,hscript_CTypedecl.CTAlias,hscript_CTypedecl.CTAbstract];
class hscript_Completion {
	constructor(expr,t) {
		this.expr = expr;
		this.t = t;
	}
}
$hxClasses["hscript.Completion"] = hscript_Completion;
hscript_Completion.__name__ = "hscript.Completion";
Object.assign(hscript_Completion.prototype, {
	__class__: hscript_Completion
});
class hscript_CheckerTypes {
	constructor() {
		this.types = new haxe_ds_StringMap();
		this.types = new haxe_ds_StringMap();
		this.types.h["Void"] = hscript_CTypedecl.CTAlias(hscript_TType.TVoid);
		this.types.h["Int"] = hscript_CTypedecl.CTAlias(hscript_TType.TInt);
		this.types.h["Float"] = hscript_CTypedecl.CTAlias(hscript_TType.TFloat);
		this.types.h["Bool"] = hscript_CTypedecl.CTAlias(hscript_TType.TBool);
		this.types.h["Dynamic"] = hscript_CTypedecl.CTAlias(hscript_TType.TDynamic);
		this.parser = new hscript_Parser();
	}
	addXmlApi(api) {
		let types = new haxe_rtti_XmlParser();
		types.process(api,"");
		let todo = [];
		let _g = 0;
		let _g1 = types.root;
		while(_g < _g1.length) {
			let v = _g1[_g];
			++_g;
			this.addXmlType(v,todo);
		}
		let _g2 = 0;
		while(_g2 < todo.length) {
			let f = todo[_g2];
			++_g2;
			f();
		}
		this.t_string = this.getType("String");
	}
	defineClass(name,ct) {
		if(ct == null) {
			ct = { name : name, fields : new haxe_ds_StringMap(), statics : new haxe_ds_StringMap(), params : []};
		}
		this.types.h[name] = hscript_CTypedecl.CTClass(ct);
		return ct;
	}
	addXmlType(x,todo) {
		let _gthis = this;
		switch(x._hx_index) {
		case 0:
			let name = x.name;
			let full = x.full;
			let subs = x.subs;
			let _g = 0;
			while(_g < subs.length) {
				let s = subs[_g];
				++_g;
				this.addXmlType(s,todo);
			}
			break;
		case 1:
			let c = x.c;
			if(Object.prototype.hasOwnProperty.call(this.types.h,c.path)) {
				return;
			}
			let cl = { name : c.path, params : [], fields : new haxe_ds_StringMap(), statics : new haxe_ds_StringMap()};
			this.addMeta(c,cl);
			if(c.isInterface) {
				cl.isInterface = true;
			}
			let _g1 = 0;
			let _g2 = c.params;
			while(_g1 < _g2.length) {
				let p = _g2[_g1];
				++_g1;
				cl.params.push(hscript_TType.TParam(p));
			}
			todo.push(function() {
				let _g = new haxe_ds_StringMap();
				let _g1 = 0;
				let _g2 = cl.params;
				while(_g1 < _g2.length) {
					let t = _g2[_g1];
					++_g1;
					let key = c.path + "." + hscript_Checker.typeStr(t);
					_g.h[key] = t;
				}
				_gthis.localParams = _g;
				if(c.superClass != null) {
					let _gthis1 = _gthis;
					let c1 = c.superClass.path;
					let _g = [];
					let _g1 = 0;
					let _g2 = c.superClass.params;
					while(_g1 < _g2.length) {
						let t = _g2[_g1];
						++_g1;
						_g.push(_gthis.makeXmlType(t));
					}
					cl.superClass = _gthis1.getType(c1,_g);
				}
				if(c.interfaces != null) {
					cl.interfaces = [];
					let _g = 0;
					let _g1 = c.interfaces;
					while(_g < _g1.length) {
						let i = _g1[_g];
						++_g;
						let cl1 = cl.interfaces;
						let _gthis1 = _gthis;
						let i1 = i.path;
						let _g2 = [];
						let _g3 = 0;
						let _g4 = i.params;
						while(_g3 < _g4.length) {
							let t = _g4[_g3];
							++_g3;
							_g2.push(_gthis.makeXmlType(t));
						}
						cl1.push(_gthis1.getType(i1,_g2));
					}
				}
				let pkeys = [];
				let initField = function(f,fields) {
					if(f.isOverride || HxOverrides.substr(f.name,0,4) == "get_" || HxOverrides.substr(f.name,0,4) == "set_") {
						return;
					}
					let complete = !f.name.startsWith("__");
					let _g = 0;
					let _g1 = f.meta;
					while(_g < _g1.length) {
						let m = _g1[_g];
						++_g;
						if(m.name == ":noScript") {
							return;
						}
						if(m.name == ":noCompletion") {
							complete = false;
						}
					}
					let _g2 = f.set;
					let fl;
					switch(_g2._hx_index) {
					case 2:
						let _g3 = _g2.m;
						fl = true;
						break;
					case 0:case 4:
						fl = true;
						break;
					default:
						fl = false;
					}
					let fl1 = { isPublic : f.isPublic, canWrite : fl, complete : complete, params : [], name : f.name, t : null};
					let _g4 = 0;
					let _g5 = f.params;
					while(_g4 < _g5.length) {
						let p = _g5[_g4];
						++_g4;
						let pt = hscript_TType.TParam(p);
						let key = f.name + "." + p;
						pkeys.push(key);
						fl1.params.push(pt);
						_gthis.localParams.h[key] = pt;
					}
					fl1.t = _gthis.makeXmlType(f.type);
					if(f.meta != null && f.meta.length > 0) {
						fl1.meta = [];
						let _g = 0;
						let _g1 = f.meta;
						while(_g < _g1.length) {
							let m = _g1[_g];
							++_g;
							let fl = fl1.meta;
							let m1 = m.name;
							let _g2 = [];
							let _g3 = 0;
							let _g4 = m.params;
							while(_g3 < _g4.length) {
								let p = _g4[_g3];
								++_g3;
								let initField;
								try {
									initField = _gthis.parser.parseString(p);
								} catch( _g ) {
									if(((haxe_Exception.caught(_g).unwrap()) instanceof hscript_Error)) {
										initField = null;
									} else {
										throw _g;
									}
								}
								_g2.push(initField);
							}
							fl.push({ name : m1, params : _g2});
						}
					}
					while(pkeys.length > 0) {
						let this1 = _gthis.localParams;
						let key = pkeys.pop();
						let _this = this1;
						if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
							delete(_this.h[key]);
						}
					}
					if(fl1.name == "new") {
						cl.constructor = fl1;
					} else {
						fields.set(f.name,fl1);
					}
				};
				let _g3 = 0;
				let _g4 = c.fields;
				while(_g3 < _g4.length) {
					let f = _g4[_g3];
					++_g3;
					initField(f,cl.fields);
				}
				let _g5 = 0;
				let _g6 = c.statics;
				while(_g5 < _g6.length) {
					let f = _g6[_g5];
					++_g5;
					initField(f,cl.statics);
				}
				_gthis.localParams = null;
			});
			this.types.h[cl.name] = hscript_CTypedecl.CTClass(cl);
			break;
		case 2:
			let e = x.e;
			if(Object.prototype.hasOwnProperty.call(this.types.h,e.path)) {
				return;
			}
			let en = { name : e.path, params : [], constructors : []};
			this.addMeta(e,en);
			let _g3 = 0;
			let _g4 = e.params;
			while(_g3 < _g4.length) {
				let p = _g4[_g3];
				++_g3;
				en.params.push(hscript_TType.TParam(p));
			}
			todo.push(function() {
				let _g = new haxe_ds_StringMap();
				let _g1 = 0;
				let _g2 = en.params;
				while(_g1 < _g2.length) {
					let t = _g2[_g1];
					++_g1;
					let key = e.path + "." + hscript_Checker.typeStr(t);
					_g.h[key] = t;
				}
				_gthis.localParams = _g;
				let _g3 = 0;
				let _g4 = e.constructors;
				while(_g3 < _g4.length) {
					let c = _g4[_g3];
					++_g3;
					let en1 = en.constructors;
					let c1 = c.name;
					let tmp;
					if(c.args == null) {
						tmp = null;
					} else {
						let _g = [];
						let _g1 = 0;
						let _g2 = c.args;
						while(_g1 < _g2.length) {
							let a = _g2[_g1];
							++_g1;
							_g.push({ name : a.name, opt : a.opt, t : _gthis.makeXmlType(a.t)});
						}
						tmp = _g;
					}
					en1.push({ name : c1, args : tmp});
				}
				_gthis.localParams = null;
			});
			this.types.h[en.name] = hscript_CTypedecl.CTEnum(en);
			break;
		case 3:
			let t = x.t;
			if(Object.prototype.hasOwnProperty.call(this.types.h,t.path)) {
				return;
			}
			let td = { name : t.path, params : [], t : null};
			let _g5 = 0;
			let _g6 = t.params;
			while(_g5 < _g6.length) {
				let p = _g6[_g5];
				++_g5;
				td.params.push(hscript_TType.TParam(p));
			}
			if(t.path == "hscript.TypeCheck") {
				td.params.reverse();
			}
			todo.push(function() {
				let _g = new haxe_ds_StringMap();
				let _g1 = 0;
				let _g2 = td.params;
				while(_g1 < _g2.length) {
					let pt = _g2[_g1];
					++_g1;
					let key = t.path + "." + hscript_Checker.typeStr(pt);
					_g.h[key] = pt;
				}
				_gthis.localParams = _g;
				td.t = _gthis.makeXmlType(t.type);
				_gthis.localParams = null;
			});
			this.types.h[t.path] = hscript_CTypedecl.CTTypedef(td);
			break;
		case 4:
			let a = x.a;
			if(Object.prototype.hasOwnProperty.call(this.types.h,a.path)) {
				return;
			}
			let ta = { name : a.path, params : [], t : null};
			this.addMeta(a,ta);
			let _g7 = 0;
			let _g8 = a.params;
			while(_g7 < _g8.length) {
				let p = _g8[_g7];
				++_g7;
				ta.params.push(hscript_TType.TParam(p));
			}
			todo.push(function() {
				let _g = new haxe_ds_StringMap();
				let _g1 = 0;
				let _g2 = ta.params;
				while(_g1 < _g2.length) {
					let t = _g2[_g1];
					++_g1;
					let key = a.path + "." + hscript_Checker.typeStr(t);
					_g.h[key] = t;
				}
				_gthis.localParams = _g;
				ta.t = _gthis.makeXmlType(a.athis);
				_gthis.localParams = null;
			});
			this.types.h[a.path] = hscript_CTypedecl.CTAbstract(ta);
			break;
		}
	}
	addMeta(src,to) {
		if(src.meta == null || src.meta.length == 0) {
			return;
		}
		to.meta = [];
		let _g = 0;
		let _g1 = src.meta;
		while(_g < _g1.length) {
			let m = _g1[_g];
			++_g;
			let to1 = to.meta;
			let m1 = m.name;
			let _g2 = [];
			let _g3 = 0;
			let _g4 = m.params;
			while(_g3 < _g4.length) {
				let p = _g4[_g3];
				++_g3;
				let tmp;
				try {
					tmp = this.parser.parseString(p);
				} catch( _g ) {
					if(((haxe_Exception.caught(_g).unwrap()) instanceof hscript_Error)) {
						tmp = null;
					} else {
						throw _g;
					}
				}
				_g2.push(tmp);
			}
			to1.push({ name : m1, params : _g2});
		}
	}
	makeXmlType(t) {
		switch(t._hx_index) {
		case 0:
			return hscript_TType.TUnresolved("Unknown");
		case 1:
			let name = t.name;
			let params = t.params;
			let _g = [];
			let _g1 = 0;
			while(_g1 < params.length) {
				let t = params[_g1];
				++_g1;
				_g.push(this.makeXmlType(t));
			}
			return this.getType(name,_g);
		case 2:
			let name1 = t.name;
			let params1 = t.params;
			let _g2 = [];
			let _g3 = 0;
			while(_g3 < params1.length) {
				let t = params1[_g3];
				++_g3;
				_g2.push(this.makeXmlType(t));
			}
			return this.getType(name1,_g2);
		case 3:
			let name2 = t.name;
			let params2 = t.params;
			let _g4 = [];
			let _g5 = 0;
			while(_g5 < params2.length) {
				let t = params2[_g5];
				++_g5;
				_g4.push(this.makeXmlType(t));
			}
			return this.getType(name2,_g4);
		case 4:
			let args = t.args;
			let ret = t.ret;
			let _g6 = [];
			let _g7 = 0;
			while(_g7 < args.length) {
				let a = args[_g7];
				++_g7;
				_g6.push({ name : a.name, opt : a.opt, t : this.makeXmlType(a.t)});
			}
			return hscript_TType.TFun(_g6,this.makeXmlType(ret));
		case 5:
			let fields = t.fields;
			let _g8 = [];
			let _g9 = 0;
			while(_g9 < fields.length) {
				let f = fields[_g9];
				++_g9;
				let f1 = f.name;
				let tmp = this.makeXmlType(f.type);
				let m = f.meta;
				let tmp1;
				if(m == null) {
					tmp1 = false;
				} else {
					let b = false;
					let _g = 0;
					while(_g < m.length) {
						let m1 = m[_g];
						++_g;
						if(m1.name == ":optional") {
							b = true;
							break;
						}
					}
					tmp1 = b;
				}
				_g8.push({ name : f1, t : tmp, opt : tmp1});
			}
			return hscript_TType.TAnon(_g8);
		case 6:
			let t1 = t.t;
			return hscript_TType.TDynamic;
		case 7:
			let name3 = t.name;
			let params3 = t.params;
			let _g10 = [];
			let _g11 = 0;
			while(_g11 < params3.length) {
				let t = params3[_g11];
				++_g11;
				_g10.push(this.makeXmlType(t));
			}
			return this.getType(name3,_g10);
		}
	}
	getType(name,args) {
		if(this.localParams != null) {
			let t = this.localParams.h[name];
			if(t != null) {
				return t;
			}
		}
		let t = this.resolve(name,args);
		if(t == null) {
			let pack = name.split(".");
			if(pack.length > 1) {
				let priv = pack[pack.length - 2];
				if(HxOverrides.cca(priv,0) == 95) {
					HxOverrides.remove(pack,priv);
					return this.getType(pack.join("."),args);
				}
			}
			return hscript_TType.TUnresolved(name);
		}
		return t;
	}
	resolve(name,args) {
		if(name == "Null") {
			if(args == null || args.length != 1) {
				throw haxe_Exception.thrown("Missing Null<T> parameter");
			}
			return hscript_TType.TNull(args[0]);
		}
		let t = this.types.h[name];
		if(t == null) {
			return null;
		}
		if(args == null) {
			args = [];
		}
		switch(t._hx_index) {
		case 0:
			let c = t.c;
			return hscript_TType.TInst(c,args);
		case 1:
			let e = t.e;
			return hscript_TType.TEnum(e,args);
		case 2:
			let t1 = t.t;
			return hscript_TType.TType(t1,args);
		case 3:
			let t2 = t.t;
			return t2;
		case 4:
			let a = t.a;
			return hscript_TType.TAbstract(a,args);
		}
	}
}
$hxClasses["hscript.CheckerTypes"] = hscript_CheckerTypes;
hscript_CheckerTypes.__name__ = "hscript.CheckerTypes";
Object.assign(hscript_CheckerTypes.prototype, {
	__class__: hscript_CheckerTypes
});
class hscript_Checker {
	constructor(types) {
		this.events = new haxe_ds_StringMap();
		this.globals = new haxe_ds_StringMap();
		if(types == null) {
			types = new hscript_CheckerTypes();
		}
		this.types = types;
	}
	setGlobals(cl,allowPrivate) {
		if(allowPrivate == null) {
			allowPrivate = false;
		}
		let _gthis = this;
		while(true) {
			let h = cl.fields.h;
			let f_h = h;
			let f_keys = Object.keys(h);
			let f_length = f_keys.length;
			let f_current = 0;
			while(f_current < f_length) {
				let f = f_h[f_keys[f_current++]];
				if(f.isPublic || allowPrivate) {
					let tmp = f.params.length == 0 ? f.t : hscript_TType.TLazy(function() {
						let _gthis1 = _gthis;
						let f1 = f.t;
						let f2 = f.params;
						let _g = [];
						let _g1 = 0;
						let _g2 = f.params.length;
						while(_g1 < _g2) {
							let i = _g1++;
							_g.push(_gthis.makeMono());
						}
						return _gthis1.apply(f1,f2,_g);
					});
					this.setGlobal(f.name,tmp);
				}
			}
			if(cl.superClass == null) {
				break;
			}
			let _g = cl.superClass;
			if(_g == null) {
				throw haxe_Exception.thrown("assert");
			} else if(_g._hx_index == 9) {
				let _g1 = _g.args;
				let c = _g.c;
				cl = c;
			} else {
				throw haxe_Exception.thrown("assert");
			}
		}
	}
	removeGlobal(name) {
		let _this = this.globals;
		if(Object.prototype.hasOwnProperty.call(_this.h,name)) {
			delete(_this.h[name]);
		}
	}
	setGlobal(name,type) {
		this.globals.h[name] = type;
	}
	setEvent(name,type) {
		this.events.h[name] = type;
	}
	getGlobals() {
		return this.globals;
	}
	onTopDownEnum(en,field) {
		return false;
	}
	typeArgs(args,pos) {
		let _g = [];
		let _g1 = 0;
		let _g2 = args.length;
		while(_g1 < _g2) {
			let i = _g1++;
			let a = args[i];
			let at = a.t == null ? this.makeMono() : this.makeType(a.t,pos);
			_g.push({ name : a.name, opt : a.opt, t : at});
		}
		return _g;
	}
	check(expr,withType,isCompletion) {
		if(isCompletion == null) {
			isCompletion = false;
		}
		if(withType == null) {
			withType = hscript__$Checker_WithType.NoValue;
		}
		this.locals = new haxe_ds_StringMap();
		if(this.types.t_string == null) {
			this.types.t_string = this.types.getType("String");
		}
		this.allowDefine = this.allowGlobalsDefine;
		this.isCompletion = isCompletion;
		let _g = expr.e;
		let tmp;
		if(_g._hx_index == 14) {
			let _g1 = _g.args;
			let _g2 = _g.e;
			let _g3 = _g.name;
			let _g4 = _g.ret;
			tmp = true;
		} else {
			tmp = false;
		}
		if(tmp) {
			expr = this.mk(hscript_ExprDef.EBlock([expr]),expr);
		}
		let _gthis = this;
		let _g1 = expr.e;
		if(_g1._hx_index == 4) {
			let el = _g1.e;
			let delayed = [];
			let last = hscript_TType.TVoid;
			let _g = 0;
			while(_g < el.length) {
				let e = el[_g];
				++_g;
				while(true) {
					let _g = e.e;
					if(_g._hx_index == 25) {
						let _g1 = _g.name;
						let _g2 = _g.args;
						let e2 = _g.e;
						e = e2;
					} else {
						break;
					}
				}
				let _g1 = e.e;
				if(_g1._hx_index == 14) {
					let _g = _g1.e;
					let args = _g1.args;
					let name = _g1.name;
					let ret = _g1.ret;
					if(name != null) {
						let tret = ret == null ? this.makeMono() : this.makeType(ret,e);
						let ft = hscript_TType.TFun(this.typeArgs(args,e),tret);
						this.locals.h[name] = ft;
						delayed.push(function() {
							_gthis.currentFunType = ft;
							_gthis.typeExpr(e,hscript__$Checker_WithType.NoValue);
							return ft;
						});
					} else {
						let _g = 0;
						while(_g < delayed.length) {
							let f = delayed[_g];
							++_g;
							f();
						}
						delayed = [];
						if(el[el.length - 1] == e) {
							last = this.typeExpr(e,withType);
						} else {
							this.typeExpr(e,hscript__$Checker_WithType.NoValue);
						}
					}
				} else {
					let _g = 0;
					while(_g < delayed.length) {
						let f = delayed[_g];
						++_g;
						f();
					}
					delayed = [];
					if(el[el.length - 1] == e) {
						last = this.typeExpr(e,withType);
					} else {
						this.typeExpr(e,hscript__$Checker_WithType.NoValue);
					}
				}
			}
			let _g2 = 0;
			while(_g2 < delayed.length) {
				let f = delayed[_g2];
				++_g2;
				last = f();
			}
			return last;
		}
		return this.typeExpr(expr,withType);
	}
	edef(e) {
		return e.e;
	}
	error(msg,curExpr) {
		let e = hscript_ErrorDef.ECustom(msg);
		let e1 = new hscript_Error(e,curExpr.pmin,curExpr.pmax,curExpr.origin,curExpr.line);
		if(!this.isCompletion) {
			throw haxe_Exception.thrown(e1);
		}
	}
	saveLocals() {
		let _g = new haxe_ds_StringMap();
		let h = this.locals.h;
		let k_h = h;
		let k_keys = Object.keys(h);
		let k_length = k_keys.length;
		let k_current = 0;
		while(k_current < k_length) {
			let k = k_keys[k_current++];
			_g.h[k] = this.locals.h[k];
		}
		return _g;
	}
	makeType(t,e) {
		switch(t._hx_index) {
		case 0:
			let path = t.path;
			let params = t.params;
			let ct = this.types;
			let ct1 = path.join(".");
			let ct2;
			if(params == null) {
				ct2 = [];
			} else {
				let _g = [];
				let _g1 = 0;
				while(_g1 < params.length) {
					let p = params[_g1];
					++_g1;
					_g.push(this.makeType(p,e));
				}
				ct2 = _g;
			}
			let ct3 = ct.resolve(ct1,ct2);
			if(ct3 == null) {
				let e1 = hscript_ErrorDef.ECustom("Unknown type " + Std.string(path));
				let e2 = new hscript_Error(e1,e.pmin,e.pmax,e.origin,e.line);
				if(!this.isCompletion) {
					throw haxe_Exception.thrown(e2);
				}
				ct3 = hscript_TType.TDynamic;
			}
			return ct3;
		case 1:
			let args = t.args;
			let ret = t.ret;
			let i = 0;
			let _g = [];
			let _g1 = 0;
			while(_g1 < args.length) {
				let a = args[_g1];
				++_g1;
				_g.push({ name : "p" + i++, opt : false, t : this.makeType(a,e)});
			}
			return hscript_TType.TFun(_g,this.makeType(ret,e));
		case 2:
			let fields = t.fields;
			let _g2 = [];
			let _g3 = 0;
			while(_g3 < fields.length) {
				let f = fields[_g3];
				++_g3;
				_g2.push({ name : f.name, opt : false, t : this.makeType(f.t,e)});
			}
			return hscript_TType.TAnon(_g2);
		case 3:
			let t1 = t.t;
			return this.makeType(t1,e);
		case 4:
			let t2 = t.t;
			return this.makeType(t2,e);
		case 5:
			let n = t.n;
			let t3 = t.t;
			return this.makeType(t3,e);
		}
	}
	linkLoop(a,t) {
		if(t == a) {
			return true;
		}
		switch(t._hx_index) {
		case 0:
			let r = t.r;
			if(r.r == null) {
				return false;
			}
			return this.linkLoop(a,r.r);
		case 5:
			if(t == hscript_TType.TDynamic) {
				return false;
			}
			return this.linkLoop(a,hscript_TType.TDynamic);
		case 9:
			let _g = t.c;
			let tl = t.args;
			let _g1 = 0;
			while(_g1 < tl.length) {
				let t = tl[_g1];
				++_g1;
				if(this.linkLoop(a,t)) {
					return true;
				}
			}
			return false;
		case 10:
			let _g2 = t.e;
			let tl1 = t.args;
			let _g3 = 0;
			while(_g3 < tl1.length) {
				let t = tl1[_g3];
				++_g3;
				if(this.linkLoop(a,t)) {
					return true;
				}
			}
			return false;
		case 11:
			let _g4 = t.t;
			let tl2 = t.args;
			let _g5 = 0;
			while(_g5 < tl2.length) {
				let t = tl2[_g5];
				++_g5;
				if(this.linkLoop(a,t)) {
					return true;
				}
			}
			return false;
		case 12:
			let _g6 = t.a;
			let tl3 = t.args;
			let _g7 = 0;
			while(_g7 < tl3.length) {
				let t = tl3[_g7];
				++_g7;
				if(this.linkLoop(a,t)) {
					return true;
				}
			}
			return false;
		case 13:
			let args = t.args;
			let ret = t.ret;
			let _g8 = 0;
			while(_g8 < args.length) {
				let arg = args[_g8];
				++_g8;
				if(this.linkLoop(a,arg.t)) {
					return true;
				}
			}
			return this.linkLoop(a,ret);
		case 14:
			let fl = t.fields;
			let _g9 = 0;
			while(_g9 < fl.length) {
				let f = fl[_g9];
				++_g9;
				if(this.linkLoop(a,f.t)) {
					return true;
				}
			}
			return false;
		default:
			return false;
		}
	}
	link(a,b,r) {
		if(this.linkLoop(a,b)) {
			return this.follow(b) == a;
		}
		if(b == hscript_TType.TDynamic) {
			return true;
		}
		r.r = b;
		return true;
	}
	typeEq(t1,t2) {
		if(t1 == t2) {
			return true;
		}
		switch(t1._hx_index) {
		case 0:
			let r = t1.r;
			if(r.r == null) {
				if(!this.link(t1,t2,r)) {
					return false;
				}
				r.r = t2;
				return true;
			}
			return this.typeEq(r.r,t2);
		case 8:
			let _g = t1.t;
			switch(t2._hx_index) {
			case 0:
				let r1 = t2.r;
				if(r1.r == null) {
					if(!this.link(t2,t1,r1)) {
						return false;
					}
					r1.r = t1;
					return true;
				}
				return this.typeEq(t1,r1.r);
			case 8:
				let t21 = t2.t;
				let t11 = _g;
				return this.typeEq(t11,t21);
			case 11:
				let t22 = t2.t;
				let pl2 = t2.args;
				return this.typeEq(t1,this.apply(t22.t,t22.params,pl2));
			default:
				let t12 = _g;
				return this.typeEq(t12,t2);
			}
			break;
		case 9:
			let _g1 = t1.c;
			let _g2 = t1.args;
			switch(t2._hx_index) {
			case 0:
				let r2 = t2.r;
				if(r2.r == null) {
					if(!this.link(t2,t1,r2)) {
						return false;
					}
					r2.r = t1;
					return true;
				}
				return this.typeEq(t1,r2.r);
			case 8:
				let t23 = t2.t;
				return this.typeEq(t1,t23);
			case 9:
				let cl2 = t2.c;
				let pl21 = t2.args;
				let pl1 = _g2;
				let cl1 = _g1;
				if(cl1 == cl2) {
					let _g = 0;
					let _g1 = pl1.length;
					while(_g < _g1) {
						let i = _g++;
						if(!this.typeEq(pl1[i],pl21[i])) {
							return false;
						}
					}
					return true;
				}
				break;
			case 11:
				let t24 = t2.t;
				let pl22 = t2.args;
				return this.typeEq(t1,this.apply(t24.t,t24.params,pl22));
			default:
			}
			break;
		case 10:
			let _g3 = t1.e;
			let _g4 = t1.args;
			switch(t2._hx_index) {
			case 0:
				let r3 = t2.r;
				if(r3.r == null) {
					if(!this.link(t2,t1,r3)) {
						return false;
					}
					r3.r = t1;
					return true;
				}
				return this.typeEq(t1,r3.r);
			case 8:
				let t25 = t2.t;
				return this.typeEq(t1,t25);
			case 10:
				let e2 = t2.e;
				let pl23 = t2.args;
				let pl11 = _g4;
				let e1 = _g3;
				if(e1 == e2) {
					let _g = 0;
					let _g1 = pl11.length;
					while(_g < _g1) {
						let i = _g++;
						if(!this.typeEq(pl11[i],pl23[i])) {
							return false;
						}
					}
					return true;
				}
				break;
			case 11:
				let t26 = t2.t;
				let pl24 = t2.args;
				return this.typeEq(t1,this.apply(t26.t,t26.params,pl24));
			default:
			}
			break;
		case 11:
			let _g5 = t1.t;
			let _g6 = t1.args;
			switch(t2._hx_index) {
			case 0:
				let r4 = t2.r;
				if(r4.r == null) {
					if(!this.link(t2,t1,r4)) {
						return false;
					}
					r4.r = t1;
					return true;
				}
				return this.typeEq(t1,r4.r);
			case 8:
				let _g7 = t2.t;
				let pl12 = _g6;
				let t13 = _g5;
				return this.typeEq(this.apply(t13.t,t13.params,pl12),t2);
			case 11:
				let t27 = t2.t;
				let pl25 = t2.args;
				let pl13 = _g6;
				let t14 = _g5;
				if(t14 == t27) {
					let _g = 0;
					let _g1 = pl13.length;
					while(_g < _g1) {
						let i = _g++;
						if(!this.typeEq(pl13[i],pl25[i])) {
							return false;
						}
					}
					return true;
				} else {
					let pl1 = _g6;
					let t1 = _g5;
					return this.typeEq(this.apply(t1.t,t1.params,pl1),t2);
				}
				break;
			default:
				let pl14 = _g6;
				let t15 = _g5;
				return this.typeEq(this.apply(t15.t,t15.params,pl14),t2);
			}
			break;
		case 12:
			let _g8 = t1.a;
			let _g9 = t1.args;
			switch(t2._hx_index) {
			case 0:
				let r5 = t2.r;
				if(r5.r == null) {
					if(!this.link(t2,t1,r5)) {
						return false;
					}
					r5.r = t1;
					return true;
				}
				return this.typeEq(t1,r5.r);
			case 8:
				let t28 = t2.t;
				return this.typeEq(t1,t28);
			case 11:
				let t29 = t2.t;
				let pl26 = t2.args;
				return this.typeEq(t1,this.apply(t29.t,t29.params,pl26));
			case 12:
				let a2 = t2.a;
				let pl27 = t2.args;
				let pl15 = _g9;
				let a1 = _g8;
				if(a1 == a2) {
					let _g = 0;
					let _g1 = pl15.length;
					while(_g < _g1) {
						let i = _g++;
						if(!this.typeEq(pl15[i],pl27[i])) {
							return false;
						}
					}
					return true;
				}
				break;
			default:
			}
			break;
		case 13:
			let _g10 = t1.args;
			let _g11 = t1.ret;
			switch(t2._hx_index) {
			case 0:
				let r6 = t2.r;
				if(r6.r == null) {
					if(!this.link(t2,t1,r6)) {
						return false;
					}
					r6.r = t1;
					return true;
				}
				return this.typeEq(t1,r6.r);
			case 8:
				let t210 = t2.t;
				return this.typeEq(t1,t210);
			case 11:
				let t211 = t2.t;
				let pl28 = t2.args;
				return this.typeEq(t1,this.apply(t211.t,t211.params,pl28));
			case 13:
				let args2 = t2.args;
				let r21 = t2.ret;
				let r11 = _g11;
				let args1 = _g10;
				if(args1.length == args2.length) {
					let _g = 0;
					let _g1 = args1.length;
					while(_g < _g1) {
						let i = _g++;
						if(!this.typeEq(args1[i].t,args2[i].t)) {
							return false;
						}
					}
					return this.typeEq(r11,r21);
				}
				break;
			default:
			}
			break;
		case 14:
			let _g12 = t1.fields;
			switch(t2._hx_index) {
			case 0:
				let r7 = t2.r;
				if(r7.r == null) {
					if(!this.link(t2,t1,r7)) {
						return false;
					}
					r7.r = t1;
					return true;
				}
				return this.typeEq(t1,r7.r);
			case 8:
				let t212 = t2.t;
				return this.typeEq(t1,t212);
			case 11:
				let t213 = t2.t;
				let pl29 = t2.args;
				return this.typeEq(t1,this.apply(t213.t,t213.params,pl29));
			case 14:
				let a21 = t2.fields;
				let a11 = _g12;
				if(a11.length == a21.length) {
					let m_h = Object.create(null);
					let _g = 0;
					while(_g < a21.length) {
						let f = a21[_g];
						++_g;
						m_h[f.name] = f;
					}
					let _g1 = 0;
					while(_g1 < a11.length) {
						let f1 = a11[_g1];
						++_g1;
						let f2 = m_h[f1.name];
						if(f2 == null) {
							return false;
						}
						if(!this.typeEq(f1.t,f2.t)) {
							return false;
						}
					}
					return true;
				}
				break;
			default:
			}
			break;
		default:
			switch(t2._hx_index) {
			case 0:
				let r8 = t2.r;
				if(r8.r == null) {
					if(!this.link(t2,t1,r8)) {
						return false;
					}
					r8.r = t1;
					return true;
				}
				return this.typeEq(t1,r8.r);
			case 8:
				let t214 = t2.t;
				return this.typeEq(t1,t214);
			case 11:
				let t215 = t2.t;
				let pl210 = t2.args;
				return this.typeEq(t1,this.apply(t215.t,t215.params,pl210));
			default:
			}
		}
		return false;
	}
	tryUnify(t1,t2) {
		if(t1 == t2) {
			return true;
		}
		switch(t1._hx_index) {
		case 0:
			let r = t1.r;
			if(r.r == null) {
				if(!this.link(t1,t2,r)) {
					return false;
				}
				r.r = t2;
				return true;
			}
			return this.tryUnify(r.r,t2);
		case 2:
			switch(t2._hx_index) {
			case 0:
				let r1 = t2.r;
				if(r1.r == null) {
					if(!this.link(t2,t1,r1)) {
						return false;
					}
					r1.r = t1;
					return true;
				}
				return this.tryUnify(t1,r1.r);
			case 3:
				return true;
			case 5:
				return true;
			case 8:
				let t21 = t2.t;
				return this.tryUnify(t1,t21);
			case 11:
				let t22 = t2.t;
				let pl2 = t2.args;
				return this.tryUnify(t1,this.apply(t22.t,t22.params,pl2));
			default:
			}
			break;
		case 5:
			switch(t2._hx_index) {
			case 0:
				let r2 = t2.r;
				if(r2.r == null) {
					if(!this.link(t2,t1,r2)) {
						return false;
					}
					r2.r = t1;
					return true;
				}
				return this.tryUnify(t1,r2.r);
			case 5:
				return true;
			case 8:
				let t23 = t2.t;
				return this.tryUnify(t1,t23);
			case 11:
				let t24 = t2.t;
				let pl21 = t2.args;
				return this.tryUnify(t1,this.apply(t24.t,t24.params,pl21));
			default:
				return true;
			}
			break;
		case 8:
			let _g = t1.t;
			switch(t2._hx_index) {
			case 0:
				let r3 = t2.r;
				if(r3.r == null) {
					if(!this.link(t2,t1,r3)) {
						return false;
					}
					r3.r = t1;
					return true;
				}
				return this.tryUnify(t1,r3.r);
			case 5:
				let t11 = _g;
				return this.tryUnify(t11,t2);
			case 8:
				let _g1 = t2.t;
				let t12 = _g;
				return this.tryUnify(t12,t2);
			case 11:
				let t25 = t2.t;
				let pl22 = t2.args;
				return this.tryUnify(t1,this.apply(t25.t,t25.params,pl22));
			default:
				let t13 = _g;
				return this.tryUnify(t13,t2);
			}
			break;
		case 9:
			let _g2 = t1.c;
			let _g3 = t1.args;
			switch(t2._hx_index) {
			case 0:
				let r4 = t2.r;
				if(r4.r == null) {
					if(!this.link(t2,t1,r4)) {
						return false;
					}
					r4.r = t1;
					return true;
				}
				return this.tryUnify(t1,r4.r);
			case 5:
				return true;
			case 8:
				let t26 = t2.t;
				return this.tryUnify(t1,t26);
			case 9:
				let cl2 = t2.c;
				let pl23 = t2.args;
				let pl1 = _g3;
				let cl1 = _g2;
				while(cl1 != cl2) {
					if(cl1.interfaces != null) {
						let _g = 0;
						let _g1 = cl1.interfaces;
						while(_g < _g1.length) {
							let i = _g1[_g];
							++_g;
							if(i._hx_index == 9) {
								let cli = i.c;
								let args = i.args;
								let _g = [];
								let _g1 = 0;
								while(_g1 < args.length) {
									let a = args[_g1];
									++_g1;
									_g.push(this.apply(a,cl1.params,pl1));
								}
								let i1 = hscript_TType.TInst(cli,_g);
								if(this.tryUnify(i1,t2)) {
									return true;
								}
							} else {
								throw haxe_Exception.thrown("assert");
							}
						}
					}
					let _g = cl1.superClass;
					if(_g == null) {
						return false;
					} else if(_g._hx_index == 9) {
						let c = _g.c;
						let args = _g.args;
						let _g1 = [];
						let _g2 = 0;
						while(_g2 < args.length) {
							let a = args[_g2];
							++_g2;
							_g1.push(this.apply(a,cl1.params,pl1));
						}
						pl1 = _g1;
						cl1 = c;
					} else {
						throw haxe_Exception.thrown("assert");
					}
				}
				let _g4 = 0;
				let _g5 = pl1.length;
				while(_g4 < _g5) {
					let i = _g4++;
					if(!this.typeEq(pl1[i],pl23[i])) {
						return false;
					}
				}
				return true;
			case 11:
				let t27 = t2.t;
				let pl24 = t2.args;
				return this.tryUnify(t1,this.apply(t27.t,t27.params,pl24));
			case 14:
				let fl = t2.fields;
				let pl11 = _g3;
				let cl11 = _g2;
				let _g6 = 0;
				let _g7 = fl.length;
				while(_g6 < _g7) {
					let i = _g6++;
					let f2 = fl[i];
					let f1 = null;
					let cl = cl11;
					while(true) {
						f1 = cl.fields.h[f2.name];
						if(f1 != null) {
							break;
						}
						if(cl.superClass == null) {
							return false;
						}
						let _g = cl.superClass;
						if(_g == null) {
							throw haxe_Exception.thrown("assert");
						} else if(_g._hx_index == 9) {
							let _g1 = _g.args;
							let c = _g.c;
							cl = c;
						} else {
							throw haxe_Exception.thrown("assert");
						}
					}
					if(!this.typeEq(this.apply(f1.t,cl11.params,pl11),f2.t)) {
						return false;
					}
				}
				return true;
			default:
			}
			break;
		case 11:
			let _g8 = t1.t;
			let _g9 = t1.args;
			switch(t2._hx_index) {
			case 0:
				let r5 = t2.r;
				if(r5.r == null) {
					if(!this.link(t2,t1,r5)) {
						return false;
					}
					r5.r = t1;
					return true;
				}
				return this.tryUnify(t1,r5.r);
			case 5:
				let pl12 = _g9;
				let t14 = _g8;
				return this.tryUnify(this.apply(t14.t,t14.params,pl12),t2);
			case 8:
				let _g10 = t2.t;
				let pl13 = _g9;
				let t15 = _g8;
				return this.tryUnify(this.apply(t15.t,t15.params,pl13),t2);
			case 11:
				let _g11 = t2.t;
				let _g12 = t2.args;
				let pl14 = _g9;
				let t16 = _g8;
				return this.tryUnify(this.apply(t16.t,t16.params,pl14),t2);
			default:
				let pl15 = _g9;
				let t17 = _g8;
				return this.tryUnify(this.apply(t17.t,t17.params,pl15),t2);
			}
			break;
		case 13:
			let _g13 = t1.args;
			let _g14 = t1.ret;
			switch(t2._hx_index) {
			case 0:
				let r6 = t2.r;
				if(r6.r == null) {
					if(!this.link(t2,t1,r6)) {
						return false;
					}
					r6.r = t1;
					return true;
				}
				return this.tryUnify(t1,r6.r);
			case 5:
				return true;
			case 8:
				let t28 = t2.t;
				return this.tryUnify(t1,t28);
			case 11:
				let t29 = t2.t;
				let pl25 = t2.args;
				return this.tryUnify(t1,this.apply(t29.t,t29.params,pl25));
			case 12:
				let _g15 = t2.a;
				let _g16 = t2.args;
				let _g17 = _g15.meta;
				let _g18 = _g15.params;
				let _g19 = _g15.t;
				if(_g15.name == "haxe.Function") {
					return true;
				}
				break;
			case 13:
				let args2 = t2.args;
				let r21 = t2.ret;
				let r11 = _g14;
				let args1 = _g13;
				if(args1.length == args2.length) {
					let _g = 0;
					let _g1 = args1.length;
					while(_g < _g1) {
						let i = _g++;
						let a1 = args1[i];
						let a2 = args2[i];
						if(a2.opt && !a1.opt) {
							return false;
						}
						if(!this.tryUnify(a2.t,a1.t)) {
							return false;
						}
					}
					return this.tryUnify(r11,r21);
				}
				break;
			default:
			}
			break;
		case 14:
			let _g20 = t1.fields;
			switch(t2._hx_index) {
			case 0:
				let r7 = t2.r;
				if(r7.r == null) {
					if(!this.link(t2,t1,r7)) {
						return false;
					}
					r7.r = t1;
					return true;
				}
				return this.tryUnify(t1,r7.r);
			case 5:
				return true;
			case 8:
				let t210 = t2.t;
				return this.tryUnify(t1,t210);
			case 11:
				let t211 = t2.t;
				let pl26 = t2.args;
				return this.tryUnify(t1,this.apply(t211.t,t211.params,pl26));
			case 14:
				let a2 = t2.fields;
				let a1 = _g20;
				if(a2.length == 0) {
					return true;
				}
				let m_h = Object.create(null);
				let _g21 = 0;
				while(_g21 < a1.length) {
					let f = a1[_g21];
					++_g21;
					m_h[f.name] = f;
				}
				let _g22 = 0;
				while(_g22 < a2.length) {
					let f2 = a2[_g22];
					++_g22;
					let f1 = m_h[f2.name];
					if(f1 == null) {
						if(f2.opt) {
							continue;
						}
						return false;
					}
					if(!this.typeEq(f1.t,f2.t)) {
						return false;
					}
				}
				return true;
			default:
			}
			break;
		default:
			switch(t2._hx_index) {
			case 0:
				let r8 = t2.r;
				if(r8.r == null) {
					if(!this.link(t2,t1,r8)) {
						return false;
					}
					r8.r = t1;
					return true;
				}
				return this.tryUnify(t1,r8.r);
			case 5:
				return true;
			case 8:
				let t212 = t2.t;
				return this.tryUnify(t1,t212);
			case 11:
				let t213 = t2.t;
				let pl27 = t2.args;
				return this.tryUnify(t1,this.apply(t213.t,t213.params,pl27));
			default:
			}
		}
		return this.typeEq(t1,t2);
	}
	unify(t1,t2,e) {
		if(!this.tryUnify(t1,t2)) {
			let e1 = hscript_ErrorDef.ECustom(hscript_Checker.typeStr(t1) + " should be " + hscript_Checker.typeStr(t2));
			let e2 = new hscript_Error(e1,e.pmin,e.pmax,e.origin,e.line);
			if(!this.isCompletion) {
				throw haxe_Exception.thrown(e2);
			}
		}
	}
	apply(t,params,args) {
		if(args.length != params.length) {
			throw haxe_Exception.thrown("Invalid number of type parameters");
		}
		if(args.length == 0) {
			return t;
		}
		let subst = new haxe_ds_EnumValueMap();
		let _g = 0;
		let _g1 = params.length;
		while(_g < _g1) {
			let i = _g++;
			subst.set(params[i],args[i]);
		}
		let map = null;
		let _gthis = this;
		map = function(t) {
			let st = subst.get(t);
			if(st != null) {
				return st;
			}
			return _gthis.mapType(t,map);
		};
		return map(t);
	}
	mapType(t,f) {
		switch(t._hx_index) {
		case 0:
			let r = t.r;
			if(r.r == null) {
				return t;
			}
			return f(t);
		case 1:case 2:case 3:case 4:case 5:
			return t;
		case 6:
			let _g = t.name;
			return t;
		case 7:
			let _g1 = t.name;
			return t;
		case 8:
			let t1 = t.t;
			return hscript_TType.TNull(f(t1));
		case 9:
			let _g2 = t.args;
			if(_g2.length == 0) {
				return t;
			} else {
				let args = _g2;
				let c = t.c;
				let _g = [];
				let _g1 = 0;
				while(_g1 < args.length) {
					let t = args[_g1];
					++_g1;
					_g.push(f(t));
				}
				return hscript_TType.TInst(c,_g);
			}
			break;
		case 10:
			let _g3 = t.args;
			if(_g3.length == 0) {
				return t;
			} else {
				let args = _g3;
				let e = t.e;
				let _g = [];
				let _g1 = 0;
				while(_g1 < args.length) {
					let t = args[_g1];
					++_g1;
					_g.push(f(t));
				}
				return hscript_TType.TEnum(e,_g);
			}
			break;
		case 11:
			let _g4 = t.args;
			if(_g4.length == 0) {
				return t;
			} else {
				let args = _g4;
				let t1 = t.t;
				let _g = [];
				let _g1 = 0;
				while(_g1 < args.length) {
					let t = args[_g1];
					++_g1;
					_g.push(f(t));
				}
				return hscript_TType.TType(t1,_g);
			}
			break;
		case 12:
			let _g5 = t.args;
			if(_g5.length == 0) {
				return t;
			} else {
				let args = _g5;
				let a = t.a;
				let _g = [];
				let _g1 = 0;
				while(_g1 < args.length) {
					let t = args[_g1];
					++_g1;
					_g.push(f(t));
				}
				return hscript_TType.TAbstract(a,_g);
			}
			break;
		case 13:
			let args = t.args;
			let ret = t.ret;
			let _g6 = [];
			let _g7 = 0;
			while(_g7 < args.length) {
				let a = args[_g7];
				++_g7;
				_g6.push({ name : a.name, opt : a.opt, t : f(a.t)});
			}
			return hscript_TType.TFun(_g6,f(ret));
		case 14:
			let fields = t.fields;
			let _g8 = [];
			let _g9 = 0;
			while(_g9 < fields.length) {
				let af = fields[_g9];
				++_g9;
				_g8.push({ name : af.name, opt : af.opt, t : f(af.t)});
			}
			return hscript_TType.TAnon(_g8);
		case 15:
			let l = t.f;
			return f(l());
		}
	}
	follow(t) {
		switch(t._hx_index) {
		case 0:
			let r = t.r;
			if(r.r != null) {
				return this.follow(r.r);
			} else {
				return t;
			}
			break;
		case 8:
			let t1 = t.t;
			return this.follow(t1);
		case 11:
			let t2 = t.t;
			let args = t.args;
			return this.follow(this.apply(t2.t,t2.params,args));
		case 15:
			let f = t.f;
			return this.follow(f());
		default:
			return t;
		}
	}
	getFields(t) {
		let fields = [];
		let _gthis = this;
		let _g = this.follow(t);
		switch(_g._hx_index) {
		case 9:
			let c = _g.c;
			let args = _g.args;
			let map = function(t) {
				return _gthis.apply(t,c.params,args);
			};
			while(c != null) {
				let h = c.fields.h;
				let fname_h = h;
				let fname_keys = Object.keys(h);
				let fname_length = fname_keys.length;
				let fname_current = 0;
				while(fname_current < fname_length) {
					let fname = fname_keys[fname_current++];
					let f = c.fields.h[fname];
					if(!f.isPublic || !f.complete) {
						continue;
					}
					let name = f.name;
					let t = map(f.t);
					if(this.allowAsync && name.startsWith("a_")) {
						t = this.unasync(t);
						name = HxOverrides.substr(name,2,null);
					}
					fields.push({ name : name, t : t});
				}
				if(c.isInterface && c.interfaces != null) {
					let _g = 0;
					let _g1 = c.interfaces;
					while(_g < _g1.length) {
						let i = _g1[_g];
						++_g;
						let _g2 = 0;
						let _g3 = this.getFields(i);
						while(_g2 < _g3.length) {
							let f = _g3[_g2];
							++_g2;
							fields.push({ name : f.name, t : map(f.t)});
						}
					}
				}
				if(c.superClass == null) {
					break;
				}
				let _g = c.superClass;
				if(_g == null) {
					break;
				} else if(_g._hx_index == 9) {
					let csup = _g.c;
					let args = _g.args;
					let curMap = map;
					map = function(t) {
						return curMap(_gthis.apply(t,csup.params,args));
					};
					c = csup;
				} else {
					break;
				}
			}
			break;
		case 13:
			let args1 = _g.args;
			let ret = _g.ret;
			if(this.isCompletion) {
				fields.push({ name : "bind", t : hscript_TType.TFun(args1,hscript_TType.TVoid)});
			}
			break;
		case 14:
			let fl = _g.fields;
			let _g1 = 0;
			while(_g1 < fl.length) {
				let f = fl[_g1];
				++_g1;
				fields.push({ name : f.name, t : f.t});
			}
			break;
		default:
		}
		return fields;
	}
	getField(t,f,e,forWrite) {
		if(forWrite == null) {
			forWrite = false;
		}
		let _g = this.follow(t);
		switch(_g._hx_index) {
		case 5:
			return this.makeMono();
		case 9:
			let c = _g.c;
			let args = _g.args;
			let cf = c.fields.h[f];
			if(cf == null && this.allowAsync) {
				cf = c.fields.h["a_" + f];
				if(cf != null) {
					let isPublic = true;
					cf = { isPublic : isPublic, canWrite : false, params : cf.params, name : cf.name, t : this.unasync(cf.t), complete : cf.complete};
					if(cf.t == null) {
						cf = null;
					}
				}
			}
			if(cf == null && c.isInterface && c.interfaces != null) {
				let _g = 0;
				let _g1 = c.interfaces;
				while(_g < _g1.length) {
					let i = _g1[_g];
					++_g;
					let ft = this.getField(i,f,e,forWrite);
					if(ft != null) {
						return this.apply(ft,c.params,args);
					}
				}
			}
			if(cf == null) {
				if(c.superClass == null) {
					return null;
				}
				let ft = this.getField(c.superClass,f,e,forWrite);
				if(ft != null) {
					ft = this.apply(ft,c.params,args);
				}
				return ft;
			}
			if(!cf.isPublic) {
				let e1 = hscript_ErrorDef.ECustom("Can't access private field " + f + " on " + c.name);
				let e2 = new hscript_Error(e1,e.pmin,e.pmax,e.origin,e.line);
				if(!this.isCompletion) {
					throw haxe_Exception.thrown(e2);
				}
			}
			if(forWrite && !cf.canWrite) {
				let e1 = hscript_ErrorDef.ECustom("Can't write readonly field " + f + " on " + c.name);
				let e2 = new hscript_Error(e1,e.pmin,e.pmax,e.origin,e.line);
				if(!this.isCompletion) {
					throw haxe_Exception.thrown(e2);
				}
			}
			let t1 = cf.t;
			if(cf.params != null) {
				let cf1 = cf.params;
				let _g = [];
				let _g1 = 0;
				let _g2 = cf.params.length;
				while(_g1 < _g2) {
					let i = _g1++;
					_g.push(this.makeMono());
				}
				t1 = this.apply(t1,cf1,_g);
			}
			return this.apply(t1,c.params,args);
		case 14:
			let fields = _g.fields;
			let _g1 = 0;
			while(_g1 < fields.length) {
				let af = fields[_g1];
				++_g1;
				if(af.name == f) {
					return af.t;
				}
			}
			return null;
		default:
			return null;
		}
	}
	unasync(t) {
		let _g = this.follow(t);
		if(_g._hx_index == 13) {
			let args = _g.args;
			let ret = _g.ret;
			if(args.length > 0) {
				let rargs = args.slice();
				let _g = this.follow(rargs.shift().t);
				if(_g._hx_index == 13) {
					let _g1 = _g.args;
					let _g2 = _g.ret;
					if(_g1.length == 1) {
						let r = _g1[0];
						return hscript_TType.TFun(rargs,r.t);
					}
				}
			}
		}
		return null;
	}
	typeExprWith(expr,t) {
		let et = this.typeExpr(expr,hscript__$Checker_WithType.WithType(t));
		this.unify(et,t,expr);
		return t;
	}
	makeMono() {
		return hscript_TType.TMono({ r : null});
	}
	makeIterator(t) {
		return hscript_TType.TAnon([{ name : "next", opt : false, t : hscript_TType.TFun([],t)},{ name : "hasNext", opt : false, t : hscript_TType.TFun([],hscript_TType.TBool)}]);
	}
	mk(e,p) {
		return { e : e, pmin : p.pmin, pmax : p.pmax, origin : p.origin, line : p.line};
	}
	isString(t) {
		t = this.follow(t);
		if(t._hx_index == 9) {
			let _g = t.c;
			let _g1 = t.args;
			let _g2 = _g.constructor;
			let _g3 = _g.fields;
			let _g4 = _g.interfaces;
			let _g5 = _g.isInterface;
			let _g6 = _g.meta;
			let _g7 = _g.params;
			let _g8 = _g.statics;
			let _g9 = _g.superClass;
			if(_g.name == "String") {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	onCompletion(expr,t) {
		if(this.isCompletion) {
			throw haxe_Exception.thrown(new hscript_Completion(expr,t));
		}
	}
	typeField(o,f,expr,forWrite) {
		let ot = this.typeExpr(o,hscript__$Checker_WithType.Value);
		if(f == null) {
			this.onCompletion(expr,ot);
		}
		let ft = this.getField(ot,f,expr,forWrite);
		if(ft == null) {
			let e = hscript_ErrorDef.ECustom(hscript_Checker.typeStr(ot) + " has no field " + f);
			let e1 = new hscript_Error(e,expr.pmin,expr.pmax,expr.origin,expr.line);
			if(!this.isCompletion) {
				throw haxe_Exception.thrown(e1);
			}
			ft = hscript_TType.TDynamic;
		}
		return ft;
	}
	typeExpr(expr,withType) {
		if(expr == null && this.isCompletion) {
			if(withType._hx_index == 2) {
				let t = withType.t;
				return t;
			} else {
				return hscript_TType.TDynamic;
			}
		}
		let _gthis = this;
		let _g = expr.e;
		switch(_g._hx_index) {
		case 0:
			let c = _g.c;
			switch(c._hx_index) {
			case 0:
				let _g1 = c.v;
				return hscript_TType.TInt;
			case 1:
				let _g2 = c.f;
				return hscript_TType.TFloat;
			case 2:
				let _g3 = c.s;
				return this.types.t_string;
			}
			break;
		case 1:
			let v = _g.v;
			let l = this.locals.h[v];
			if(l != null) {
				return l;
			}
			let g = this.globals.h[v];
			if(g != null) {
				if(g == null) {
					return g;
				} else if(g._hx_index == 15) {
					let f = g.f;
					return f();
				} else {
					return g;
				}
			}
			if(this.allowAsync) {
				g = this.globals.h["a_" + v];
				if(g != null) {
					g = this.unasync(g);
				}
				if(g != null) {
					return g;
				}
			}
			switch(v) {
			case "false":case "true":
				return hscript_TType.TBool;
			case "null":
				return this.makeMono();
			case "trace":
				return hscript_TType.TDynamic;
			default:
				if(withType._hx_index == 2) {
					let _g = withType.t;
					if(_g._hx_index == 10) {
						let et = _g;
						let e = _g.e;
						let args = _g.args;
						let _g1 = 0;
						let _g2 = e.constructors;
						while(_g1 < _g2.length) {
							let c = _g2[_g1];
							++_g1;
							if(c.name == v) {
								if(this.onTopDownEnum(e,v)) {
									let ct = c.args == null ? et : hscript_TType.TFun(c.args,et);
									return this.apply(ct,e.params,args);
								}
								break;
							}
						}
					}
				}
				if(this.isCompletion) {
					return hscript_TType.TDynamic;
				}
				let e = hscript_ErrorDef.ECustom("Unknown identifier " + v);
				let e1 = new hscript_Error(e,expr.pmin,expr.pmax,expr.origin,expr.line);
				if(!this.isCompletion) {
					throw haxe_Exception.thrown(e1);
				}
			}
			break;
		case 2:
			let n = _g.n;
			let t = _g.t;
			let init = _g.e;
			let vt = t == null ? this.makeMono() : this.makeType(t,expr);
			if(init != null) {
				let et = this.typeExpr(init,t == null ? hscript__$Checker_WithType.Value : hscript__$Checker_WithType.WithType(vt));
				if(t == null) {
					vt = et;
				} else {
					this.unify(et,vt,init);
				}
			}
			this.locals.h[n] = vt;
			return hscript_TType.TVoid;
		case 3:
			let e2 = _g.e;
			return this.typeExpr(e2,withType);
		case 4:
			let el = _g.e;
			let t1 = hscript_TType.TVoid;
			let locals = this.saveLocals();
			let _g4 = 0;
			while(_g4 < el.length) {
				let e = el[_g4];
				++_g4;
				t1 = this.typeExpr(e,e == el[el.length - 1] ? withType : hscript__$Checker_WithType.NoValue);
			}
			this.locals = locals;
			return t1;
		case 5:
			let o = _g.e;
			let f = _g.f;
			return this.typeField(o,f,expr,false);
		case 6:
			let op = _g.op;
			let e11 = _g.e1;
			let e21 = _g.e2;
			switch(op) {
			case "!=":case "==":
				let t11 = this.typeExpr(e11,hscript__$Checker_WithType.Value);
				let t2 = this.typeExpr(e21,hscript__$Checker_WithType.WithType(t11));
				if(!this.tryUnify(t11,t2)) {
					this.unify(t2,t11,e21);
				}
				return hscript_TType.TBool;
			case "%":case "*":case "-":case "/":
				let t12 = this.typeExpr(e11,hscript__$Checker_WithType.WithType(hscript_TType.TInt));
				let t21 = this.typeExpr(e21,hscript__$Checker_WithType.WithType(t12));
				if(!this.tryUnify(t12,t21)) {
					this.unify(t21,t12,e21);
				}
				let _g5 = this.follow(t12);
				let _g6 = this.follow(t21);
				switch(_g5._hx_index) {
				case 2:
					switch(_g6._hx_index) {
					case 2:
						if(op == "/") {
							return hscript_TType.TFloat;
						}
						return hscript_TType.TInt;
					case 3:case 5:
						return hscript_TType.TFloat;
					default:
						this.unify(t12,hscript_TType.TFloat,e11);
						this.unify(t21,hscript_TType.TFloat,e21);
					}
					break;
				case 3:
					switch(_g6._hx_index) {
					case 2:case 3:case 5:
						return hscript_TType.TFloat;
					default:
						this.unify(t12,hscript_TType.TFloat,e11);
						this.unify(t21,hscript_TType.TFloat,e21);
					}
					break;
				case 5:
					switch(_g6._hx_index) {
					case 2:case 3:case 5:
						return hscript_TType.TFloat;
					default:
						this.unify(t12,hscript_TType.TFloat,e11);
						this.unify(t21,hscript_TType.TFloat,e21);
					}
					break;
				default:
					this.unify(t12,hscript_TType.TFloat,e11);
					this.unify(t21,hscript_TType.TFloat,e21);
				}
				break;
			case "+":
				let t13 = this.typeExpr(e11,hscript__$Checker_WithType.WithType(hscript_TType.TInt));
				let t22 = this.typeExpr(e21,hscript__$Checker_WithType.WithType(t13));
				this.tryUnify(t13,t22);
				let _g7 = this.follow(t13);
				let _g8 = this.follow(t22);
				switch(_g7._hx_index) {
				case 2:
					switch(_g8._hx_index) {
					case 2:
						return hscript_TType.TInt;
					case 3:
						return hscript_TType.TFloat;
					case 5:
						return hscript_TType.TDynamic;
					default:
						let t14 = _g7;
						let t23 = _g8;
						if(this.isString(t14) || this.isString(t23)) {
							return this.types.t_string;
						}
						this.unify(t14,hscript_TType.TFloat,e11);
						this.unify(t23,hscript_TType.TFloat,e21);
					}
					break;
				case 3:
					switch(_g8._hx_index) {
					case 2:case 3:
						return hscript_TType.TFloat;
					case 5:
						return hscript_TType.TDynamic;
					default:
						let t15 = _g7;
						let t24 = _g8;
						if(this.isString(t15) || this.isString(t24)) {
							return this.types.t_string;
						}
						this.unify(t15,hscript_TType.TFloat,e11);
						this.unify(t24,hscript_TType.TFloat,e21);
					}
					break;
				case 5:
					return hscript_TType.TDynamic;
				default:
					if(_g8._hx_index == 5) {
						return hscript_TType.TDynamic;
					} else {
						let t1 = _g7;
						let t2 = _g8;
						if(this.isString(t1) || this.isString(t2)) {
							return this.types.t_string;
						}
						this.unify(t1,hscript_TType.TFloat,e11);
						this.unify(t2,hscript_TType.TFloat,e21);
					}
				}
				break;
			case "...":
				this.typeExprWith(e11,hscript_TType.TInt);
				this.typeExprWith(e21,hscript_TType.TInt);
				return this.makeIterator(hscript_TType.TInt);
			case "&":case "<<":case ">>":case ">>>":case "^":case "|":
				this.typeExprWith(e11,hscript_TType.TInt);
				this.typeExprWith(e21,hscript_TType.TInt);
				return hscript_TType.TInt;
			case "<":case "<=":case ">":case ">=":
				let t16 = this.typeExpr(e11,hscript__$Checker_WithType.Value);
				let t25 = this.typeExpr(e21,hscript__$Checker_WithType.WithType(t16));
				if(!this.tryUnify(t16,t25)) {
					this.unify(t25,t16,e21);
				}
				let _g9 = this.follow(t16);
				switch(_g9._hx_index) {
				case 2:case 3:case 4:
					break;
				case 9:
					let _g10 = _g9.c;
					let _g11 = _g9.args;
					let _g12 = _g10.constructor;
					let _g13 = _g10.fields;
					let _g14 = _g10.interfaces;
					let _g15 = _g10.isInterface;
					let _g16 = _g10.meta;
					let _g17 = _g10.params;
					let _g18 = _g10.statics;
					let _g19 = _g10.superClass;
					if(_g10.name != "String") {
						let e = hscript_ErrorDef.ECustom("Cannot compare " + hscript_Checker.typeStr(t16));
						let e1 = new hscript_Error(e,expr.pmin,expr.pmax,expr.origin,expr.line);
						if(!this.isCompletion) {
							throw haxe_Exception.thrown(e1);
						}
					}
					break;
				default:
					let e3 = hscript_ErrorDef.ECustom("Cannot compare " + hscript_Checker.typeStr(t16));
					let e4 = new hscript_Error(e3,expr.pmin,expr.pmax,expr.origin,expr.line);
					if(!this.isCompletion) {
						throw haxe_Exception.thrown(e4);
					}
				}
				return hscript_TType.TBool;
			case "=":
				if(this.allowDefine) {
					let _g = e11.e;
					if(_g._hx_index == 1) {
						let i = _g.v;
						if(!Object.prototype.hasOwnProperty.call(this.locals.h,i) && !Object.prototype.hasOwnProperty.call(this.globals.h,i)) {
							let vt = this.typeExpr(e21,hscript__$Checker_WithType.Value);
							this.locals.h[i] = vt;
							return vt;
						}
					}
				}
				let vt1;
				let _g20 = e11.e;
				if(_g20._hx_index == 5) {
					let o = _g20.e;
					let f = _g20.f;
					vt1 = this.typeField(o,f,e11,true);
				} else {
					vt1 = this.typeExpr(e11,hscript__$Checker_WithType.Value);
				}
				this.typeExprWith(e21,vt1);
				return vt1;
			case "&&":case "||":
				this.typeExprWith(e11,hscript_TType.TBool);
				this.typeExprWith(e21,hscript_TType.TBool);
				return hscript_TType.TBool;
			default:
				if(HxOverrides.cca(op,op.length - 1) == 61) {
					let t = this.typeExpr(this.mk(hscript_ExprDef.EBinop(HxOverrides.substr(op,0,op.length - 1),e11,e21),expr),withType);
					return this.typeExpr(this.mk(hscript_ExprDef.EBinop("=",e11,e21),expr),withType);
				}
				let e5 = hscript_ErrorDef.ECustom("Unsupported operation " + op);
				let e6 = new hscript_Error(e5,expr.pmin,expr.pmax,expr.origin,expr.line);
				if(!this.isCompletion) {
					throw haxe_Exception.thrown(e6);
				}
			}
			break;
		case 7:
			let _g21 = _g.prefix;
			let op1 = _g.op;
			let e7 = _g.e;
			let et = this.typeExpr(e7,hscript__$Checker_WithType.Value);
			switch(op1) {
			case "!":
				this.unify(et,hscript_TType.TBool,e7);
				return et;
			case "++":case "-":case "--":
				this.unify(et,hscript_TType.TInt,e7);
				return et;
			default:
			}
			break;
		case 8:
			let e8 = _g.e;
			let params = _g.params;
			let _g22 = e8.e;
			if(_g22._hx_index == 5) {
				if(_g22.f == "bind") {
					let val = _g22.e;
					let ft = this.typeExpr(val,hscript__$Checker_WithType.Value);
					if(ft._hx_index == 13) {
						let args = ft.args;
						let ret = ft.ret;
						let remainArgs = args.slice();
						let _g = 0;
						while(_g < params.length) {
							let p = params[_g];
							++_g;
							let a = remainArgs.shift();
							if(a == null) {
								let e = hscript_ErrorDef.ECustom("Too many arguments");
								let e1 = new hscript_Error(e,p.pmin,p.pmax,p.origin,p.line);
								if(!this.isCompletion) {
									throw haxe_Exception.thrown(e1);
								}
								return hscript_TType.TFun([],ret);
							}
							this.typeExprWith(p,a.t);
						}
						return hscript_TType.TFun(remainArgs,ret);
					}
				}
			}
			let _g23 = e8.e;
			let ft;
			if(_g23._hx_index == 1) {
				let _g = _g23.v;
				if(withType._hx_index == 2) {
					let _g = withType.t;
					if(_g._hx_index == 10) {
						let _g1 = _g.e;
						let _g2 = _g.args;
						ft = withType;
					} else {
						ft = hscript__$Checker_WithType.Value;
					}
				} else {
					ft = hscript__$Checker_WithType.Value;
				}
			} else {
				ft = hscript__$Checker_WithType.Value;
			}
			let ft1 = this.typeExpr(e8,ft);
			let _g24 = this.follow(ft1);
			switch(_g24._hx_index) {
			case 5:
				let _g25 = 0;
				while(_g25 < params.length) {
					let p = params[_g25];
					++_g25;
					this.typeExpr(p,hscript__$Checker_WithType.Value);
				}
				return this.makeMono();
			case 13:
				let args = _g24.args;
				let ret = _g24.ret;
				let _g26 = 0;
				let _g27 = params.length;
				while(_g26 < _g27) {
					let i = _g26++;
					let a = args[i];
					if(a == null) {
						let curExpr = params[i];
						let e = hscript_ErrorDef.ECustom("Too many arguments");
						let e1 = new hscript_Error(e,curExpr.pmin,curExpr.pmax,curExpr.origin,curExpr.line);
						if(!this.isCompletion) {
							throw haxe_Exception.thrown(e1);
						}
						break;
					}
					let t = this.typeExpr(params[i],a == null ? hscript__$Checker_WithType.Value : hscript__$Checker_WithType.WithType(a.t));
					this.unify(t,a.t,params[i]);
				}
				let _g28 = params.length;
				let _g29 = args.length;
				while(_g28 < _g29) {
					let i = _g28++;
					if(!args[i].opt) {
						let e = hscript_ErrorDef.ECustom("Missing argument " + args[i].name + ":" + hscript_Checker.typeStr(args[i].t));
						let e1 = new hscript_Error(e,expr.pmin,expr.pmax,expr.origin,expr.line);
						if(!this.isCompletion) {
							throw haxe_Exception.thrown(e1);
						}
					}
				}
				return ret;
			default:
				let e9 = hscript_ErrorDef.ECustom(hscript_Checker.typeStr(ft1) + " cannot be called");
				let e10 = new hscript_Error(e9,e8.pmin,e8.pmax,e8.origin,e8.line);
				if(!this.isCompletion) {
					throw haxe_Exception.thrown(e10);
				}
				return this.makeMono();
			}
			break;
		case 9:
			let cond = _g.cond;
			let e12 = _g.e1;
			let e22 = _g.e2;
			this.typeExprWith(cond,hscript_TType.TBool);
			let t17 = this.typeExpr(e12,withType);
			if(e22 == null) {
				return t17;
			}
			let t26 = this.typeExpr(e22,withType);
			if(withType == hscript__$Checker_WithType.NoValue) {
				return hscript_TType.TVoid;
			}
			if(this.tryUnify(t26,t17)) {
				return t17;
			}
			if(this.tryUnify(t17,t26)) {
				return t26;
			}
			this.unify(t26,t17,e22);
			break;
		case 10:
			let cond1 = _g.cond;
			let e13 = _g.e;
			this.typeExprWith(cond1,hscript_TType.TBool);
			this.typeExpr(e13,hscript__$Checker_WithType.NoValue);
			return hscript_TType.TVoid;
		case 11:
			let v1 = _g.v;
			let it = _g.it;
			let e14 = _g.e;
			let locals1 = this.saveLocals();
			let itt = this.typeExpr(it,hscript__$Checker_WithType.Value);
			let vt2 = this.getIteratorType(it,itt);
			this.locals.h[v1] = vt2;
			this.typeExpr(e14,hscript__$Checker_WithType.NoValue);
			this.locals = locals1;
			return hscript_TType.TVoid;
		case 12:case 13:
			return hscript_TType.TVoid;
		case 14:
			let args1 = _g.args;
			let body = _g.e;
			let name = _g.name;
			let ret1 = _g.ret;
			let ft2 = null;
			let tret = null;
			let targs = null;
			if(this.currentFunType != null) {
				let _g = this.currentFunType;
				if(_g._hx_index == 13) {
					let args = _g.args;
					let ret = _g.ret;
					ft2 = this.currentFunType;
					tret = ret;
					targs = args;
				} else {
					throw haxe_Exception.thrown("assert");
				}
				this.currentFunType = null;
			} else {
				tret = ret1 == null ? this.makeMono() : this.makeType(ret1,expr);
			}
			let locals2 = this.saveLocals();
			let oldRet = this.allowReturn;
			let oldGDef = this.allowDefine;
			let oldHasRet = this.hasReturn;
			this.allowReturn = tret;
			this.allowDefine = false;
			this.hasReturn = false;
			let withArgs = null;
			let tmp;
			if(name != null) {
				let tmp1;
				if(withType._hx_index == 2) {
					let _hx_tmp = this.follow(withType.t);
					if(_hx_tmp._hx_index == 13) {
						let _g = _hx_tmp.args;
						let _g1 = _hx_tmp.ret;
						tmp1 = true;
					} else {
						tmp1 = false;
					}
				} else {
					tmp1 = false;
				}
				tmp = !tmp1;
			} else {
				tmp = false;
			}
			if(tmp) {
				let ev = this.events.h[name];
				if(ev != null) {
					withType = hscript__$Checker_WithType.WithType(ev);
				}
			}
			if(withType._hx_index == 2) {
				let _hx_tmp = this.follow(withType.t);
				if(_hx_tmp._hx_index == 13) {
					let args = _hx_tmp.args;
					let ret = _hx_tmp.ret;
					withArgs = args;
					this.unify(tret,ret,expr);
				}
			}
			if(targs == null) {
				targs = this.typeArgs(args1,expr);
			}
			let _g30 = 0;
			let _g31 = targs.length;
			while(_g30 < _g31) {
				let i = _g30++;
				let a = targs[i];
				if(withArgs != null) {
					if(i < withArgs.length) {
						this.unify(withArgs[i].t,a.t,expr);
					} else {
						let e = hscript_ErrorDef.ECustom("Extra argument " + a.name);
						let e1 = new hscript_Error(e,expr.pmin,expr.pmax,expr.origin,expr.line);
						if(!this.isCompletion) {
							throw haxe_Exception.thrown(e1);
						}
					}
				}
				this.locals.h[a.name] = a.t;
			}
			if(withArgs != null && targs.length < withArgs.length) {
				let msg = "Missing " + (withArgs.length - targs.length) + " arguments (";
				let _g = [];
				let _g1 = targs.length;
				let _g2 = withArgs.length;
				while(_g1 < _g2) {
					let i = _g1++;
					_g.push(hscript_Checker.typeStr(withArgs[i].t));
				}
				let e = hscript_ErrorDef.ECustom(msg + _g.join(",") + ")");
				let e1 = new hscript_Error(e,expr.pmin,expr.pmax,expr.origin,expr.line);
				if(!this.isCompletion) {
					throw haxe_Exception.thrown(e1);
				}
			}
			this.typeExpr(body,hscript__$Checker_WithType.NoValue);
			if(!this.hasReturn && !this.tryUnify(tret,hscript_TType.TVoid)) {
				let e = hscript_ErrorDef.ECustom("Missing return " + hscript_Checker.typeStr(tret));
				let e1 = new hscript_Error(e,expr.pmin,expr.pmax,expr.origin,expr.line);
				if(!this.isCompletion) {
					throw haxe_Exception.thrown(e1);
				}
			}
			this.allowDefine = oldGDef;
			this.allowReturn = oldRet;
			this.hasReturn = oldHasRet;
			this.locals = locals2;
			if(ft2 == null) {
				ft2 = hscript_TType.TFun(targs,tret);
				if(name != null) {
					locals2.h[name] = ft2;
				}
			}
			return ft2;
		case 15:
			let v2 = _g.e;
			let et1 = v2 == null ? hscript_TType.TVoid : this.typeExpr(v2,this.allowReturn == null ? hscript__$Checker_WithType.Value : hscript__$Checker_WithType.WithType(this.allowReturn));
			this.hasReturn = true;
			if(this.allowReturn == null) {
				let e = hscript_ErrorDef.ECustom("Return not allowed here");
				let e1 = new hscript_Error(e,expr.pmin,expr.pmax,expr.origin,expr.line);
				if(!this.isCompletion) {
					throw haxe_Exception.thrown(e1);
				}
			} else {
				this.unify(et1,this.allowReturn,v2 == null ? expr : v2);
			}
			return this.makeMono();
		case 16:
			let a = _g.e;
			let index = _g.index;
			this.typeExprWith(index,hscript_TType.TInt);
			let at = this.typeExpr(a,hscript__$Checker_WithType.Value);
			let _g32 = this.follow(at);
			if(_g32._hx_index == 9) {
				let _g = _g32.c;
				let _g1 = _g32.args;
				let _g2 = _g.constructor;
				let _g3 = _g.fields;
				let _g4 = _g.interfaces;
				let _g5 = _g.isInterface;
				let _g6 = _g.meta;
				let _g7 = _g.params;
				let _g8 = _g.statics;
				let _g9 = _g.superClass;
				if(_g.name == "Array") {
					if(_g1.length == 1) {
						let et = _g1[0];
						return et;
					} else {
						let e = hscript_ErrorDef.ECustom(hscript_Checker.typeStr(at) + " is not an Array");
						let e1 = new hscript_Error(e,a.pmin,a.pmax,a.origin,a.line);
						if(!this.isCompletion) {
							throw haxe_Exception.thrown(e1);
						}
					}
				} else {
					let e = hscript_ErrorDef.ECustom(hscript_Checker.typeStr(at) + " is not an Array");
					let e1 = new hscript_Error(e,a.pmin,a.pmax,a.origin,a.line);
					if(!this.isCompletion) {
						throw haxe_Exception.thrown(e1);
					}
				}
			} else {
				let e = hscript_ErrorDef.ECustom(hscript_Checker.typeStr(at) + " is not an Array");
				let e1 = new hscript_Error(e,a.pmin,a.pmax,a.origin,a.line);
				if(!this.isCompletion) {
					throw haxe_Exception.thrown(e1);
				}
			}
			break;
		case 17:
			let el1 = _g.e;
			let et2 = null;
			let _g33 = 0;
			while(_g33 < el1.length) {
				let v = el1[_g33];
				++_g33;
				let t = this.typeExpr(v,et2 == null ? hscript__$Checker_WithType.Value : hscript__$Checker_WithType.WithType(et2));
				if(et2 == null) {
					et2 = t;
				} else if(!this.tryUnify(t,et2)) {
					if(this.tryUnify(et2,t)) {
						et2 = t;
					} else {
						this.unify(t,et2,v);
					}
				}
			}
			if(et2 == null) {
				et2 = this.makeMono();
			}
			return this.types.getType("Array",[et2]);
		case 18:
			let cl = _g.cl;
			let params1 = _g.params;
			break;
		case 19:
			let e15 = _g.e;
			this.typeExpr(e15,hscript__$Checker_WithType.Value);
			return this.makeMono();
		case 20:
			let etry = _g.e;
			let v3 = _g.v;
			let et3 = _g.t;
			let ecatch = _g.ecatch;
			let vt3 = this.typeExpr(etry,withType);
			let old = this.locals.h[v3];
			let this1 = this.locals;
			let value = this.makeType(et3,ecatch);
			this1.h[v3] = value;
			let ct = this.typeExpr(ecatch,withType);
			if(old != null) {
				this.locals.h[v3] = old;
			} else {
				let _this = this.locals;
				if(Object.prototype.hasOwnProperty.call(_this.h,v3)) {
					delete(_this.h[v3]);
				}
			}
			if(withType == hscript__$Checker_WithType.NoValue) {
				return hscript_TType.TVoid;
			}
			if(this.tryUnify(vt3,ct)) {
				return ct;
			}
			this.unify(ct,vt3,ecatch);
			return vt3;
		case 21:
			let fl = _g.fl;
			if(withType._hx_index == 2) {
				let _hx_tmp = this.follow(withType.t);
				if(_hx_tmp._hx_index == 14) {
					let tfields = _hx_tmp.fields;
					if(tfields.length > 0) {
						let map_h = Object.create(null);
						let _g = 0;
						while(_g < tfields.length) {
							let f = tfields[_g];
							++_g;
							map_h[f.name] = f;
						}
						let _g1 = [];
						let _g2 = 0;
						while(_g2 < fl.length) {
							let f = fl[_g2];
							++_g2;
							let ft = map_h[f.name];
							let ft1;
							if(ft == null) {
								let curExpr = f.e;
								let e = hscript_ErrorDef.ECustom("Extra field " + f.name);
								let e1 = new hscript_Error(e,curExpr.pmin,curExpr.pmax,curExpr.origin,curExpr.line);
								if(!this.isCompletion) {
									throw haxe_Exception.thrown(e1);
								}
								ft1 = hscript_TType.TDynamic;
							} else {
								ft1 = ft.t;
							}
							_g1.push({ t : this.typeExprWith(f.e,ft1), opt : false, name : f.name});
						}
						return hscript_TType.TAnon(_g1);
					} else {
						let _g = [];
						let _g1 = 0;
						while(_g1 < fl.length) {
							let f = fl[_g1];
							++_g1;
							_g.push({ t : this.typeExpr(f.e,hscript__$Checker_WithType.Value), opt : false, name : f.name});
						}
						return hscript_TType.TAnon(_g);
					}
				} else {
					let _g = [];
					let _g1 = 0;
					while(_g1 < fl.length) {
						let f = fl[_g1];
						++_g1;
						_g.push({ t : this.typeExpr(f.e,hscript__$Checker_WithType.Value), opt : false, name : f.name});
					}
					return hscript_TType.TAnon(_g);
				}
			} else {
				let _g = [];
				let _g1 = 0;
				while(_g1 < fl.length) {
					let f = fl[_g1];
					++_g1;
					_g.push({ t : this.typeExpr(f.e,hscript__$Checker_WithType.Value), opt : false, name : f.name});
				}
				return hscript_TType.TAnon(_g);
			}
			break;
		case 22:
			let cond2 = _g.cond;
			let e16 = _g.e1;
			let e23 = _g.e2;
			this.typeExprWith(cond2,hscript_TType.TBool);
			let t18 = this.typeExpr(e16,withType);
			if(e23 == null) {
				return t18;
			}
			let t27 = this.typeExpr(e23,withType);
			if(withType == hscript__$Checker_WithType.NoValue) {
				return hscript_TType.TVoid;
			}
			if(this.tryUnify(t27,t18)) {
				return t18;
			}
			if(this.tryUnify(t18,t27)) {
				return t27;
			}
			this.unify(t27,t18,e23);
			break;
		case 23:
			let value1 = _g.e;
			let cases = _g.cases;
			let defaultExpr = _g.defaultExpr;
			let tmin = null;
			let vt4 = this.typeExpr(value1,hscript__$Checker_WithType.Value);
			let _g34 = 0;
			while(_g34 < cases.length) {
				let c = cases[_g34];
				++_g34;
				let _g = 0;
				let _g1 = c.values;
				while(_g < _g1.length) {
					let v = _g1[_g];
					++_g;
					let ct = this.typeExpr(v,hscript__$Checker_WithType.WithType(vt4));
					this.unify(ct,vt4,v);
				}
				let et = this.typeExpr(c.expr,withType);
				let p = c.expr;
				if(withType != hscript__$Checker_WithType.NoValue) {
					if(tmin == null) {
						tmin = et;
					} else if(!_gthis.tryUnify(et,tmin)) {
						_gthis.unify(tmin,et,p);
						tmin = et;
					}
				}
			}
			if(defaultExpr != null) {
				let t = this.typeExpr(defaultExpr,withType);
				if(withType != hscript__$Checker_WithType.NoValue) {
					if(tmin == null) {
						tmin = t;
					} else if(!_gthis.tryUnify(t,tmin)) {
						_gthis.unify(tmin,t,defaultExpr);
						tmin = t;
					}
				}
			}
			if(withType == hscript__$Checker_WithType.NoValue) {
				return hscript_TType.TVoid;
			} else if(tmin == null) {
				return this.makeMono();
			} else {
				return tmin;
			}
			break;
		case 24:
			let cond3 = _g.cond;
			let e17 = _g.e;
			this.typeExprWith(cond3,hscript_TType.TBool);
			this.typeExpr(e17,hscript__$Checker_WithType.NoValue);
			return hscript_TType.TVoid;
		case 25:
			let _g35 = _g.args;
			let m = _g.name;
			let e18 = _g.e;
			if(m == ":untyped" && this.allowUntypedMeta) {
				return this.makeMono();
			}
			return this.typeExpr(e18,withType);
		case 26:
			let v4 = _g.e;
			let t3 = _g.t;
			let ct1 = this.makeType(t3,expr);
			let vt5 = this.typeExpr(v4,hscript__$Checker_WithType.WithType(ct1));
			this.unify(vt5,ct1,v4);
			return ct1;
		}
		let e19 = expr.e;
		let e20 = hscript_ErrorDef.ECustom("Don't know how to type " + $hxEnums[e19.__enum__].__constructs__[e19._hx_index]._hx_name);
		let e24 = new hscript_Error(e20,expr.pmin,expr.pmax,expr.origin,expr.line);
		if(!this.isCompletion) {
			throw haxe_Exception.thrown(e24);
		}
		return hscript_TType.TDynamic;
	}
	getIteratorType(it,itt) {
		let _g = this.follow(itt);
		if(_g._hx_index == 9) {
			let _g1 = _g.c;
			let _g2 = _g.args;
			let _g3 = _g1.constructor;
			let _g4 = _g1.fields;
			let _g5 = _g1.interfaces;
			let _g6 = _g1.isInterface;
			let _g7 = _g1.meta;
			let _g8 = _g1.params;
			let _g9 = _g1.statics;
			let _g10 = _g1.superClass;
			if(_g1.name == "Array") {
				if(_g2.length == 1) {
					let t = _g2[0];
					return t;
				}
			}
		}
		let ft = this.getField(itt,"iterator",it);
		if(ft == null) {
			if(itt._hx_index == 12) {
				let a = itt.a;
				let args = itt.args;
				let at = this.apply(a.t,a.params,args);
				return this.getIteratorType(it,at);
			}
		}
		if(ft != null) {
			if(ft == null) {
				ft = null;
			} else if(ft._hx_index == 13) {
				if(ft.args.length == 0) {
					let ret = ft.ret;
					ft = ret;
				} else {
					ft = null;
				}
			} else {
				ft = null;
			}
		}
		let t = this.makeMono();
		let iter = this.makeIterator(t);
		this.unify(ft != null ? ft : itt,iter,it);
		return t;
	}
	static typeStr(t) {
		switch(t._hx_index) {
		case 0:
			let r = t.r;
			if(r.r == null) {
				return "Unknown";
			} else {
				return hscript_Checker.typeStr(r.r);
			}
			break;
		case 6:
			let name = t.name;
			return name;
		case 7:
			let name1 = t.name;
			return "?" + name1;
		case 8:
			let t1 = t.t;
			return "Null<" + hscript_Checker.typeStr(t1) + ">";
		case 9:
			let c = t.c;
			let args = t.args;
			let c1 = c.name;
			let tmp;
			if(args.length == 0) {
				tmp = "";
			} else {
				let _g = [];
				let _g1 = 0;
				while(_g1 < args.length) {
					let t = args[_g1];
					++_g1;
					_g.push(hscript_Checker.typeStr(t));
				}
				tmp = "<" + _g.join(",") + ">";
			}
			return c1 + tmp;
		case 10:
			let e = t.e;
			let args1 = t.args;
			let e1 = e.name;
			let tmp1;
			if(args1.length == 0) {
				tmp1 = "";
			} else {
				let _g = [];
				let _g1 = 0;
				while(_g1 < args1.length) {
					let t = args1[_g1];
					++_g1;
					_g.push(hscript_Checker.typeStr(t));
				}
				tmp1 = "<" + _g.join(",") + ">";
			}
			return e1 + tmp1;
		case 11:
			let t2 = t.t;
			let args2 = t.args;
			if(t2.name == "hscript.TypeCheck") {
				return hscript_Checker.typeStr(args2[1]);
			} else {
				let t = t2.name;
				let tmp;
				if(args2.length == 0) {
					tmp = "";
				} else {
					let _g = [];
					let _g1 = 0;
					while(_g1 < args2.length) {
						let t = args2[_g1];
						++_g1;
						_g.push(hscript_Checker.typeStr(t));
					}
					tmp = "<" + _g.join(",") + ">";
				}
				return t + tmp;
			}
			break;
		case 12:
			let a = t.a;
			let args3 = t.args;
			let a1 = a.name;
			let tmp2;
			if(args3.length == 0) {
				tmp2 = "";
			} else {
				let _g = [];
				let _g1 = 0;
				while(_g1 < args3.length) {
					let t = args3[_g1];
					++_g1;
					_g.push(hscript_Checker.typeStr(t));
				}
				tmp2 = "<" + _g.join(",") + ">";
			}
			return a1 + tmp2;
		case 13:
			let args4 = t.args;
			let ret = t.ret;
			let _g = [];
			let _g1 = 0;
			while(_g1 < args4.length) {
				let a = args4[_g1];
				++_g1;
				_g.push((a.opt ? "?" : "") + (a.name == "" ? "" : a.name + ":") + hscript_Checker.typeStr(a.t));
			}
			return "(" + _g.join(", ") + ") -> " + hscript_Checker.typeStr(ret);
		case 14:
			let fields = t.fields;
			let _g2 = [];
			let _g3 = 0;
			while(_g3 < fields.length) {
				let f = fields[_g3];
				++_g3;
				_g2.push((f.opt ? "?" : "") + f.name + ":" + hscript_Checker.typeStr(f.t));
			}
			return "{" + _g2.join(", ") + "}";
		default:
			return HxOverrides.substr($hxEnums[t.__enum__].__constructs__[t._hx_index]._hx_name,1,null);
		}
	}
	static typeIter(t,callb) {
		switch(t._hx_index) {
		case 0:
			let r = t.r;
			if(r.r != null) {
				callb(r.r);
			}
			break;
		case 8:
			let t1 = t.t;
			callb(t1);
			break;
		case 9:
			let _g = t.c;
			let tl = t.args;
			let _g1 = 0;
			while(_g1 < tl.length) {
				let t = tl[_g1];
				++_g1;
				callb(t);
			}
			break;
		case 10:
			let _g2 = t.e;
			let tl1 = t.args;
			let _g3 = 0;
			while(_g3 < tl1.length) {
				let t = tl1[_g3];
				++_g3;
				callb(t);
			}
			break;
		case 11:
			let _g4 = t.t;
			let tl2 = t.args;
			let _g5 = 0;
			while(_g5 < tl2.length) {
				let t = tl2[_g5];
				++_g5;
				callb(t);
			}
			break;
		case 12:
			let _g6 = t.a;
			let tl3 = t.args;
			let _g7 = 0;
			while(_g7 < tl3.length) {
				let t = tl3[_g7];
				++_g7;
				callb(t);
			}
			break;
		case 13:
			let args = t.args;
			let ret = t.ret;
			let _g8 = 0;
			while(_g8 < args.length) {
				let t = args[_g8];
				++_g8;
				callb(t.t);
			}
			callb(ret);
			break;
		case 14:
			let fl = t.fields;
			let _g9 = 0;
			while(_g9 < fl.length) {
				let f = fl[_g9];
				++_g9;
				callb(f.t);
			}
			break;
		case 15:
			let f = t.f;
			callb(f());
			break;
		default:
		}
	}
}
$hxClasses["hscript.Checker"] = hscript_Checker;
hscript_Checker.__name__ = "hscript.Checker";
Object.assign(hscript_Checker.prototype, {
	__class__: hscript_Checker
});
var hscript_Const = $hxEnums["hscript.Const"] = { __ename__:"hscript.Const",__constructs__:null
	,CInt: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hscript.Const",toString:$estr}; },$_._hx_name="CInt",$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"hscript.Const",toString:$estr}; },$_._hx_name="CFloat",$_.__params__ = ["f"],$_)
	,CString: ($_=function(s) { return {_hx_index:2,s:s,__enum__:"hscript.Const",toString:$estr}; },$_._hx_name="CString",$_.__params__ = ["s"],$_)
};
hscript_Const.__constructs__ = [hscript_Const.CInt,hscript_Const.CFloat,hscript_Const.CString];
var hscript_ExprDef = $hxEnums["hscript.ExprDef"] = { __ename__:"hscript.ExprDef",__constructs__:null
	,EConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EConst",$_.__params__ = ["c"],$_)
	,EIdent: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EIdent",$_.__params__ = ["v"],$_)
	,EVar: ($_=function(n,t,e) { return {_hx_index:2,n:n,t:t,e:e,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EVar",$_.__params__ = ["n","t","e"],$_)
	,EParent: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EParent",$_.__params__ = ["e"],$_)
	,EBlock: ($_=function(e) { return {_hx_index:4,e:e,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EBlock",$_.__params__ = ["e"],$_)
	,EField: ($_=function(e,f) { return {_hx_index:5,e:e,f:f,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EField",$_.__params__ = ["e","f"],$_)
	,EBinop: ($_=function(op,e1,e2) { return {_hx_index:6,op:op,e1:e1,e2:e2,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EBinop",$_.__params__ = ["op","e1","e2"],$_)
	,EUnop: ($_=function(op,prefix,e) { return {_hx_index:7,op:op,prefix:prefix,e:e,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EUnop",$_.__params__ = ["op","prefix","e"],$_)
	,ECall: ($_=function(e,params) { return {_hx_index:8,e:e,params:params,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="ECall",$_.__params__ = ["e","params"],$_)
	,EIf: ($_=function(cond,e1,e2) { return {_hx_index:9,cond:cond,e1:e1,e2:e2,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EIf",$_.__params__ = ["cond","e1","e2"],$_)
	,EWhile: ($_=function(cond,e) { return {_hx_index:10,cond:cond,e:e,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EWhile",$_.__params__ = ["cond","e"],$_)
	,EFor: ($_=function(v,it,e) { return {_hx_index:11,v:v,it:it,e:e,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EFor",$_.__params__ = ["v","it","e"],$_)
	,EBreak: {_hx_name:"EBreak",_hx_index:12,__enum__:"hscript.ExprDef",toString:$estr}
	,EContinue: {_hx_name:"EContinue",_hx_index:13,__enum__:"hscript.ExprDef",toString:$estr}
	,EFunction: ($_=function(args,e,name,ret) { return {_hx_index:14,args:args,e:e,name:name,ret:ret,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EFunction",$_.__params__ = ["args","e","name","ret"],$_)
	,EReturn: ($_=function(e) { return {_hx_index:15,e:e,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EReturn",$_.__params__ = ["e"],$_)
	,EArray: ($_=function(e,index) { return {_hx_index:16,e:e,index:index,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EArray",$_.__params__ = ["e","index"],$_)
	,EArrayDecl: ($_=function(e) { return {_hx_index:17,e:e,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EArrayDecl",$_.__params__ = ["e"],$_)
	,ENew: ($_=function(cl,params) { return {_hx_index:18,cl:cl,params:params,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="ENew",$_.__params__ = ["cl","params"],$_)
	,EThrow: ($_=function(e) { return {_hx_index:19,e:e,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EThrow",$_.__params__ = ["e"],$_)
	,ETry: ($_=function(e,v,t,ecatch) { return {_hx_index:20,e:e,v:v,t:t,ecatch:ecatch,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="ETry",$_.__params__ = ["e","v","t","ecatch"],$_)
	,EObject: ($_=function(fl) { return {_hx_index:21,fl:fl,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EObject",$_.__params__ = ["fl"],$_)
	,ETernary: ($_=function(cond,e1,e2) { return {_hx_index:22,cond:cond,e1:e1,e2:e2,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="ETernary",$_.__params__ = ["cond","e1","e2"],$_)
	,ESwitch: ($_=function(e,cases,defaultExpr) { return {_hx_index:23,e:e,cases:cases,defaultExpr:defaultExpr,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="ESwitch",$_.__params__ = ["e","cases","defaultExpr"],$_)
	,EDoWhile: ($_=function(cond,e) { return {_hx_index:24,cond:cond,e:e,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EDoWhile",$_.__params__ = ["cond","e"],$_)
	,EMeta: ($_=function(name,args,e) { return {_hx_index:25,name:name,args:args,e:e,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="EMeta",$_.__params__ = ["name","args","e"],$_)
	,ECheckType: ($_=function(e,t) { return {_hx_index:26,e:e,t:t,__enum__:"hscript.ExprDef",toString:$estr}; },$_._hx_name="ECheckType",$_.__params__ = ["e","t"],$_)
};
hscript_ExprDef.__constructs__ = [hscript_ExprDef.EConst,hscript_ExprDef.EIdent,hscript_ExprDef.EVar,hscript_ExprDef.EParent,hscript_ExprDef.EBlock,hscript_ExprDef.EField,hscript_ExprDef.EBinop,hscript_ExprDef.EUnop,hscript_ExprDef.ECall,hscript_ExprDef.EIf,hscript_ExprDef.EWhile,hscript_ExprDef.EFor,hscript_ExprDef.EBreak,hscript_ExprDef.EContinue,hscript_ExprDef.EFunction,hscript_ExprDef.EReturn,hscript_ExprDef.EArray,hscript_ExprDef.EArrayDecl,hscript_ExprDef.ENew,hscript_ExprDef.EThrow,hscript_ExprDef.ETry,hscript_ExprDef.EObject,hscript_ExprDef.ETernary,hscript_ExprDef.ESwitch,hscript_ExprDef.EDoWhile,hscript_ExprDef.EMeta,hscript_ExprDef.ECheckType];
var hscript_CType = $hxEnums["hscript.CType"] = { __ename__:"hscript.CType",__constructs__:null
	,CTPath: ($_=function(path,params) { return {_hx_index:0,path:path,params:params,__enum__:"hscript.CType",toString:$estr}; },$_._hx_name="CTPath",$_.__params__ = ["path","params"],$_)
	,CTFun: ($_=function(args,ret) { return {_hx_index:1,args:args,ret:ret,__enum__:"hscript.CType",toString:$estr}; },$_._hx_name="CTFun",$_.__params__ = ["args","ret"],$_)
	,CTAnon: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"hscript.CType",toString:$estr}; },$_._hx_name="CTAnon",$_.__params__ = ["fields"],$_)
	,CTParent: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"hscript.CType",toString:$estr}; },$_._hx_name="CTParent",$_.__params__ = ["t"],$_)
	,CTOpt: ($_=function(t) { return {_hx_index:4,t:t,__enum__:"hscript.CType",toString:$estr}; },$_._hx_name="CTOpt",$_.__params__ = ["t"],$_)
	,CTNamed: ($_=function(n,t) { return {_hx_index:5,n:n,t:t,__enum__:"hscript.CType",toString:$estr}; },$_._hx_name="CTNamed",$_.__params__ = ["n","t"],$_)
};
hscript_CType.__constructs__ = [hscript_CType.CTPath,hscript_CType.CTFun,hscript_CType.CTAnon,hscript_CType.CTParent,hscript_CType.CTOpt,hscript_CType.CTNamed];
class hscript_Error {
	constructor(e,pmin,pmax,origin,line) {
		this.e = e;
		this.pmin = pmin;
		this.pmax = pmax;
		this.origin = origin;
		this.line = line;
	}
	toString() {
		return hscript_Printer.errorToString(this);
	}
}
$hxClasses["hscript.Error"] = hscript_Error;
hscript_Error.__name__ = "hscript.Error";
Object.assign(hscript_Error.prototype, {
	__class__: hscript_Error
});
var hscript_ErrorDef = $hxEnums["hscript.ErrorDef"] = { __ename__:"hscript.ErrorDef",__constructs__:null
	,EInvalidChar: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"hscript.ErrorDef",toString:$estr}; },$_._hx_name="EInvalidChar",$_.__params__ = ["c"],$_)
	,EUnexpected: ($_=function(s) { return {_hx_index:1,s:s,__enum__:"hscript.ErrorDef",toString:$estr}; },$_._hx_name="EUnexpected",$_.__params__ = ["s"],$_)
	,EUnterminatedString: {_hx_name:"EUnterminatedString",_hx_index:2,__enum__:"hscript.ErrorDef",toString:$estr}
	,EUnterminatedComment: {_hx_name:"EUnterminatedComment",_hx_index:3,__enum__:"hscript.ErrorDef",toString:$estr}
	,EInvalidPreprocessor: ($_=function(msg) { return {_hx_index:4,msg:msg,__enum__:"hscript.ErrorDef",toString:$estr}; },$_._hx_name="EInvalidPreprocessor",$_.__params__ = ["msg"],$_)
	,EUnknownVariable: ($_=function(v) { return {_hx_index:5,v:v,__enum__:"hscript.ErrorDef",toString:$estr}; },$_._hx_name="EUnknownVariable",$_.__params__ = ["v"],$_)
	,EInvalidIterator: ($_=function(v) { return {_hx_index:6,v:v,__enum__:"hscript.ErrorDef",toString:$estr}; },$_._hx_name="EInvalidIterator",$_.__params__ = ["v"],$_)
	,EInvalidOp: ($_=function(op) { return {_hx_index:7,op:op,__enum__:"hscript.ErrorDef",toString:$estr}; },$_._hx_name="EInvalidOp",$_.__params__ = ["op"],$_)
	,EInvalidAccess: ($_=function(f) { return {_hx_index:8,f:f,__enum__:"hscript.ErrorDef",toString:$estr}; },$_._hx_name="EInvalidAccess",$_.__params__ = ["f"],$_)
	,ECustom: ($_=function(msg) { return {_hx_index:9,msg:msg,__enum__:"hscript.ErrorDef",toString:$estr}; },$_._hx_name="ECustom",$_.__params__ = ["msg"],$_)
};
hscript_ErrorDef.__constructs__ = [hscript_ErrorDef.EInvalidChar,hscript_ErrorDef.EUnexpected,hscript_ErrorDef.EUnterminatedString,hscript_ErrorDef.EUnterminatedComment,hscript_ErrorDef.EInvalidPreprocessor,hscript_ErrorDef.EUnknownVariable,hscript_ErrorDef.EInvalidIterator,hscript_ErrorDef.EInvalidOp,hscript_ErrorDef.EInvalidAccess,hscript_ErrorDef.ECustom];
var hscript_ModuleDecl = $hxEnums["hscript.ModuleDecl"] = { __ename__:"hscript.ModuleDecl",__constructs__:null
	,DPackage: ($_=function(path) { return {_hx_index:0,path:path,__enum__:"hscript.ModuleDecl",toString:$estr}; },$_._hx_name="DPackage",$_.__params__ = ["path"],$_)
	,DImport: ($_=function(path,everything) { return {_hx_index:1,path:path,everything:everything,__enum__:"hscript.ModuleDecl",toString:$estr}; },$_._hx_name="DImport",$_.__params__ = ["path","everything"],$_)
	,DClass: ($_=function(c) { return {_hx_index:2,c:c,__enum__:"hscript.ModuleDecl",toString:$estr}; },$_._hx_name="DClass",$_.__params__ = ["c"],$_)
	,DTypedef: ($_=function(c) { return {_hx_index:3,c:c,__enum__:"hscript.ModuleDecl",toString:$estr}; },$_._hx_name="DTypedef",$_.__params__ = ["c"],$_)
};
hscript_ModuleDecl.__constructs__ = [hscript_ModuleDecl.DPackage,hscript_ModuleDecl.DImport,hscript_ModuleDecl.DClass,hscript_ModuleDecl.DTypedef];
var hscript_FieldAccess = $hxEnums["hscript.FieldAccess"] = { __ename__:"hscript.FieldAccess",__constructs__:null
	,APublic: {_hx_name:"APublic",_hx_index:0,__enum__:"hscript.FieldAccess",toString:$estr}
	,APrivate: {_hx_name:"APrivate",_hx_index:1,__enum__:"hscript.FieldAccess",toString:$estr}
	,AInline: {_hx_name:"AInline",_hx_index:2,__enum__:"hscript.FieldAccess",toString:$estr}
	,AOverride: {_hx_name:"AOverride",_hx_index:3,__enum__:"hscript.FieldAccess",toString:$estr}
	,AStatic: {_hx_name:"AStatic",_hx_index:4,__enum__:"hscript.FieldAccess",toString:$estr}
	,AMacro: {_hx_name:"AMacro",_hx_index:5,__enum__:"hscript.FieldAccess",toString:$estr}
};
hscript_FieldAccess.__constructs__ = [hscript_FieldAccess.APublic,hscript_FieldAccess.APrivate,hscript_FieldAccess.AInline,hscript_FieldAccess.AOverride,hscript_FieldAccess.AStatic,hscript_FieldAccess.AMacro];
var hscript_FieldKind = $hxEnums["hscript.FieldKind"] = { __ename__:"hscript.FieldKind",__constructs__:null
	,KFunction: ($_=function(f) { return {_hx_index:0,f:f,__enum__:"hscript.FieldKind",toString:$estr}; },$_._hx_name="KFunction",$_.__params__ = ["f"],$_)
	,KVar: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hscript.FieldKind",toString:$estr}; },$_._hx_name="KVar",$_.__params__ = ["v"],$_)
};
hscript_FieldKind.__constructs__ = [hscript_FieldKind.KFunction,hscript_FieldKind.KVar];
var hscript_Token = $hxEnums["hscript.Token"] = { __ename__:"hscript.Token",__constructs__:null
	,TEof: {_hx_name:"TEof",_hx_index:0,__enum__:"hscript.Token",toString:$estr}
	,TConst: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"hscript.Token",toString:$estr}; },$_._hx_name="TConst",$_.__params__ = ["c"],$_)
	,TId: ($_=function(s) { return {_hx_index:2,s:s,__enum__:"hscript.Token",toString:$estr}; },$_._hx_name="TId",$_.__params__ = ["s"],$_)
	,TOp: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"hscript.Token",toString:$estr}; },$_._hx_name="TOp",$_.__params__ = ["s"],$_)
	,TPOpen: {_hx_name:"TPOpen",_hx_index:4,__enum__:"hscript.Token",toString:$estr}
	,TPClose: {_hx_name:"TPClose",_hx_index:5,__enum__:"hscript.Token",toString:$estr}
	,TBrOpen: {_hx_name:"TBrOpen",_hx_index:6,__enum__:"hscript.Token",toString:$estr}
	,TBrClose: {_hx_name:"TBrClose",_hx_index:7,__enum__:"hscript.Token",toString:$estr}
	,TDot: {_hx_name:"TDot",_hx_index:8,__enum__:"hscript.Token",toString:$estr}
	,TQuestionDot: {_hx_name:"TQuestionDot",_hx_index:9,__enum__:"hscript.Token",toString:$estr}
	,TComma: {_hx_name:"TComma",_hx_index:10,__enum__:"hscript.Token",toString:$estr}
	,TSemicolon: {_hx_name:"TSemicolon",_hx_index:11,__enum__:"hscript.Token",toString:$estr}
	,TBkOpen: {_hx_name:"TBkOpen",_hx_index:12,__enum__:"hscript.Token",toString:$estr}
	,TBkClose: {_hx_name:"TBkClose",_hx_index:13,__enum__:"hscript.Token",toString:$estr}
	,TQuestion: {_hx_name:"TQuestion",_hx_index:14,__enum__:"hscript.Token",toString:$estr}
	,TDoubleDot: {_hx_name:"TDoubleDot",_hx_index:15,__enum__:"hscript.Token",toString:$estr}
	,TMeta: ($_=function(s) { return {_hx_index:16,s:s,__enum__:"hscript.Token",toString:$estr}; },$_._hx_name="TMeta",$_.__params__ = ["s"],$_)
	,TPrepro: ($_=function(s) { return {_hx_index:17,s:s,__enum__:"hscript.Token",toString:$estr}; },$_._hx_name="TPrepro",$_.__params__ = ["s"],$_)
};
hscript_Token.__constructs__ = [hscript_Token.TEof,hscript_Token.TConst,hscript_Token.TId,hscript_Token.TOp,hscript_Token.TPOpen,hscript_Token.TPClose,hscript_Token.TBrOpen,hscript_Token.TBrClose,hscript_Token.TDot,hscript_Token.TQuestionDot,hscript_Token.TComma,hscript_Token.TSemicolon,hscript_Token.TBkOpen,hscript_Token.TBkClose,hscript_Token.TQuestion,hscript_Token.TDoubleDot,hscript_Token.TMeta,hscript_Token.TPrepro];
class hscript_Parser {
	constructor() {
		this.uid = 0;
		this.preprocesorValues = new haxe_ds_StringMap();
		this.line = 1;
		this.opChars = "+*/-=!><&|^%~";
		this.identChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_";
		let priorities = [["%"],["*","/"],["+","-"],["<<",">>",">>>"],["|","&","^"],["==","!=",">","<",">=","<="],["..."],["&&"],["||"],["=","+=","-=","*=","/=","%=","<<=",">>=",">>>=","|=","&=","^=","=>"],["->"]];
		this.opPriority = new haxe_ds_StringMap();
		this.opRightAssoc = new haxe_ds_StringMap();
		let _g = 0;
		let _g1 = priorities.length;
		while(_g < _g1) {
			let i = _g++;
			let _g1 = 0;
			let _g2 = priorities[i];
			while(_g1 < _g2.length) {
				let x = _g2[_g1];
				++_g1;
				this.opPriority.h[x] = i;
				if(i == 9) {
					this.opRightAssoc.h[x] = true;
				}
			}
		}
		let x = "!";
		this.opPriority.h[x] = x == "++" || x == "--" ? -1 : -2;
		let x1 = "++";
		this.opPriority.h[x1] = x1 == "++" || x1 == "--" ? -1 : -2;
		let x2 = "--";
		this.opPriority.h[x2] = x2 == "++" || x2 == "--" ? -1 : -2;
		let x3 = "~";
		this.opPriority.h[x3] = x3 == "++" || x3 == "--" ? -1 : -2;
	}
	get_currentPos() {
		return this.readPos + this.offset;
	}
	error(err,pmin,pmax) {
		if(!this.resumeErrors) {
			throw haxe_Exception.thrown(new hscript_Error(err,pmin,pmax,this.origin,this.line));
		}
	}
	invalidChar(c) {
		if(!this.resumeErrors) {
			throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.EInvalidChar(c),this.readPos - 1,this.readPos - 1,this.origin,this.line));
		}
	}
	initParser(origin,pos) {
		this.preprocStack = [];
		this.origin = origin;
		this.readPos = 0;
		this.tokenMin = this.oldTokenMin = pos;
		this.tokenMax = this.oldTokenMax = pos;
		this.tokens = new haxe_ds_List();
		this.offset = pos;
		this.char = -1;
		this.ops = [];
		this.idents = [];
		this.uid = 0;
		let _g = 0;
		let _g1 = this.opChars.length;
		while(_g < _g1) {
			let i = _g++;
			this.ops[HxOverrides.cca(this.opChars,i)] = true;
		}
		let _g2 = 0;
		let _g3 = this.identChars.length;
		while(_g2 < _g3) {
			let i = _g2++;
			this.idents[HxOverrides.cca(this.identChars,i)] = true;
		}
	}
	parseString(s,origin,position) {
		if(position == null) {
			position = 0;
		}
		if(origin == null) {
			origin = "hscript";
		}
		this.initParser(origin,position);
		this.input = s;
		this.readPos = 0;
		let a = [];
		while(true) {
			let tk = this.token();
			if(tk == hscript_Token.TEof) {
				break;
			}
			this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			this.parseFullExpr(a);
		}
		if(a.length == 1) {
			return a[0];
		} else {
			let e = hscript_ExprDef.EBlock(a);
			let pmin = 0;
			let pmax = null;
			if(e == null) {
				return null;
			} else {
				if(pmin == null) {
					pmin = this.tokenMin;
				}
				if(pmax == null) {
					pmax = this.tokenMax;
				}
				return { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
			}
		}
	}
	unexpected(tk) {
		let err = hscript_ErrorDef.EUnexpected(this.tokenString(tk));
		if(!this.resumeErrors) {
			throw haxe_Exception.thrown(new hscript_Error(err,this.tokenMin,this.tokenMax,this.origin,this.line));
		}
		return null;
	}
	push(tk) {
		this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
		this.tokenMin = this.oldTokenMin;
		this.tokenMax = this.oldTokenMax;
	}
	ensure(tk) {
		let t = this.token();
		if(t != tk) {
			this.unexpected(t);
		}
	}
	ensureToken(tk) {
		let t = this.token();
		if(!Type.enumEq(t,tk)) {
			this.unexpected(t);
		}
	}
	maybe(tk) {
		let t = this.token();
		if(Type.enumEq(t,tk)) {
			return true;
		}
		this.tokens.push({ t : t, min : this.tokenMin, max : this.tokenMax});
		this.tokenMin = this.oldTokenMin;
		this.tokenMax = this.oldTokenMax;
		return false;
	}
	getIdent() {
		let tk = this.token();
		if(tk._hx_index == 2) {
			let id = tk.s;
			return id;
		} else {
			this.unexpected(tk);
			return null;
		}
	}
	expr(e) {
		return e.e;
	}
	pmin(e) {
		if(e == null) {
			return 0;
		} else {
			return e.pmin;
		}
	}
	pmax(e) {
		if(e == null) {
			return 0;
		} else {
			return e.pmax;
		}
	}
	mk(e,pmin,pmax) {
		if(e == null) {
			return null;
		}
		if(pmin == null) {
			pmin = this.tokenMin;
		}
		if(pmax == null) {
			pmax = this.tokenMax;
		}
		return { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
	}
	isBlock(e) {
		if(e == null) {
			return false;
		}
		let _g = e.e;
		switch(_g._hx_index) {
		case 2:
			let _g1 = _g.n;
			let t = _g.t;
			let e1 = _g.e;
			if(e1 != null) {
				return this.isBlock(e1);
			} else if(t != null) {
				if(t == null) {
					return false;
				} else if(t._hx_index == 2) {
					let _g = t.fields;
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 4:
			let _g2 = _g.e;
			return true;
		case 6:
			let _g3 = _g.op;
			let _g4 = _g.e1;
			let e2 = _g.e2;
			return this.isBlock(e2);
		case 7:
			let _g5 = _g.op;
			let prefix = _g.prefix;
			let e3 = _g.e;
			if(!prefix) {
				return this.isBlock(e3);
			} else {
				return false;
			}
			break;
		case 9:
			let _g6 = _g.cond;
			let e11 = _g.e1;
			let e21 = _g.e2;
			if(e21 != null) {
				return this.isBlock(e21);
			} else {
				return this.isBlock(e11);
			}
			break;
		case 10:
			let _g7 = _g.cond;
			let e4 = _g.e;
			return this.isBlock(e4);
		case 11:
			let _g8 = _g.v;
			let _g9 = _g.it;
			let e5 = _g.e;
			return this.isBlock(e5);
		case 14:
			let _g10 = _g.args;
			let _g11 = _g.name;
			let _g12 = _g.ret;
			let e6 = _g.e;
			return this.isBlock(e6);
		case 15:
			let e7 = _g.e;
			if(e7 != null) {
				return this.isBlock(e7);
			} else {
				return false;
			}
			break;
		case 20:
			let _g13 = _g.e;
			let _g14 = _g.v;
			let _g15 = _g.t;
			let e8 = _g.ecatch;
			return this.isBlock(e8);
		case 21:
			let _g16 = _g.fl;
			return true;
		case 23:
			let _g17 = _g.e;
			let _g18 = _g.cases;
			let _g19 = _g.defaultExpr;
			return true;
		case 24:
			let _g20 = _g.cond;
			let e9 = _g.e;
			return this.isBlock(e9);
		case 25:
			let _g21 = _g.name;
			let _g22 = _g.args;
			let e10 = _g.e;
			return this.isBlock(e10);
		default:
			return false;
		}
	}
	parseFullExpr(exprs) {
		let e = this.parseExpr();
		exprs.push(e);
		let tk = this.token();
		while(true) {
			let tmp;
			if(tk == hscript_Token.TComma && e != null) {
				let _g = e.e;
				if(_g._hx_index == 2) {
					let _g1 = _g.n;
					let _g2 = _g.t;
					let _g3 = _g.e;
					tmp = true;
				} else {
					tmp = false;
				}
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			e = this.parseStructure("var");
			exprs.push(e);
			tk = this.token();
		}
		if(tk != hscript_Token.TSemicolon && tk != hscript_Token.TEof) {
			if(this.isBlock(e)) {
				this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
			} else {
				this.unexpected(tk);
			}
		}
	}
	parseObject(p1) {
		let fl = [];
		_hx_loop1: while(true) {
			let tk = this.token();
			let id = null;
			switch(tk._hx_index) {
			case 1:
				let c = tk.c;
				if(!this.allowJSON) {
					this.unexpected(tk);
				}
				if(c._hx_index == 2) {
					let s = c.s;
					id = s;
				} else {
					this.unexpected(tk);
				}
				break;
			case 2:
				let i = tk.s;
				id = i;
				break;
			case 7:
				break _hx_loop1;
			default:
				this.unexpected(tk);
				break _hx_loop1;
			}
			let t = this.token();
			if(t != hscript_Token.TDoubleDot) {
				this.unexpected(t);
			}
			fl.push({ name : id, e : this.parseExpr()});
			tk = this.token();
			switch(tk._hx_index) {
			case 7:
				break _hx_loop1;
			case 10:
				break;
			default:
				this.unexpected(tk);
			}
		}
		let e = hscript_ExprDef.EObject(fl);
		let pmin = p1;
		let pmax = null;
		let tmp;
		if(e == null) {
			tmp = null;
		} else {
			if(pmin == null) {
				pmin = this.tokenMin;
			}
			if(pmax == null) {
				pmax = this.tokenMax;
			}
			tmp = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
		}
		return this.parseExprNext(tmp);
	}
	parseExpr() {
		let tk = this.token();
		let p1 = this.tokenMin;
		switch(tk._hx_index) {
		case 1:
			let c = tk.c;
			let e = hscript_ExprDef.EConst(c);
			let pmin = null;
			let pmax = null;
			let tmp;
			if(e == null) {
				tmp = null;
			} else {
				if(pmin == null) {
					pmin = this.tokenMin;
				}
				if(pmax == null) {
					pmax = this.tokenMax;
				}
				tmp = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
			}
			return this.parseExprNext(tmp);
		case 2:
			let id = tk.s;
			let e1 = this.parseStructure(id);
			if(e1 == null) {
				let e = hscript_ExprDef.EIdent(id);
				let pmin = null;
				let pmax = null;
				if(e == null) {
					e1 = null;
				} else {
					if(pmin == null) {
						pmin = this.tokenMin;
					}
					if(pmax == null) {
						pmax = this.tokenMax;
					}
					e1 = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
				}
			}
			return this.parseExprNext(e1);
		case 3:
			let op = tk.s;
			if(op == "-") {
				let start = this.tokenMin;
				let e = this.parseExpr();
				if(e == null) {
					return this.makeUnop(op,e);
				}
				let _g = e.e;
				if(_g._hx_index == 0) {
					let _g1 = _g.c;
					switch(_g1._hx_index) {
					case 0:
						let i = _g1.v;
						let e1 = hscript_ExprDef.EConst(hscript_Const.CInt(-i));
						let pmin = start;
						let pmax = e == null ? 0 : e.pmax;
						if(e1 == null) {
							return null;
						} else {
							if(pmin == null) {
								pmin = this.tokenMin;
							}
							if(pmax == null) {
								pmax = this.tokenMax;
							}
							return { e : e1, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
						}
						break;
					case 1:
						let f = _g1.f;
						let e2 = hscript_ExprDef.EConst(hscript_Const.CFloat(-f));
						let pmin1 = start;
						let pmax1 = e == null ? 0 : e.pmax;
						if(e2 == null) {
							return null;
						} else {
							if(pmin1 == null) {
								pmin1 = this.tokenMin;
							}
							if(pmax1 == null) {
								pmax1 = this.tokenMax;
							}
							return { e : e2, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
						}
						break;
					default:
						return this.makeUnop(op,e);
					}
				} else {
					return this.makeUnop(op,e);
				}
			}
			if(this.opPriority.h[op] < 0) {
				return this.makeUnop(op,this.parseExpr());
			}
			return this.unexpected(tk);
		case 4:
			tk = this.token();
			if(tk == hscript_Token.TPClose) {
				let t = this.token();
				if(!Type.enumEq(t,hscript_Token.TOp("->"))) {
					this.unexpected(t);
				}
				let eret = this.parseExpr();
				let e = hscript_ExprDef.EReturn(eret);
				let pmin = p1;
				let pmax = null;
				let e1;
				if(e == null) {
					e1 = null;
				} else {
					if(pmin == null) {
						pmin = this.tokenMin;
					}
					if(pmax == null) {
						pmax = this.tokenMax;
					}
					e1 = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
				}
				let e2 = hscript_ExprDef.EFunction([],e1);
				let pmin1 = p1;
				let pmax1 = null;
				if(e2 == null) {
					return null;
				} else {
					if(pmin1 == null) {
						pmin1 = this.tokenMin;
					}
					if(pmax1 == null) {
						pmax1 = this.tokenMax;
					}
					return { e : e2, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
				}
			}
			this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			let e2 = this.parseExpr();
			tk = this.token();
			switch(tk._hx_index) {
			case 5:
				let e3 = hscript_ExprDef.EParent(e2);
				let pmin1 = p1;
				let pmax1 = this.tokenMax;
				let tmp1;
				if(e3 == null) {
					tmp1 = null;
				} else {
					if(pmin1 == null) {
						pmin1 = this.tokenMin;
					}
					if(pmax1 == null) {
						pmax1 = this.tokenMax;
					}
					tmp1 = { e : e3, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
				}
				return this.parseExprNext(tmp1);
			case 10:
				let _g = e2.e;
				if(_g._hx_index == 1) {
					let v = _g.v;
					return this.parseLambda([{ name : v}],e2 == null ? 0 : e2.pmin);
				}
				break;
			case 15:
				let t = this.parseType();
				tk = this.token();
				switch(tk._hx_index) {
				case 5:
					let e4 = hscript_ExprDef.ECheckType(e2,t);
					let pmin2 = p1;
					let pmax2 = this.tokenMax;
					let tmp2;
					if(e4 == null) {
						tmp2 = null;
					} else {
						if(pmin2 == null) {
							pmin2 = this.tokenMin;
						}
						if(pmax2 == null) {
							pmax2 = this.tokenMax;
						}
						tmp2 = { e : e4, pmin : pmin2, pmax : pmax2, origin : this.origin, line : this.line};
					}
					return this.parseExprNext(tmp2);
				case 10:
					let _g1 = e2.e;
					if(_g1._hx_index == 1) {
						let v = _g1.v;
						return this.parseLambda([{ name : v, t : t}],e2 == null ? 0 : e2.pmin);
					}
					break;
				default:
				}
				break;
			default:
			}
			return this.unexpected(tk);
		case 6:
			tk = this.token();
			switch(tk._hx_index) {
			case 1:
				let c1 = tk.c;
				if(this.allowJSON) {
					if(c1._hx_index == 2) {
						let _g = c1.s;
						let tk2 = this.token();
						this.tokens.push({ t : tk2, min : this.tokenMin, max : this.tokenMax});
						this.tokenMin = this.oldTokenMin;
						this.tokenMax = this.oldTokenMax;
						this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
						this.tokenMin = this.oldTokenMin;
						this.tokenMax = this.oldTokenMax;
						if(tk2._hx_index == 15) {
							return this.parseExprNext(this.parseObject(p1));
						}
					} else {
						this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
						this.tokenMin = this.oldTokenMin;
						this.tokenMax = this.oldTokenMax;
					}
				} else {
					this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
					this.tokenMin = this.oldTokenMin;
					this.tokenMax = this.oldTokenMax;
				}
				break;
			case 2:
				let _g2 = tk.s;
				let tk2 = this.token();
				this.tokens.push({ t : tk2, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
				this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
				if(tk2._hx_index == 15) {
					return this.parseExprNext(this.parseObject(p1));
				}
				break;
			case 7:
				let e5 = hscript_ExprDef.EObject([]);
				let pmin3 = p1;
				let pmax3 = null;
				let tmp3;
				if(e5 == null) {
					tmp3 = null;
				} else {
					if(pmin3 == null) {
						pmin3 = this.tokenMin;
					}
					if(pmax3 == null) {
						pmax3 = this.tokenMax;
					}
					tmp3 = { e : e5, pmin : pmin3, pmax : pmax3, origin : this.origin, line : this.line};
				}
				return this.parseExprNext(tmp3);
			default:
				this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
			}
			let a = [];
			while(true) {
				this.parseFullExpr(a);
				tk = this.token();
				if(tk == hscript_Token.TBrClose || this.resumeErrors && tk == hscript_Token.TEof) {
					break;
				}
				this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
			}
			let e6 = hscript_ExprDef.EBlock(a);
			let pmin4 = p1;
			let pmax4 = null;
			if(e6 == null) {
				return null;
			} else {
				if(pmin4 == null) {
					pmin4 = this.tokenMin;
				}
				if(pmax4 == null) {
					pmax4 = this.tokenMax;
				}
				return { e : e6, pmin : pmin4, pmax : pmax4, origin : this.origin, line : this.line};
			}
			break;
		case 12:
			let a1 = [];
			tk = this.token();
			let first = true;
			while(tk != hscript_Token.TBkClose && (!this.resumeErrors || tk != hscript_Token.TEof)) {
				if(!first) {
					if(tk != hscript_Token.TComma) {
						this.unexpected(tk);
					} else {
						tk = this.token();
					}
				}
				first = false;
				this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
				a1.push(this.parseExpr());
				tk = this.token();
			}
			if(a1.length == 1 && a1[0] != null) {
				let _g = a1[0].e;
				switch(_g._hx_index) {
				case 10:
					let _g1 = _g.cond;
					let _g2 = _g.e;
					let tmp = "__a_" + this.uid++;
					let e = hscript_ExprDef.EArrayDecl([]);
					let pmin = p1;
					let pmax = null;
					let e1;
					if(e == null) {
						e1 = null;
					} else {
						if(pmin == null) {
							pmin = this.tokenMin;
						}
						if(pmax == null) {
							pmax = this.tokenMax;
						}
						e1 = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
					}
					let e2 = hscript_ExprDef.EVar(tmp,null,e1);
					let pmin1 = p1;
					let pmax1 = null;
					let e3;
					if(e2 == null) {
						e3 = null;
					} else {
						if(pmin1 == null) {
							pmin1 = this.tokenMin;
						}
						if(pmax1 == null) {
							pmax1 = this.tokenMax;
						}
						e3 = { e : e2, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
					}
					let e4 = this.mapCompr(tmp,a1[0]);
					let e5 = hscript_ExprDef.EIdent(tmp);
					let pmin2 = p1;
					let pmax2 = null;
					let e6;
					if(e5 == null) {
						e6 = null;
					} else {
						if(pmin2 == null) {
							pmin2 = this.tokenMin;
						}
						if(pmax2 == null) {
							pmax2 = this.tokenMax;
						}
						e6 = { e : e5, pmin : pmin2, pmax : pmax2, origin : this.origin, line : this.line};
					}
					let e7 = hscript_ExprDef.EBlock([e3,e4,e6]);
					let pmin3 = p1;
					let pmax3 = null;
					let e8;
					if(e7 == null) {
						e8 = null;
					} else {
						if(pmin3 == null) {
							pmin3 = this.tokenMin;
						}
						if(pmax3 == null) {
							pmax3 = this.tokenMax;
						}
						e8 = { e : e7, pmin : pmin3, pmax : pmax3, origin : this.origin, line : this.line};
					}
					return this.parseExprNext(e8);
				case 11:
					let _g3 = _g.v;
					let _g4 = _g.it;
					let _g5 = _g.e;
					let tmp1 = "__a_" + this.uid++;
					let e9 = hscript_ExprDef.EArrayDecl([]);
					let pmin4 = p1;
					let pmax4 = null;
					let e10;
					if(e9 == null) {
						e10 = null;
					} else {
						if(pmin4 == null) {
							pmin4 = this.tokenMin;
						}
						if(pmax4 == null) {
							pmax4 = this.tokenMax;
						}
						e10 = { e : e9, pmin : pmin4, pmax : pmax4, origin : this.origin, line : this.line};
					}
					let e11 = hscript_ExprDef.EVar(tmp1,null,e10);
					let pmin5 = p1;
					let pmax5 = null;
					let e12;
					if(e11 == null) {
						e12 = null;
					} else {
						if(pmin5 == null) {
							pmin5 = this.tokenMin;
						}
						if(pmax5 == null) {
							pmax5 = this.tokenMax;
						}
						e12 = { e : e11, pmin : pmin5, pmax : pmax5, origin : this.origin, line : this.line};
					}
					let e13 = this.mapCompr(tmp1,a1[0]);
					let e14 = hscript_ExprDef.EIdent(tmp1);
					let pmin6 = p1;
					let pmax6 = null;
					let e15;
					if(e14 == null) {
						e15 = null;
					} else {
						if(pmin6 == null) {
							pmin6 = this.tokenMin;
						}
						if(pmax6 == null) {
							pmax6 = this.tokenMax;
						}
						e15 = { e : e14, pmin : pmin6, pmax : pmax6, origin : this.origin, line : this.line};
					}
					let e16 = hscript_ExprDef.EBlock([e12,e13,e15]);
					let pmin7 = p1;
					let pmax7 = null;
					let e17;
					if(e16 == null) {
						e17 = null;
					} else {
						if(pmin7 == null) {
							pmin7 = this.tokenMin;
						}
						if(pmax7 == null) {
							pmax7 = this.tokenMax;
						}
						e17 = { e : e16, pmin : pmin7, pmax : pmax7, origin : this.origin, line : this.line};
					}
					return this.parseExprNext(e17);
				case 24:
					let _g6 = _g.cond;
					let _g7 = _g.e;
					let tmp2 = "__a_" + this.uid++;
					let e18 = hscript_ExprDef.EArrayDecl([]);
					let pmin8 = p1;
					let pmax8 = null;
					let e19;
					if(e18 == null) {
						e19 = null;
					} else {
						if(pmin8 == null) {
							pmin8 = this.tokenMin;
						}
						if(pmax8 == null) {
							pmax8 = this.tokenMax;
						}
						e19 = { e : e18, pmin : pmin8, pmax : pmax8, origin : this.origin, line : this.line};
					}
					let e20 = hscript_ExprDef.EVar(tmp2,null,e19);
					let pmin9 = p1;
					let pmax9 = null;
					let e21;
					if(e20 == null) {
						e21 = null;
					} else {
						if(pmin9 == null) {
							pmin9 = this.tokenMin;
						}
						if(pmax9 == null) {
							pmax9 = this.tokenMax;
						}
						e21 = { e : e20, pmin : pmin9, pmax : pmax9, origin : this.origin, line : this.line};
					}
					let e22 = this.mapCompr(tmp2,a1[0]);
					let e23 = hscript_ExprDef.EIdent(tmp2);
					let pmin10 = p1;
					let pmax10 = null;
					let e24;
					if(e23 == null) {
						e24 = null;
					} else {
						if(pmin10 == null) {
							pmin10 = this.tokenMin;
						}
						if(pmax10 == null) {
							pmax10 = this.tokenMax;
						}
						e24 = { e : e23, pmin : pmin10, pmax : pmax10, origin : this.origin, line : this.line};
					}
					let e25 = hscript_ExprDef.EBlock([e21,e22,e24]);
					let pmin11 = p1;
					let pmax11 = null;
					let e26;
					if(e25 == null) {
						e26 = null;
					} else {
						if(pmin11 == null) {
							pmin11 = this.tokenMin;
						}
						if(pmax11 == null) {
							pmax11 = this.tokenMax;
						}
						e26 = { e : e25, pmin : pmin11, pmax : pmax11, origin : this.origin, line : this.line};
					}
					return this.parseExprNext(e26);
				default:
				}
			}
			let e7 = hscript_ExprDef.EArrayDecl(a1);
			let pmin5 = p1;
			let pmax5 = null;
			let tmp4;
			if(e7 == null) {
				tmp4 = null;
			} else {
				if(pmin5 == null) {
					pmin5 = this.tokenMin;
				}
				if(pmax5 == null) {
					pmax5 = this.tokenMax;
				}
				tmp4 = { e : e7, pmin : pmin5, pmax : pmax5, origin : this.origin, line : this.line};
			}
			return this.parseExprNext(tmp4);
		case 16:
			let id1 = tk.s;
			if(this.allowMetadata) {
				let args = this.parseMetaArgs();
				let e = hscript_ExprDef.EMeta(id1,args,this.parseExpr());
				let pmin = p1;
				let pmax = null;
				if(e == null) {
					return null;
				} else {
					if(pmin == null) {
						pmin = this.tokenMin;
					}
					if(pmax == null) {
						pmax = this.tokenMax;
					}
					return { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
				}
			} else {
				return this.unexpected(tk);
			}
			break;
		default:
			return this.unexpected(tk);
		}
	}
	parseLambda(args,pmin) {
		_hx_loop1: while(true) {
			let id = this.getIdent();
			let t = this.maybe(hscript_Token.TDoubleDot) ? this.parseType() : null;
			args.push({ name : id, t : t});
			let tk = this.token();
			switch(tk._hx_index) {
			case 5:
				break _hx_loop1;
			case 10:
				break;
			default:
				this.unexpected(tk);
				break _hx_loop1;
			}
		}
		let t = this.token();
		if(!Type.enumEq(t,hscript_Token.TOp("->"))) {
			this.unexpected(t);
		}
		let eret = this.parseExpr();
		let e = hscript_ExprDef.EReturn(eret);
		let pmin1 = pmin;
		let pmax = null;
		let e1;
		if(e == null) {
			e1 = null;
		} else {
			if(pmin1 == null) {
				pmin1 = this.tokenMin;
			}
			if(pmax == null) {
				pmax = this.tokenMax;
			}
			e1 = { e : e, pmin : pmin1, pmax : pmax, origin : this.origin, line : this.line};
		}
		let e2 = hscript_ExprDef.EFunction(args,e1);
		let pmin2 = pmin;
		let pmax1 = null;
		if(e2 == null) {
			return null;
		} else {
			if(pmin2 == null) {
				pmin2 = this.tokenMin;
			}
			if(pmax1 == null) {
				pmax1 = this.tokenMax;
			}
			return { e : e2, pmin : pmin2, pmax : pmax1, origin : this.origin, line : this.line};
		}
	}
	parseMetaArgs() {
		let tk = this.token();
		if(tk != hscript_Token.TPOpen) {
			this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			return null;
		}
		let args = [];
		tk = this.token();
		if(tk != hscript_Token.TPClose) {
			this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			_hx_loop1: while(true) {
				args.push(this.parseExpr());
				let _g = this.token();
				switch(_g._hx_index) {
				case 5:
					break _hx_loop1;
				case 10:
					break;
				default:
					let tk = _g;
					this.unexpected(tk);
				}
			}
		}
		return args;
	}
	mapCompr(tmp,e) {
		if(e == null) {
			return null;
		}
		let edef;
		let _g = e.e;
		switch(_g._hx_index) {
		case 3:
			let e2 = _g.e;
			edef = hscript_ExprDef.EParent(this.mapCompr(tmp,e2));
			break;
		case 4:
			let _g1 = _g.e;
			if(_g1.length == 1) {
				let e = _g1[0];
				edef = hscript_ExprDef.EBlock([this.mapCompr(tmp,e)]);
			} else {
				let e1 = hscript_ExprDef.EIdent(tmp);
				let pmin = e == null ? 0 : e.pmin;
				let pmax = e == null ? 0 : e.pmax;
				let e2;
				if(e1 == null) {
					e2 = null;
				} else {
					if(pmin == null) {
						pmin = this.tokenMin;
					}
					if(pmax == null) {
						pmax = this.tokenMax;
					}
					e2 = { e : e1, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
				}
				let e3 = hscript_ExprDef.EField(e2,"push");
				let pmin1 = e == null ? 0 : e.pmin;
				let pmax1 = e == null ? 0 : e.pmax;
				let edef1;
				if(e3 == null) {
					edef1 = null;
				} else {
					if(pmin1 == null) {
						pmin1 = this.tokenMin;
					}
					if(pmax1 == null) {
						pmax1 = this.tokenMax;
					}
					edef1 = { e : e3, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
				}
				edef = hscript_ExprDef.ECall(edef1,[e]);
			}
			break;
		case 9:
			let cond = _g.cond;
			let e1 = _g.e1;
			let e21 = _g.e2;
			if(e21 == null) {
				edef = hscript_ExprDef.EIf(cond,this.mapCompr(tmp,e1),null);
			} else {
				let e1 = hscript_ExprDef.EIdent(tmp);
				let pmin = e == null ? 0 : e.pmin;
				let pmax = e == null ? 0 : e.pmax;
				let e2;
				if(e1 == null) {
					e2 = null;
				} else {
					if(pmin == null) {
						pmin = this.tokenMin;
					}
					if(pmax == null) {
						pmax = this.tokenMax;
					}
					e2 = { e : e1, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
				}
				let e3 = hscript_ExprDef.EField(e2,"push");
				let pmin1 = e == null ? 0 : e.pmin;
				let pmax1 = e == null ? 0 : e.pmax;
				let edef1;
				if(e3 == null) {
					edef1 = null;
				} else {
					if(pmin1 == null) {
						pmin1 = this.tokenMin;
					}
					if(pmax1 == null) {
						pmax1 = this.tokenMax;
					}
					edef1 = { e : e3, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
				}
				edef = hscript_ExprDef.ECall(edef1,[e]);
			}
			break;
		case 10:
			let cond1 = _g.cond;
			let e22 = _g.e;
			edef = hscript_ExprDef.EWhile(cond1,this.mapCompr(tmp,e22));
			break;
		case 11:
			let v = _g.v;
			let it = _g.it;
			let e23 = _g.e;
			edef = hscript_ExprDef.EFor(v,it,this.mapCompr(tmp,e23));
			break;
		case 24:
			let cond2 = _g.cond;
			let e24 = _g.e;
			edef = hscript_ExprDef.EDoWhile(cond2,this.mapCompr(tmp,e24));
			break;
		default:
			let e3 = hscript_ExprDef.EIdent(tmp);
			let pmin = e == null ? 0 : e.pmin;
			let pmax = e == null ? 0 : e.pmax;
			let e4;
			if(e3 == null) {
				e4 = null;
			} else {
				if(pmin == null) {
					pmin = this.tokenMin;
				}
				if(pmax == null) {
					pmax = this.tokenMax;
				}
				e4 = { e : e3, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
			}
			let e5 = hscript_ExprDef.EField(e4,"push");
			let pmin1 = e == null ? 0 : e.pmin;
			let pmax1 = e == null ? 0 : e.pmax;
			let edef1;
			if(e5 == null) {
				edef1 = null;
			} else {
				if(pmin1 == null) {
					pmin1 = this.tokenMin;
				}
				if(pmax1 == null) {
					pmax1 = this.tokenMax;
				}
				edef1 = { e : e5, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
			}
			edef = hscript_ExprDef.ECall(edef1,[e]);
		}
		let pmin2 = e == null ? 0 : e.pmin;
		let pmax2 = e == null ? 0 : e.pmax;
		if(edef == null) {
			return null;
		} else {
			if(pmin2 == null) {
				pmin2 = this.tokenMin;
			}
			if(pmax2 == null) {
				pmax2 = this.tokenMax;
			}
			return { e : edef, pmin : pmin2, pmax : pmax2, origin : this.origin, line : this.line};
		}
	}
	makeUnop(op,e) {
		if(e == null && this.resumeErrors) {
			return null;
		}
		let _g = e.e;
		switch(_g._hx_index) {
		case 6:
			let bop = _g.op;
			let e1 = _g.e1;
			let e2 = _g.e2;
			let e3 = hscript_ExprDef.EBinop(bop,this.makeUnop(op,e1),e2);
			let pmin = e1 == null ? 0 : e1.pmin;
			let pmax = e2 == null ? 0 : e2.pmax;
			if(e3 == null) {
				return null;
			} else {
				if(pmin == null) {
					pmin = this.tokenMin;
				}
				if(pmax == null) {
					pmax = this.tokenMax;
				}
				return { e : e3, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
			}
			break;
		case 22:
			let e11 = _g.cond;
			let e21 = _g.e1;
			let e31 = _g.e2;
			let e4 = hscript_ExprDef.ETernary(this.makeUnop(op,e11),e21,e31);
			let pmin1 = e11 == null ? 0 : e11.pmin;
			let pmax1 = e31 == null ? 0 : e31.pmax;
			if(e4 == null) {
				return null;
			} else {
				if(pmin1 == null) {
					pmin1 = this.tokenMin;
				}
				if(pmax1 == null) {
					pmax1 = this.tokenMax;
				}
				return { e : e4, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
			}
			break;
		default:
			let e5 = hscript_ExprDef.EUnop(op,true,e);
			let pmin2 = e == null ? 0 : e.pmin;
			let pmax2 = e == null ? 0 : e.pmax;
			if(e5 == null) {
				return null;
			} else {
				if(pmin2 == null) {
					pmin2 = this.tokenMin;
				}
				if(pmax2 == null) {
					pmax2 = this.tokenMax;
				}
				return { e : e5, pmin : pmin2, pmax : pmax2, origin : this.origin, line : this.line};
			}
		}
	}
	makeBinop(op,e1,e) {
		if(e == null && this.resumeErrors) {
			let e2 = hscript_ExprDef.EBinop(op,e1,e);
			let pmin = e1 == null ? 0 : e1.pmin;
			let pmax = e1 == null ? 0 : e1.pmax;
			if(e2 == null) {
				return null;
			} else {
				if(pmin == null) {
					pmin = this.tokenMin;
				}
				if(pmax == null) {
					pmax = this.tokenMax;
				}
				return { e : e2, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
			}
		}
		let _g = e.e;
		switch(_g._hx_index) {
		case 6:
			let op2 = _g.op;
			let e2 = _g.e1;
			let e3 = _g.e2;
			if(this.opPriority.h[op] <= this.opPriority.h[op2] && !Object.prototype.hasOwnProperty.call(this.opRightAssoc.h,op)) {
				let e = hscript_ExprDef.EBinop(op2,this.makeBinop(op,e1,e2),e3);
				let pmin = e1 == null ? 0 : e1.pmin;
				let pmax = e3 == null ? 0 : e3.pmax;
				if(e == null) {
					return null;
				} else {
					if(pmin == null) {
						pmin = this.tokenMin;
					}
					if(pmax == null) {
						pmax = this.tokenMax;
					}
					return { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
				}
			} else {
				let e2 = hscript_ExprDef.EBinop(op,e1,e);
				let pmin = e1 == null ? 0 : e1.pmin;
				let pmax = e == null ? 0 : e.pmax;
				if(e2 == null) {
					return null;
				} else {
					if(pmin == null) {
						pmin = this.tokenMin;
					}
					if(pmax == null) {
						pmax = this.tokenMax;
					}
					return { e : e2, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
				}
			}
			break;
		case 22:
			let e21 = _g.cond;
			let e31 = _g.e1;
			let e4 = _g.e2;
			if(Object.prototype.hasOwnProperty.call(this.opRightAssoc.h,op)) {
				let e2 = hscript_ExprDef.EBinop(op,e1,e);
				let pmin = e1 == null ? 0 : e1.pmin;
				let pmax = e == null ? 0 : e.pmax;
				if(e2 == null) {
					return null;
				} else {
					if(pmin == null) {
						pmin = this.tokenMin;
					}
					if(pmax == null) {
						pmax = this.tokenMax;
					}
					return { e : e2, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
				}
			} else {
				let e2 = hscript_ExprDef.ETernary(this.makeBinop(op,e1,e21),e31,e4);
				let pmin = e1 == null ? 0 : e1.pmin;
				let pmax = e == null ? 0 : e.pmax;
				if(e2 == null) {
					return null;
				} else {
					if(pmin == null) {
						pmin = this.tokenMin;
					}
					if(pmax == null) {
						pmax = this.tokenMax;
					}
					return { e : e2, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
				}
			}
			break;
		default:
			let e5 = hscript_ExprDef.EBinop(op,e1,e);
			let pmin = e1 == null ? 0 : e1.pmin;
			let pmax = e == null ? 0 : e.pmax;
			if(e5 == null) {
				return null;
			} else {
				if(pmin == null) {
					pmin = this.tokenMin;
				}
				if(pmax == null) {
					pmax = this.tokenMax;
				}
				return { e : e5, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
			}
		}
	}
	parseStructure(id) {
		let p1 = this.tokenMin;
		switch(id) {
		case "break":
			let e = hscript_ExprDef.EBreak;
			let pmin = null;
			let pmax = null;
			if(e == null) {
				return null;
			} else {
				if(pmin == null) {
					pmin = this.tokenMin;
				}
				if(pmax == null) {
					pmax = this.tokenMax;
				}
				return { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
			}
			break;
		case "continue":
			let e1 = hscript_ExprDef.EContinue;
			let pmin1 = null;
			let pmax1 = null;
			if(e1 == null) {
				return null;
			} else {
				if(pmin1 == null) {
					pmin1 = this.tokenMin;
				}
				if(pmax1 == null) {
					pmax1 = this.tokenMax;
				}
				return { e : e1, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
			}
			break;
		case "do":
			let e2 = this.parseExpr();
			let tk = this.token();
			if(tk._hx_index == 2) {
				if(tk.s != "while") {
					this.unexpected(tk);
				}
			} else {
				this.unexpected(tk);
			}
			let econd = this.parseExpr();
			let e3 = hscript_ExprDef.EDoWhile(econd,e2);
			let pmin2 = p1;
			let pmax2 = econd == null ? 0 : econd.pmax;
			if(e3 == null) {
				return null;
			} else {
				if(pmin2 == null) {
					pmin2 = this.tokenMin;
				}
				if(pmax2 == null) {
					pmax2 = this.tokenMax;
				}
				return { e : e3, pmin : pmin2, pmax : pmax2, origin : this.origin, line : this.line};
			}
			break;
		case "else":
			return this.unexpected(hscript_Token.TId(id));
		case "for":
			let t = this.token();
			if(t != hscript_Token.TPOpen) {
				this.unexpected(t);
			}
			let vname = this.getIdent();
			let t1 = this.token();
			if(!Type.enumEq(t1,hscript_Token.TId("in"))) {
				this.unexpected(t1);
			}
			let eiter = this.parseExpr();
			let t2 = this.token();
			if(t2 != hscript_Token.TPClose) {
				this.unexpected(t2);
			}
			let e4 = this.parseExpr();
			let e5 = hscript_ExprDef.EFor(vname,eiter,e4);
			let pmin3 = p1;
			let pmax3 = e4 == null ? 0 : e4.pmax;
			if(e5 == null) {
				return null;
			} else {
				if(pmin3 == null) {
					pmin3 = this.tokenMin;
				}
				if(pmax3 == null) {
					pmax3 = this.tokenMax;
				}
				return { e : e5, pmin : pmin3, pmax : pmax3, origin : this.origin, line : this.line};
			}
			break;
		case "function":
			let tk1 = this.token();
			let name = null;
			if(tk1._hx_index == 2) {
				let id = tk1.s;
				name = id;
			} else {
				this.tokens.push({ t : tk1, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
			}
			let inf = this.parseFunctionDecl();
			let e6 = hscript_ExprDef.EFunction(inf.args,inf.body,name,inf.ret);
			let pmin4 = p1;
			let e7 = inf.body;
			let pmax4 = e7 == null ? 0 : e7.pmax;
			if(e6 == null) {
				return null;
			} else {
				if(pmin4 == null) {
					pmin4 = this.tokenMin;
				}
				if(pmax4 == null) {
					pmax4 = this.tokenMax;
				}
				return { e : e6, pmin : pmin4, pmax : pmax4, origin : this.origin, line : this.line};
			}
			break;
		case "if":
			let t3 = this.token();
			if(t3 != hscript_Token.TPOpen) {
				this.unexpected(t3);
			}
			let cond = this.parseExpr();
			let t4 = this.token();
			if(t4 != hscript_Token.TPClose) {
				this.unexpected(t4);
			}
			let e11 = this.parseExpr();
			let e21 = null;
			let semic = false;
			let tk2 = this.token();
			if(tk2 == hscript_Token.TSemicolon) {
				semic = true;
				tk2 = this.token();
			}
			if(Type.enumEq(tk2,hscript_Token.TId("else"))) {
				e21 = this.parseExpr();
			} else {
				this.tokens.push({ t : tk2, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
				if(semic) {
					this.tokens.push({ t : hscript_Token.TSemicolon, min : this.tokenMin, max : this.tokenMax});
					this.tokenMin = this.oldTokenMin;
					this.tokenMax = this.oldTokenMax;
				}
			}
			let e8 = hscript_ExprDef.EIf(cond,e11,e21);
			let pmin5 = p1;
			let pmax5 = e21 == null ? this.tokenMax : e21 == null ? 0 : e21.pmax;
			if(e8 == null) {
				return null;
			} else {
				if(pmin5 == null) {
					pmin5 = this.tokenMin;
				}
				if(pmax5 == null) {
					pmax5 = this.tokenMax;
				}
				return { e : e8, pmin : pmin5, pmax : pmax5, origin : this.origin, line : this.line};
			}
			break;
		case "inline":
			if(!this.maybe(hscript_Token.TId("function"))) {
				this.unexpected(hscript_Token.TId("inline"));
			}
			return this.parseStructure("function");
		case "new":
			let a = [];
			a.push(this.getIdent());
			_hx_loop1: while(true) {
				let tk = this.token();
				switch(tk._hx_index) {
				case 4:
					break _hx_loop1;
				case 8:
					a.push(this.getIdent());
					break;
				default:
					this.unexpected(tk);
					break _hx_loop1;
				}
			}
			let args = this.parseExprList(hscript_Token.TPClose);
			let e9 = hscript_ExprDef.ENew(a.join("."),args);
			let pmin6 = p1;
			let pmax6 = null;
			if(e9 == null) {
				return null;
			} else {
				if(pmin6 == null) {
					pmin6 = this.tokenMin;
				}
				if(pmax6 == null) {
					pmax6 = this.tokenMax;
				}
				return { e : e9, pmin : pmin6, pmax : pmax6, origin : this.origin, line : this.line};
			}
			break;
		case "return":
			let tk3 = this.token();
			this.tokens.push({ t : tk3, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			let e10 = tk3 == hscript_Token.TSemicolon ? null : this.parseExpr();
			let e12 = hscript_ExprDef.EReturn(e10);
			let pmin7 = p1;
			let pmax7 = e10 == null ? this.tokenMax : e10 == null ? 0 : e10.pmax;
			if(e12 == null) {
				return null;
			} else {
				if(pmin7 == null) {
					pmin7 = this.tokenMin;
				}
				if(pmax7 == null) {
					pmax7 = this.tokenMax;
				}
				return { e : e12, pmin : pmin7, pmax : pmax7, origin : this.origin, line : this.line};
			}
			break;
		case "switch":
			let e13 = this.parseExpr();
			let def = null;
			let cases = [];
			let t5 = this.token();
			if(t5 != hscript_Token.TBrOpen) {
				this.unexpected(t5);
			}
			_hx_loop2: while(true) {
				let tk = this.token();
				switch(tk._hx_index) {
				case 2:
					switch(tk.s) {
					case "case":
						let c = { values : [], expr : null};
						cases.push(c);
						_hx_loop3: while(true) {
							let e = this.parseExpr();
							c.values.push(e);
							tk = this.token();
							switch(tk._hx_index) {
							case 10:
								break;
							case 15:
								break _hx_loop3;
							default:
								this.unexpected(tk);
								break _hx_loop3;
							}
						}
						let exprs = [];
						_hx_loop4: while(true) {
							tk = this.token();
							this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
							this.tokenMin = this.oldTokenMin;
							this.tokenMax = this.oldTokenMax;
							switch(tk._hx_index) {
							case 0:
								if(this.resumeErrors) {
									break _hx_loop4;
								} else {
									this.parseFullExpr(exprs);
								}
								break;
							case 2:
								switch(tk.s) {
								case "case":case "default":
									break _hx_loop4;
								default:
									this.parseFullExpr(exprs);
								}
								break;
							case 7:
								break _hx_loop4;
							default:
								this.parseFullExpr(exprs);
							}
						}
						let tmp;
						if(exprs.length == 1) {
							tmp = exprs[0];
						} else if(exprs.length == 0) {
							let e = hscript_ExprDef.EBlock([]);
							let pmin = this.tokenMin;
							let pmax = this.tokenMin;
							if(e == null) {
								tmp = null;
							} else {
								if(pmin == null) {
									pmin = this.tokenMin;
								}
								if(pmax == null) {
									pmax = this.tokenMax;
								}
								tmp = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
							}
						} else {
							let e = hscript_ExprDef.EBlock(exprs);
							let e1 = exprs[0];
							let pmin = e1 == null ? 0 : e1.pmin;
							let e2 = exprs[exprs.length - 1];
							let pmax = e2 == null ? 0 : e2.pmax;
							if(e == null) {
								tmp = null;
							} else {
								if(pmin == null) {
									pmin = this.tokenMin;
								}
								if(pmax == null) {
									pmax = this.tokenMax;
								}
								tmp = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
							}
						}
						c.expr = tmp;
						break;
					case "default":
						if(def != null) {
							this.unexpected(tk);
						}
						let t = this.token();
						if(t != hscript_Token.TDoubleDot) {
							this.unexpected(t);
						}
						let exprs1 = [];
						_hx_loop5: while(true) {
							tk = this.token();
							this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
							this.tokenMin = this.oldTokenMin;
							this.tokenMax = this.oldTokenMax;
							switch(tk._hx_index) {
							case 0:
								if(this.resumeErrors) {
									break _hx_loop5;
								} else {
									this.parseFullExpr(exprs1);
								}
								break;
							case 2:
								switch(tk.s) {
								case "case":case "default":
									break _hx_loop5;
								default:
									this.parseFullExpr(exprs1);
								}
								break;
							case 7:
								break _hx_loop5;
							default:
								this.parseFullExpr(exprs1);
							}
						}
						if(exprs1.length == 1) {
							def = exprs1[0];
						} else if(exprs1.length == 0) {
							let e = hscript_ExprDef.EBlock([]);
							let pmin = this.tokenMin;
							let pmax = this.tokenMin;
							if(e == null) {
								def = null;
							} else {
								if(pmin == null) {
									pmin = this.tokenMin;
								}
								if(pmax == null) {
									pmax = this.tokenMax;
								}
								def = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
							}
						} else {
							let e = hscript_ExprDef.EBlock(exprs1);
							let e1 = exprs1[0];
							let pmin = e1 == null ? 0 : e1.pmin;
							let e2 = exprs1[exprs1.length - 1];
							let pmax = e2 == null ? 0 : e2.pmax;
							if(e == null) {
								def = null;
							} else {
								if(pmin == null) {
									pmin = this.tokenMin;
								}
								if(pmax == null) {
									pmax = this.tokenMax;
								}
								def = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
							}
						}
						break;
					default:
						this.unexpected(tk);
						break _hx_loop2;
					}
					break;
				case 7:
					break _hx_loop2;
				default:
					this.unexpected(tk);
					break _hx_loop2;
				}
			}
			let e14 = hscript_ExprDef.ESwitch(e13,cases,def);
			let pmin8 = p1;
			let pmax8 = this.tokenMax;
			if(e14 == null) {
				return null;
			} else {
				if(pmin8 == null) {
					pmin8 = this.tokenMin;
				}
				if(pmax8 == null) {
					pmax8 = this.tokenMax;
				}
				return { e : e14, pmin : pmin8, pmax : pmax8, origin : this.origin, line : this.line};
			}
			break;
		case "throw":
			let e15 = this.parseExpr();
			let e16 = hscript_ExprDef.EThrow(e15);
			let pmin9 = p1;
			let pmax9 = e15 == null ? 0 : e15.pmax;
			if(e16 == null) {
				return null;
			} else {
				if(pmin9 == null) {
					pmin9 = this.tokenMin;
				}
				if(pmax9 == null) {
					pmax9 = this.tokenMax;
				}
				return { e : e16, pmin : pmin9, pmax : pmax9, origin : this.origin, line : this.line};
			}
			break;
		case "try":
			let e17 = this.parseExpr();
			let t6 = this.token();
			if(!Type.enumEq(t6,hscript_Token.TId("catch"))) {
				this.unexpected(t6);
			}
			let t7 = this.token();
			if(t7 != hscript_Token.TPOpen) {
				this.unexpected(t7);
			}
			let vname1 = this.getIdent();
			let t8 = this.token();
			if(t8 != hscript_Token.TDoubleDot) {
				this.unexpected(t8);
			}
			let t9 = null;
			if(this.allowTypes) {
				t9 = this.parseType();
			} else {
				let t = this.token();
				if(!Type.enumEq(t,hscript_Token.TId("Dynamic"))) {
					this.unexpected(t);
				}
			}
			let t10 = this.token();
			if(t10 != hscript_Token.TPClose) {
				this.unexpected(t10);
			}
			let ec = this.parseExpr();
			let e18 = hscript_ExprDef.ETry(e17,vname1,t9,ec);
			let pmin10 = p1;
			let pmax10 = ec == null ? 0 : ec.pmax;
			if(e18 == null) {
				return null;
			} else {
				if(pmin10 == null) {
					pmin10 = this.tokenMin;
				}
				if(pmax10 == null) {
					pmax10 = this.tokenMax;
				}
				return { e : e18, pmin : pmin10, pmax : pmax10, origin : this.origin, line : this.line};
			}
			break;
		case "var":
			let ident = this.getIdent();
			let tk4 = this.token();
			let t11 = null;
			if(tk4 == hscript_Token.TDoubleDot && this.allowTypes) {
				t11 = this.parseType();
				tk4 = this.token();
			}
			let e19 = null;
			switch(tk4._hx_index) {
			case 3:
				if(tk4.s == "=") {
					e19 = this.parseExpr();
				} else {
					this.unexpected(tk4);
				}
				break;
			case 10:case 11:
				this.tokens.push({ t : tk4, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
				break;
			default:
				if(t11 != null) {
					this.tokens.push({ t : tk4, min : this.tokenMin, max : this.tokenMax});
					this.tokenMin = this.oldTokenMin;
					this.tokenMax = this.oldTokenMax;
				} else {
					this.unexpected(tk4);
				}
			}
			let e20 = hscript_ExprDef.EVar(ident,t11,e19);
			let pmin11 = p1;
			let pmax11 = e19 == null ? this.tokenMax : e19 == null ? 0 : e19.pmax;
			if(e20 == null) {
				return null;
			} else {
				if(pmin11 == null) {
					pmin11 = this.tokenMin;
				}
				if(pmax11 == null) {
					pmax11 = this.tokenMax;
				}
				return { e : e20, pmin : pmin11, pmax : pmax11, origin : this.origin, line : this.line};
			}
			break;
		case "while":
			let econd1 = this.parseExpr();
			let e22 = this.parseExpr();
			let e23 = hscript_ExprDef.EWhile(econd1,e22);
			let pmin12 = p1;
			let pmax12 = e22 == null ? 0 : e22.pmax;
			if(e23 == null) {
				return null;
			} else {
				if(pmin12 == null) {
					pmin12 = this.tokenMin;
				}
				if(pmax12 == null) {
					pmax12 = this.tokenMax;
				}
				return { e : e23, pmin : pmin12, pmax : pmax12, origin : this.origin, line : this.line};
			}
			break;
		default:
			return null;
		}
	}
	parseExprNext(e1) {
		let tk = this.token();
		switch(tk._hx_index) {
		case 2:
			let op = tk.s;
			if(op == "is") {
				return this.makeBinop(op,e1,this.parseExpr());
			} else {
				this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
				return e1;
			}
			break;
		case 3:
			let op1 = tk.s;
			if(op1 == "->") {
				let _g = e1.e;
				switch(_g._hx_index) {
				case 1:
					let i = _g.v;
					let eret = this.parseExpr();
					let e = hscript_ExprDef.EReturn(eret);
					let pmin = eret == null ? 0 : eret.pmin;
					let pmax = null;
					let e2;
					if(e == null) {
						e2 = null;
					} else {
						if(pmin == null) {
							pmin = this.tokenMin;
						}
						if(pmax == null) {
							pmax = this.tokenMax;
						}
						e2 = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
					}
					let e3 = hscript_ExprDef.EFunction([{ name : i}],e2);
					let pmin1 = e1 == null ? 0 : e1.pmin;
					let pmax1 = null;
					if(e3 == null) {
						return null;
					} else {
						if(pmin1 == null) {
							pmin1 = this.tokenMin;
						}
						if(pmax1 == null) {
							pmax1 = this.tokenMax;
						}
						return { e : e3, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
					}
					break;
				case 3:
					let _hx_tmp = _g.e.e;
					if(_hx_tmp._hx_index == 1) {
						let i = _hx_tmp.v;
						let eret = this.parseExpr();
						let e = hscript_ExprDef.EReturn(eret);
						let pmin = eret == null ? 0 : eret.pmin;
						let pmax = null;
						let e2;
						if(e == null) {
							e2 = null;
						} else {
							if(pmin == null) {
								pmin = this.tokenMin;
							}
							if(pmax == null) {
								pmax = this.tokenMax;
							}
							e2 = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
						}
						let e3 = hscript_ExprDef.EFunction([{ name : i}],e2);
						let pmin1 = e1 == null ? 0 : e1.pmin;
						let pmax1 = null;
						if(e3 == null) {
							return null;
						} else {
							if(pmin1 == null) {
								pmin1 = this.tokenMin;
							}
							if(pmax1 == null) {
								pmax1 = this.tokenMax;
							}
							return { e : e3, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
						}
					}
					break;
				case 26:
					let _hx_tmp1 = _g.e.e;
					if(_hx_tmp1._hx_index == 1) {
						let i = _hx_tmp1.v;
						let t = _g.t;
						let eret = this.parseExpr();
						let e = hscript_ExprDef.EReturn(eret);
						let pmin = eret == null ? 0 : eret.pmin;
						let pmax = null;
						let e2;
						if(e == null) {
							e2 = null;
						} else {
							if(pmin == null) {
								pmin = this.tokenMin;
							}
							if(pmax == null) {
								pmax = this.tokenMax;
							}
							e2 = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
						}
						let e3 = hscript_ExprDef.EFunction([{ name : i, t : t}],e2);
						let pmin1 = e1 == null ? 0 : e1.pmin;
						let pmax1 = null;
						if(e3 == null) {
							return null;
						} else {
							if(pmin1 == null) {
								pmin1 = this.tokenMin;
							}
							if(pmax1 == null) {
								pmax1 = this.tokenMax;
							}
							return { e : e3, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
						}
					}
					break;
				default:
				}
				this.unexpected(tk);
			}
			if(this.opPriority.h[op1] == -1) {
				let tmp;
				if(!this.isBlock(e1)) {
					let _g = e1.e;
					if(_g._hx_index == 3) {
						let _g1 = _g.e;
						tmp = true;
					} else {
						tmp = false;
					}
				} else {
					tmp = true;
				}
				if(tmp) {
					this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
					this.tokenMin = this.oldTokenMin;
					this.tokenMax = this.oldTokenMax;
					return e1;
				}
				let e = hscript_ExprDef.EUnop(op1,false,e1);
				let pmin = e1 == null ? 0 : e1.pmin;
				let pmax = null;
				let tmp1;
				if(e == null) {
					tmp1 = null;
				} else {
					if(pmin == null) {
						pmin = this.tokenMin;
					}
					if(pmax == null) {
						pmax = this.tokenMax;
					}
					tmp1 = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
				}
				return this.parseExprNext(tmp1);
			}
			return this.makeBinop(op1,e1,this.parseExpr());
		case 4:
			let e = hscript_ExprDef.ECall(e1,this.parseExprList(hscript_Token.TPClose));
			let pmin = e1 == null ? 0 : e1.pmin;
			let pmax = null;
			let tmp;
			if(e == null) {
				tmp = null;
			} else {
				if(pmin == null) {
					pmin = this.tokenMin;
				}
				if(pmax == null) {
					pmax = this.tokenMax;
				}
				tmp = { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
			}
			return this.parseExprNext(tmp);
		case 8:
			let field = this.getIdent();
			let e2 = hscript_ExprDef.EField(e1,field);
			let pmin1 = e1 == null ? 0 : e1.pmin;
			let pmax1 = null;
			let tmp1;
			if(e2 == null) {
				tmp1 = null;
			} else {
				if(pmin1 == null) {
					pmin1 = this.tokenMin;
				}
				if(pmax1 == null) {
					pmax1 = this.tokenMax;
				}
				tmp1 = { e : e2, pmin : pmin1, pmax : pmax1, origin : this.origin, line : this.line};
			}
			return this.parseExprNext(tmp1);
		case 9:
			let field1 = this.getIdent();
			let tmp2 = "__a_" + this.uid++;
			let e3 = hscript_ExprDef.EVar(tmp2,null,e1);
			let pmin2 = e1 == null ? 0 : e1.pmin;
			let pmax2 = e1 == null ? 0 : e1.pmax;
			let e4;
			if(e3 == null) {
				e4 = null;
			} else {
				if(pmin2 == null) {
					pmin2 = this.tokenMin;
				}
				if(pmax2 == null) {
					pmax2 = this.tokenMax;
				}
				e4 = { e : e3, pmin : pmin2, pmax : pmax2, origin : this.origin, line : this.line};
			}
			let e5 = hscript_ExprDef.EIdent(tmp2);
			let pmin3 = e1 == null ? 0 : e1.pmin;
			let pmax3 = e1 == null ? 0 : e1.pmax;
			let e6;
			if(e5 == null) {
				e6 = null;
			} else {
				if(pmin3 == null) {
					pmin3 = this.tokenMin;
				}
				if(pmax3 == null) {
					pmax3 = this.tokenMax;
				}
				e6 = { e : e5, pmin : pmin3, pmax : pmax3, origin : this.origin, line : this.line};
			}
			let e7 = hscript_ExprDef.EIdent("null");
			let pmin4 = e1 == null ? 0 : e1.pmin;
			let pmax4 = e1 == null ? 0 : e1.pmax;
			let e8;
			if(e7 == null) {
				e8 = null;
			} else {
				if(pmin4 == null) {
					pmin4 = this.tokenMin;
				}
				if(pmax4 == null) {
					pmax4 = this.tokenMax;
				}
				e8 = { e : e7, pmin : pmin4, pmax : pmax4, origin : this.origin, line : this.line};
			}
			let e9 = hscript_ExprDef.EBinop("==",e6,e8);
			let pmin5 = null;
			let pmax5 = null;
			let e10;
			if(e9 == null) {
				e10 = null;
			} else {
				if(pmin5 == null) {
					pmin5 = this.tokenMin;
				}
				if(pmax5 == null) {
					pmax5 = this.tokenMax;
				}
				e10 = { e : e9, pmin : pmin5, pmax : pmax5, origin : this.origin, line : this.line};
			}
			let e11 = hscript_ExprDef.EIdent("null");
			let pmin6 = e1 == null ? 0 : e1.pmin;
			let pmax6 = e1 == null ? 0 : e1.pmax;
			let e12;
			if(e11 == null) {
				e12 = null;
			} else {
				if(pmin6 == null) {
					pmin6 = this.tokenMin;
				}
				if(pmax6 == null) {
					pmax6 = this.tokenMax;
				}
				e12 = { e : e11, pmin : pmin6, pmax : pmax6, origin : this.origin, line : this.line};
			}
			let e13 = hscript_ExprDef.EIdent(tmp2);
			let pmin7 = e1 == null ? 0 : e1.pmin;
			let pmax7 = e1 == null ? 0 : e1.pmax;
			let e14;
			if(e13 == null) {
				e14 = null;
			} else {
				if(pmin7 == null) {
					pmin7 = this.tokenMin;
				}
				if(pmax7 == null) {
					pmax7 = this.tokenMax;
				}
				e14 = { e : e13, pmin : pmin7, pmax : pmax7, origin : this.origin, line : this.line};
			}
			let e15 = hscript_ExprDef.EField(e14,field1);
			let pmin8 = e1 == null ? 0 : e1.pmin;
			let pmax8 = null;
			let e16;
			if(e15 == null) {
				e16 = null;
			} else {
				if(pmin8 == null) {
					pmin8 = this.tokenMin;
				}
				if(pmax8 == null) {
					pmax8 = this.tokenMax;
				}
				e16 = { e : e15, pmin : pmin8, pmax : pmax8, origin : this.origin, line : this.line};
			}
			let e17 = hscript_ExprDef.ETernary(e10,e12,e16);
			let pmin9 = null;
			let pmax9 = null;
			let e18;
			if(e17 == null) {
				e18 = null;
			} else {
				if(pmin9 == null) {
					pmin9 = this.tokenMin;
				}
				if(pmax9 == null) {
					pmax9 = this.tokenMax;
				}
				e18 = { e : e17, pmin : pmin9, pmax : pmax9, origin : this.origin, line : this.line};
			}
			let e19 = hscript_ExprDef.EBlock([e4,e18]);
			let pmin10 = e1 == null ? 0 : e1.pmin;
			let pmax10 = null;
			let e20;
			if(e19 == null) {
				e20 = null;
			} else {
				if(pmin10 == null) {
					pmin10 = this.tokenMin;
				}
				if(pmax10 == null) {
					pmax10 = this.tokenMax;
				}
				e20 = { e : e19, pmin : pmin10, pmax : pmax10, origin : this.origin, line : this.line};
			}
			return this.parseExprNext(e20);
		case 12:
			let e21 = this.parseExpr();
			let t = this.token();
			if(t != hscript_Token.TBkClose) {
				this.unexpected(t);
			}
			let e22 = hscript_ExprDef.EArray(e1,e21);
			let pmin11 = e1 == null ? 0 : e1.pmin;
			let pmax11 = null;
			let tmp3;
			if(e22 == null) {
				tmp3 = null;
			} else {
				if(pmin11 == null) {
					pmin11 = this.tokenMin;
				}
				if(pmax11 == null) {
					pmax11 = this.tokenMax;
				}
				tmp3 = { e : e22, pmin : pmin11, pmax : pmax11, origin : this.origin, line : this.line};
			}
			return this.parseExprNext(tmp3);
		case 14:
			let e23 = this.parseExpr();
			let t1 = this.token();
			if(t1 != hscript_Token.TDoubleDot) {
				this.unexpected(t1);
			}
			let e31 = this.parseExpr();
			let e24 = hscript_ExprDef.ETernary(e1,e23,e31);
			let pmin12 = e1 == null ? 0 : e1.pmin;
			let pmax12 = e31 == null ? 0 : e31.pmax;
			if(e24 == null) {
				return null;
			} else {
				if(pmin12 == null) {
					pmin12 = this.tokenMin;
				}
				if(pmax12 == null) {
					pmax12 = this.tokenMax;
				}
				return { e : e24, pmin : pmin12, pmax : pmax12, origin : this.origin, line : this.line};
			}
			break;
		default:
			this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			return e1;
		}
	}
	parseFunctionArgs() {
		let args = [];
		let tk = this.token();
		if(tk != hscript_Token.TPClose) {
			let done = false;
			while(!done) {
				let name = null;
				let opt = false;
				if(tk._hx_index == 14) {
					opt = true;
					tk = this.token();
				}
				if(tk._hx_index == 2) {
					let id = tk.s;
					name = id;
				} else {
					this.unexpected(tk);
					break;
				}
				let arg = { name : name};
				args.push(arg);
				if(opt) {
					arg.opt = true;
				}
				if(this.allowTypes) {
					if(this.maybe(hscript_Token.TDoubleDot)) {
						arg.t = this.parseType();
					}
					if(this.maybe(hscript_Token.TOp("="))) {
						arg.value = this.parseExpr();
					}
				}
				tk = this.token();
				switch(tk._hx_index) {
				case 5:
					done = true;
					break;
				case 10:
					tk = this.token();
					break;
				default:
					this.unexpected(tk);
				}
			}
		}
		return args;
	}
	parseFunctionDecl() {
		let t = this.token();
		if(t != hscript_Token.TPOpen) {
			this.unexpected(t);
		}
		let args = this.parseFunctionArgs();
		let ret = null;
		if(this.allowTypes) {
			let tk = this.token();
			if(tk != hscript_Token.TDoubleDot) {
				this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
			} else {
				ret = this.parseType();
			}
		}
		return { args : args, ret : ret, body : this.parseExpr()};
	}
	parsePath() {
		let path = [this.getIdent()];
		while(true) {
			let t = this.token();
			if(t != hscript_Token.TDot) {
				this.tokens.push({ t : t, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
				break;
			}
			path.push(this.getIdent());
		}
		return path;
	}
	parseType() {
		let t = this.token();
		let _gthis = this;
		switch(t._hx_index) {
		case 2:
			let v = t.s;
			this.tokens.push({ t : t, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			let path = this.parsePath();
			let params = null;
			t = this.token();
			if(t._hx_index == 3) {
				let op = t.s;
				if(op == "<") {
					params = [];
					_hx_loop1: while(true) {
						params.push(this.parseType());
						t = this.token();
						switch(t._hx_index) {
						case 3:
							let op = t.s;
							if(op == ">") {
								break _hx_loop1;
							}
							if(HxOverrides.cca(op,0) == 62) {
								this.tokens.add({ t : hscript_Token.TOp(HxOverrides.substr(op,1,null)), min : this.tokenMax - op.length - 1, max : this.tokenMax});
								break _hx_loop1;
							}
							break;
						case 10:
							continue;
						default:
						}
						this.unexpected(t);
						break;
					}
				} else {
					this.tokens.push({ t : t, min : this.tokenMin, max : this.tokenMax});
					this.tokenMin = this.oldTokenMin;
					this.tokenMax = this.oldTokenMax;
				}
			} else {
				this.tokens.push({ t : t, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
			}
			return this.parseTypeNext(hscript_CType.CTPath(path,params));
		case 4:
			let a = this.token();
			let b = this.token();
			this.tokens.push({ t : b, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			this.tokens.push({ t : a, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			let withReturn = function(args) {
				let _g = _gthis.token();
				if(_g._hx_index == 3) {
					if(_g.s != "->") {
						let t = _g;
						_gthis.unexpected(t);
					}
				} else {
					let t = _g;
					_gthis.unexpected(t);
				}
				return hscript_CType.CTFun(args,_gthis.parseType());
			};
			switch(a._hx_index) {
			case 2:
				let _g = a.s;
				if(b._hx_index == 15) {
					let _g = [];
					let _g1 = 0;
					let _g2 = this.parseFunctionArgs();
					while(_g1 < _g2.length) {
						let arg = _g2[_g1];
						++_g1;
						let _g3 = arg.value;
						if(_g3 != null) {
							let v = _g3;
							if(!this.resumeErrors) {
								throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.ECustom("Default values not allowed in function types"),v.pmin,v.pmax,this.origin,this.line));
							}
						}
						_g.push(hscript_CType.CTNamed(arg.name,arg.opt ? hscript_CType.CTOpt(arg.t) : arg.t));
					}
					let args = _g;
					return withReturn(args);
				} else {
					let t = this.parseType();
					let _g = this.token();
					switch(_g._hx_index) {
					case 5:
						return this.parseTypeNext(hscript_CType.CTParent(t));
					case 10:
						let args = [t];
						do args.push(this.parseType()); while(this.maybe(hscript_Token.TComma));
						let t1 = this.token();
						if(t1 != hscript_Token.TPClose) {
							this.unexpected(t1);
						}
						return withReturn(args);
					default:
						let t2 = _g;
						return this.unexpected(t2);
					}
				}
				break;
			case 5:
				let _g1 = [];
				let _g2 = 0;
				let _g3 = this.parseFunctionArgs();
				while(_g2 < _g3.length) {
					let arg = _g3[_g2];
					++_g2;
					let _g = arg.value;
					if(_g != null) {
						let v = _g;
						if(!this.resumeErrors) {
							throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.ECustom("Default values not allowed in function types"),v.pmin,v.pmax,this.origin,this.line));
						}
					}
					_g1.push(hscript_CType.CTNamed(arg.name,arg.opt ? hscript_CType.CTOpt(arg.t) : arg.t));
				}
				let args = _g1;
				return withReturn(args);
			default:
				let t1 = this.parseType();
				let _g4 = this.token();
				switch(_g4._hx_index) {
				case 5:
					return this.parseTypeNext(hscript_CType.CTParent(t1));
				case 10:
					let args1 = [t1];
					do args1.push(this.parseType()); while(this.maybe(hscript_Token.TComma));
					let t2 = this.token();
					if(t2 != hscript_Token.TPClose) {
						this.unexpected(t2);
					}
					return withReturn(args1);
				default:
					let t3 = _g4;
					return this.unexpected(t3);
				}
			}
			break;
		case 6:
			let fields = [];
			let meta = null;
			_hx_loop6: while(true) {
				t = this.token();
				switch(t._hx_index) {
				case 2:
					let _g = t.s;
					if(_g == "var") {
						let name = this.getIdent();
						let t = this.token();
						if(t != hscript_Token.TDoubleDot) {
							this.unexpected(t);
						}
						fields.push({ name : name, t : this.parseType(), meta : meta});
						meta = null;
						let t1 = this.token();
						if(t1 != hscript_Token.TSemicolon) {
							this.unexpected(t1);
						}
					} else {
						let name = _g;
						let t1 = this.token();
						if(t1 != hscript_Token.TDoubleDot) {
							this.unexpected(t1);
						}
						fields.push({ name : name, t : this.parseType(), meta : meta});
						t = this.token();
						switch(t._hx_index) {
						case 7:
							break _hx_loop6;
						case 10:
							break;
						default:
							this.unexpected(t);
						}
					}
					break;
				case 7:
					break _hx_loop6;
				case 16:
					let name = t.s;
					if(meta == null) {
						meta = [];
					}
					meta.push({ name : name, params : this.parseMetaArgs()});
					break;
				default:
					this.unexpected(t);
					break _hx_loop6;
				}
			}
			return this.parseTypeNext(hscript_CType.CTAnon(fields));
		default:
			return this.unexpected(t);
		}
	}
	parseTypeNext(t) {
		let tk = this.token();
		if(tk._hx_index == 3) {
			let op = tk.s;
			if(op != "->") {
				this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
				return t;
			}
		} else {
			this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			return t;
		}
		let t2 = this.parseType();
		if(t2._hx_index == 1) {
			let _g = t2.ret;
			let args = t2.args;
			args.unshift(t);
			return t2;
		} else {
			return hscript_CType.CTFun([t],t2);
		}
	}
	parseExprList(etk) {
		let args = [];
		let tk = this.token();
		if(tk == etk) {
			return args;
		}
		this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
		this.tokenMin = this.oldTokenMin;
		this.tokenMax = this.oldTokenMax;
		while(true) {
			args.push(this.parseExpr());
			tk = this.token();
			if(tk._hx_index != 10) {
				if(tk == etk) {
					break;
				}
				this.unexpected(tk);
				break;
			}
		}
		return args;
	}
	parseModule(content,origin,position) {
		if(position == null) {
			position = 0;
		}
		if(origin == null) {
			origin = "hscript";
		}
		this.initParser(origin,position);
		this.input = content;
		this.readPos = 0;
		this.allowTypes = true;
		this.allowMetadata = true;
		let decls = [];
		while(true) {
			let tk = this.token();
			if(tk == hscript_Token.TEof) {
				break;
			}
			this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			decls.push(this.parseModuleDecl());
		}
		return decls;
	}
	parseMetadata() {
		let meta = [];
		while(true) {
			let tk = this.token();
			if(tk._hx_index == 16) {
				let name = tk.s;
				meta.push({ name : name, params : this.parseMetaArgs()});
			} else {
				this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
				break;
			}
		}
		return meta;
	}
	parseParams() {
		if(this.maybe(hscript_Token.TOp("<"))) {
			if(!this.resumeErrors) {
				throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.EInvalidOp("Unsupported class type parameters"),this.readPos + this.offset,this.readPos + this.offset,this.origin,this.line));
			}
		}
		return { };
	}
	parseModuleDecl() {
		let meta = this.parseMetadata();
		let ident = this.getIdent();
		let isPrivate = false;
		let isExtern = false;
		_hx_loop1: while(true) {
			switch(ident) {
			case "extern":
				isExtern = true;
				break;
			case "private":
				isPrivate = true;
				break;
			default:
				break _hx_loop1;
			}
			ident = this.getIdent();
		}
		switch(ident) {
		case "class":
			let name = this.getIdent();
			let params = this.parseParams();
			let extend = null;
			let implement = [];
			_hx_loop2: while(true) {
				let t = this.token();
				if(t._hx_index == 2) {
					switch(t.s) {
					case "extends":
						extend = this.parseType();
						break;
					case "implements":
						implement.push(this.parseType());
						break;
					default:
						this.tokens.push({ t : t, min : this.tokenMin, max : this.tokenMax});
						this.tokenMin = this.oldTokenMin;
						this.tokenMax = this.oldTokenMax;
						break _hx_loop2;
					}
				} else {
					this.tokens.push({ t : t, min : this.tokenMin, max : this.tokenMax});
					this.tokenMin = this.oldTokenMin;
					this.tokenMax = this.oldTokenMax;
					break;
				}
			}
			let fields = [];
			let t = this.token();
			if(t != hscript_Token.TBrOpen) {
				this.unexpected(t);
			}
			while(!this.maybe(hscript_Token.TBrClose)) fields.push(this.parseField());
			return hscript_ModuleDecl.DClass({ name : name, meta : meta, params : params, extend : extend, implement : implement, fields : fields, isPrivate : isPrivate, isExtern : isExtern});
		case "import":
			let path = [this.getIdent()];
			let star = false;
			while(true) {
				let t = this.token();
				if(t != hscript_Token.TDot) {
					this.tokens.push({ t : t, min : this.tokenMin, max : this.tokenMax});
					this.tokenMin = this.oldTokenMin;
					this.tokenMax = this.oldTokenMax;
					break;
				}
				t = this.token();
				switch(t._hx_index) {
				case 2:
					let id = t.s;
					path.push(id);
					break;
				case 3:
					if(t.s == "*") {
						star = true;
					} else {
						this.unexpected(t);
					}
					break;
				default:
					this.unexpected(t);
				}
			}
			let t1 = this.token();
			if(t1 != hscript_Token.TSemicolon) {
				this.unexpected(t1);
			}
			return hscript_ModuleDecl.DImport(path,star);
		case "package":
			let path1 = this.parsePath();
			let t2 = this.token();
			if(t2 != hscript_Token.TSemicolon) {
				this.unexpected(t2);
			}
			return hscript_ModuleDecl.DPackage(path1);
		case "typedef":
			let name1 = this.getIdent();
			let params1 = this.parseParams();
			let t3 = this.token();
			if(!Type.enumEq(t3,hscript_Token.TOp("="))) {
				this.unexpected(t3);
			}
			let t4 = this.parseType();
			return hscript_ModuleDecl.DTypedef({ name : name1, meta : meta, params : params1, isPrivate : isPrivate, t : t4});
		default:
			this.unexpected(hscript_Token.TId(ident));
		}
		return null;
	}
	parseField() {
		let meta = this.parseMetadata();
		let access = [];
		_hx_loop1: while(true) {
			let id = this.getIdent();
			switch(id) {
			case "function":
				let name = this.getIdent();
				let inf = this.parseFunctionDecl();
				return { name : name, meta : meta, access : access, kind : hscript_FieldKind.KFunction({ args : inf.args, expr : inf.body, ret : inf.ret})};
			case "inline":
				access.push(hscript_FieldAccess.AInline);
				break;
			case "macro":
				access.push(hscript_FieldAccess.AMacro);
				break;
			case "override":
				access.push(hscript_FieldAccess.AOverride);
				break;
			case "private":
				access.push(hscript_FieldAccess.APrivate);
				break;
			case "public":
				access.push(hscript_FieldAccess.APublic);
				break;
			case "static":
				access.push(hscript_FieldAccess.AStatic);
				break;
			case "var":
				let name1 = this.getIdent();
				let get = null;
				let set = null;
				if(this.maybe(hscript_Token.TPOpen)) {
					get = this.getIdent();
					let t = this.token();
					if(t != hscript_Token.TComma) {
						this.unexpected(t);
					}
					set = this.getIdent();
					let t1 = this.token();
					if(t1 != hscript_Token.TPClose) {
						this.unexpected(t1);
					}
				}
				let type = this.maybe(hscript_Token.TDoubleDot) ? this.parseType() : null;
				let expr = this.maybe(hscript_Token.TOp("=")) ? this.parseExpr() : null;
				if(expr != null) {
					if(this.isBlock(expr)) {
						this.maybe(hscript_Token.TSemicolon);
					} else {
						let t = this.token();
						if(t != hscript_Token.TSemicolon) {
							this.unexpected(t);
						}
					}
				} else {
					let tmp;
					if(type != null) {
						if(type == null) {
							tmp = false;
						} else if(type._hx_index == 2) {
							let _g = type.fields;
							tmp = true;
						} else {
							tmp = false;
						}
					} else {
						tmp = false;
					}
					if(tmp) {
						this.maybe(hscript_Token.TSemicolon);
					} else {
						let t = this.token();
						if(t != hscript_Token.TSemicolon) {
							this.unexpected(t);
						}
					}
				}
				return { name : name1, meta : meta, access : access, kind : hscript_FieldKind.KVar({ get : get, set : set, type : type, expr : expr})};
			default:
				this.unexpected(hscript_Token.TId(id));
				break _hx_loop1;
			}
		}
		return null;
	}
	readChar() {
		return this.input.charCodeAt(this.readPos++);
	}
	readString(until) {
		let c = 0;
		let b_b = "";
		let esc = false;
		let old = this.line;
		let s = this.input;
		let p1 = this.readPos + this.offset - 1;
		while(true) {
			let c = this.input.charCodeAt(this.readPos++);
			if(c != c) {
				this.line = old;
				if(!this.resumeErrors) {
					throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.EUnterminatedString,p1,p1,this.origin,this.line));
				}
				break;
			}
			if(esc) {
				esc = false;
				switch(c) {
				case 47:
					if(this.allowJSON) {
						b_b += String.fromCodePoint(c);
					} else {
						this.invalidChar(c);
					}
					break;
				case 34:case 39:case 92:
					b_b += String.fromCodePoint(c);
					break;
				case 110:
					b_b += String.fromCodePoint(10);
					break;
				case 114:
					b_b += String.fromCodePoint(13);
					break;
				case 116:
					b_b += String.fromCodePoint(9);
					break;
				case 117:
					if(!this.allowJSON) {
						this.invalidChar(c);
					}
					let k = 0;
					let _g = 0;
					while(_g < 4) {
						let i = _g++;
						k <<= 4;
						let char = this.input.charCodeAt(this.readPos++);
						switch(char) {
						case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
							k += char - 48;
							break;
						case 65:case 66:case 67:case 68:case 69:case 70:
							k += char - 55;
							break;
						case 97:case 98:case 99:case 100:case 101:case 102:
							k += char - 87;
							break;
						default:
							if(char != char) {
								this.line = old;
								if(!this.resumeErrors) {
									throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.EUnterminatedString,p1,p1,this.origin,this.line));
								}
							}
							this.invalidChar(char);
						}
					}
					b_b += String.fromCodePoint(k);
					break;
				default:
					this.invalidChar(c);
				}
			} else if(c == 92) {
				esc = true;
			} else if(c == until) {
				break;
			} else {
				if(c == 10) {
					this.line++;
				}
				b_b += String.fromCodePoint(c);
			}
		}
		return b_b;
	}
	token() {
		let t = this.tokens.pop();
		if(t != null) {
			this.tokenMin = t.min;
			this.tokenMax = t.max;
			return t.t;
		}
		this.oldTokenMin = this.tokenMin;
		this.oldTokenMax = this.tokenMax;
		this.tokenMin = this.char < 0 ? this.readPos + this.offset : this.readPos + this.offset - 1;
		let t1 = this._token();
		this.tokenMax = this.char < 0 ? this.readPos + this.offset - 1 : this.readPos + this.offset - 2;
		return t1;
	}
	_token() {
		let char;
		if(this.char < 0) {
			char = this.input.charCodeAt(this.readPos++);
		} else {
			char = this.char;
			this.char = -1;
		}
		while(true) {
			if(char != char) {
				this.char = char;
				return hscript_Token.TEof;
			}
			switch(char) {
			case 0:
				return hscript_Token.TEof;
			case 10:
				this.line++;
				this.tokenMin++;
				break;
			case 9:case 13:case 32:
				this.tokenMin++;
				break;
			case 34:case 39:
				return hscript_Token.TConst(hscript_Const.CString(this.readString(char)));
			case 35:
				char = this.input.charCodeAt(this.readPos++);
				if(this.idents[char]) {
					let id = String.fromCodePoint(char);
					while(true) {
						char = this.input.charCodeAt(this.readPos++);
						if(!this.idents[char]) {
							this.char = char;
							return this.preprocess(id);
						}
						id += String.fromCodePoint(char);
					}
				}
				this.invalidChar(char);
				break;
			case 40:
				return hscript_Token.TPOpen;
			case 41:
				return hscript_Token.TPClose;
			case 44:
				return hscript_Token.TComma;
			case 46:
				char = this.input.charCodeAt(this.readPos++);
				switch(char) {
				case 46:
					char = this.input.charCodeAt(this.readPos++);
					if(char != 46) {
						this.invalidChar(char);
					}
					return hscript_Token.TOp("...");
				case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
					let n = char - 48;
					let exp = 1;
					while(true) {
						char = this.input.charCodeAt(this.readPos++);
						exp *= 10;
						switch(char) {
						case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
							n = n * 10 + (char - 48);
							break;
						default:
							this.char = char;
							return hscript_Token.TConst(hscript_Const.CFloat(n / exp));
						}
					}
					break;
				default:
					this.char = char;
					return hscript_Token.TDot;
				}
				break;
			case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
				let n1 = (char - 48) * 1.0;
				let exp1 = 0.;
				while(true) {
					char = this.input.charCodeAt(this.readPos++);
					exp1 *= 10;
					switch(char) {
					case 46:
						if(exp1 > 0) {
							if(exp1 == 10 && this.input.charCodeAt(this.readPos++) == 46) {
								this.tokens.push({ t : hscript_Token.TOp("..."), min : this.tokenMin, max : this.tokenMax});
								this.tokenMin = this.oldTokenMin;
								this.tokenMax = this.oldTokenMax;
								let i = n1 | 0;
								return hscript_Token.TConst(i == n1 ? hscript_Const.CInt(i) : hscript_Const.CFloat(n1));
							}
							this.invalidChar(char);
						}
						exp1 = 1.;
						break;
					case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
						n1 = n1 * 10 + (char - 48);
						break;
					case 69:case 101:
						let tk = this.token();
						let pow = null;
						switch(tk._hx_index) {
						case 1:
							let _g = tk.c;
							if(_g._hx_index == 0) {
								let e = _g.v;
								pow = e;
							} else {
								this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
								this.tokenMin = this.oldTokenMin;
								this.tokenMax = this.oldTokenMax;
							}
							break;
						case 3:
							if(tk.s == "-") {
								tk = this.token();
								if(tk._hx_index == 1) {
									let _g = tk.c;
									if(_g._hx_index == 0) {
										let e = _g.v;
										pow = -e;
									} else {
										this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
										this.tokenMin = this.oldTokenMin;
										this.tokenMax = this.oldTokenMax;
									}
								} else {
									this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
									this.tokenMin = this.oldTokenMin;
									this.tokenMax = this.oldTokenMax;
								}
							} else {
								this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
								this.tokenMin = this.oldTokenMin;
								this.tokenMax = this.oldTokenMax;
							}
							break;
						default:
							this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
							this.tokenMin = this.oldTokenMin;
							this.tokenMax = this.oldTokenMax;
						}
						if(pow == null) {
							this.invalidChar(char);
						}
						if(exp1 == 0) {
							exp1 = 10;
						}
						return hscript_Token.TConst(hscript_Const.CFloat(Math.pow(10,pow) / exp1 * n1 * 10));
					case 120:
						if(n1 > 0 || exp1 > 0) {
							this.invalidChar(char);
						}
						let n = 0;
						while(true) {
							char = this.input.charCodeAt(this.readPos++);
							switch(char) {
							case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
								n = (n << 4) + char - 48;
								break;
							case 65:case 66:case 67:case 68:case 69:case 70:
								n = (n << 4) + (char - 55);
								break;
							case 97:case 98:case 99:case 100:case 101:case 102:
								n = (n << 4) + (char - 87);
								break;
							default:
								this.char = char;
								return hscript_Token.TConst(hscript_Const.CInt(n));
							}
						}
						break;
					default:
						this.char = char;
						let i = n1 | 0;
						return hscript_Token.TConst(exp1 > 0 ? hscript_Const.CFloat(n1 * 10 / exp1) : i == n1 ? hscript_Const.CInt(i) : hscript_Const.CFloat(n1));
					}
				}
				break;
			case 58:
				return hscript_Token.TDoubleDot;
			case 59:
				return hscript_Token.TSemicolon;
			case 61:
				char = this.input.charCodeAt(this.readPos++);
				if(char == 61) {
					return hscript_Token.TOp("==");
				} else if(char == 62) {
					return hscript_Token.TOp("=>");
				}
				this.char = char;
				return hscript_Token.TOp("=");
			case 63:
				char = this.input.charCodeAt(this.readPos++);
				if(char == 46) {
					return hscript_Token.TQuestionDot;
				}
				this.char = char;
				return hscript_Token.TQuestion;
			case 64:
				char = this.input.charCodeAt(this.readPos++);
				if(this.idents[char] || char == 58) {
					let id = String.fromCodePoint(char);
					while(true) {
						char = this.input.charCodeAt(this.readPos++);
						if(!this.idents[char]) {
							this.char = char;
							return hscript_Token.TMeta(id);
						}
						id += String.fromCodePoint(char);
					}
				}
				this.invalidChar(char);
				break;
			case 91:
				return hscript_Token.TBkOpen;
			case 93:
				return hscript_Token.TBkClose;
			case 123:
				return hscript_Token.TBrOpen;
			case 125:
				return hscript_Token.TBrClose;
			default:
				if(this.ops[char]) {
					let op = String.fromCodePoint(char);
					while(true) {
						char = this.input.charCodeAt(this.readPos++);
						if(char != char) {
							char = 0;
						}
						if(!this.ops[char]) {
							this.char = char;
							return hscript_Token.TOp(op);
						}
						let pop = op;
						op += String.fromCodePoint(char);
						if(!Object.prototype.hasOwnProperty.call(this.opPriority.h,op) && Object.prototype.hasOwnProperty.call(this.opPriority.h,pop)) {
							if(op == "//" || op == "/*") {
								return this.tokenComment(op,char);
							}
							this.char = char;
							return hscript_Token.TOp(pop);
						}
					}
				}
				if(this.idents[char]) {
					let id = String.fromCodePoint(char);
					while(true) {
						char = this.input.charCodeAt(this.readPos++);
						if(char != char) {
							char = 0;
						}
						if(!this.idents[char]) {
							this.char = char;
							return hscript_Token.TId(id);
						}
						id += String.fromCodePoint(char);
					}
				}
				this.invalidChar(char);
			}
			char = this.input.charCodeAt(this.readPos++);
		}
	}
	preprocValue(id) {
		return this.preprocesorValues.h[id];
	}
	parsePreproCond() {
		let tk = this.token();
		switch(tk._hx_index) {
		case 2:
			let id = tk.s;
			let e = hscript_ExprDef.EIdent(id);
			let pmin = this.tokenMin;
			let pmax = this.tokenMax;
			if(e == null) {
				return null;
			} else {
				if(pmin == null) {
					pmin = this.tokenMin;
				}
				if(pmax == null) {
					pmax = this.tokenMax;
				}
				return { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
			}
			break;
		case 3:
			if(tk.s == "!") {
				let e = hscript_ExprDef.EUnop("!",true,this.parsePreproCond());
				let pmin = this.tokenMin;
				let pmax = this.tokenMax;
				if(e == null) {
					return null;
				} else {
					if(pmin == null) {
						pmin = this.tokenMin;
					}
					if(pmax == null) {
						pmax = this.tokenMax;
					}
					return { e : e, pmin : pmin, pmax : pmax, origin : this.origin, line : this.line};
				}
			} else {
				return this.unexpected(tk);
			}
			break;
		case 4:
			this.tokens.push({ t : hscript_Token.TPOpen, min : this.tokenMin, max : this.tokenMax});
			this.tokenMin = this.oldTokenMin;
			this.tokenMax = this.oldTokenMax;
			return this.parseExpr();
		default:
			return this.unexpected(tk);
		}
	}
	evalPreproCond(e) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 1:
			let id = _g.v;
			return this.preprocValue(id) != null;
		case 3:
			let e1 = _g.e;
			return this.evalPreproCond(e1);
		case 6:
			let _g1 = _g.e1;
			let _g2 = _g.e2;
			switch(_g.op) {
			case "&&":
				let e11 = _g1;
				let e2 = _g2;
				if(this.evalPreproCond(e11)) {
					return this.evalPreproCond(e2);
				} else {
					return false;
				}
				break;
			case "||":
				let e12 = _g1;
				let e21 = _g2;
				if(!this.evalPreproCond(e12)) {
					return this.evalPreproCond(e21);
				} else {
					return true;
				}
				break;
			default:
				let e3 = e.e;
				if(!this.resumeErrors) {
					throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.EInvalidPreprocessor("Can't eval " + $hxEnums[e3.__enum__].__constructs__[e3._hx_index]._hx_name),this.readPos + this.offset,this.readPos + this.offset,this.origin,this.line));
				}
				return false;
			}
			break;
		case 7:
			let _g3 = _g.prefix;
			if(_g.op == "!") {
				let e = _g.e;
				return !this.evalPreproCond(e);
			} else {
				let e1 = e.e;
				if(!this.resumeErrors) {
					throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.EInvalidPreprocessor("Can't eval " + $hxEnums[e1.__enum__].__constructs__[e1._hx_index]._hx_name),this.readPos + this.offset,this.readPos + this.offset,this.origin,this.line));
				}
				return false;
			}
			break;
		default:
			let e4 = e.e;
			if(!this.resumeErrors) {
				throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.EInvalidPreprocessor("Can't eval " + $hxEnums[e4.__enum__].__constructs__[e4._hx_index]._hx_name),this.readPos + this.offset,this.readPos + this.offset,this.origin,this.line));
			}
			return false;
		}
	}
	preprocess(id) {
		switch(id) {
		case "else":case "elseif":
			if(this.preprocStack.length > 0) {
				if(this.preprocStack[this.preprocStack.length - 1].r) {
					this.preprocStack[this.preprocStack.length - 1].r = false;
					this.skipTokens();
					return this.token();
				} else if(id == "else") {
					this.preprocStack.pop();
					this.preprocStack.push({ r : true});
					return this.token();
				} else {
					this.preprocStack.pop();
					return this.preprocess("if");
				}
			} else {
				return hscript_Token.TPrepro(id);
			}
			break;
		case "end":
			if(this.preprocStack.length > 0) {
				this.preprocStack.pop();
				return this.token();
			} else {
				return hscript_Token.TPrepro(id);
			}
			break;
		case "if":
			let e = this.parsePreproCond();
			if(this.evalPreproCond(e)) {
				this.preprocStack.push({ r : true});
				return this.token();
			}
			this.preprocStack.push({ r : false});
			this.skipTokens();
			return this.token();
		default:
			return hscript_Token.TPrepro(id);
		}
	}
	skipTokens() {
		let spos = this.preprocStack.length - 1;
		let obj = this.preprocStack[spos];
		let pos = this.readPos + this.offset;
		while(true) {
			let tk = this.token();
			if(tk == hscript_Token.TEof) {
				if(!this.resumeErrors) {
					throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.EInvalidPreprocessor("Unclosed"),pos,pos,this.origin,this.line));
				}
			}
			if(this.preprocStack[spos] != obj) {
				this.tokens.push({ t : tk, min : this.tokenMin, max : this.tokenMax});
				this.tokenMin = this.oldTokenMin;
				this.tokenMax = this.oldTokenMax;
				break;
			}
		}
	}
	tokenComment(op,char) {
		let c = HxOverrides.cca(op,1);
		let s = this.input;
		if(c == 47) {
			while(char != 13 && char != 10) {
				char = this.input.charCodeAt(this.readPos++);
				if(char != char) {
					break;
				}
			}
			this.char = char;
			return this.token();
		}
		if(c == 42) {
			let old = this.line;
			if(op == "/**/") {
				this.char = char;
				return this.token();
			}
			do {
				while(char != 42) {
					if(char == 10) {
						this.line++;
					}
					char = this.input.charCodeAt(this.readPos++);
					if(char != char) {
						this.line = old;
						if(!this.resumeErrors) {
							throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.EUnterminatedComment,this.tokenMin,this.tokenMin,this.origin,this.line));
						}
						break;
					}
				}
				char = this.input.charCodeAt(this.readPos++);
				if(char != char) {
					this.line = old;
					if(!this.resumeErrors) {
						throw haxe_Exception.thrown(new hscript_Error(hscript_ErrorDef.EUnterminatedComment,this.tokenMin,this.tokenMin,this.origin,this.line));
					}
					break;
				}
			} while(char != 47);
			return this.token();
		}
		this.char = char;
		return hscript_Token.TOp(op);
	}
	constString(c) {
		switch(c._hx_index) {
		case 0:
			let v = c.v;
			if(v == null) {
				return "null";
			} else {
				return "" + v;
			}
			break;
		case 1:
			let f = c.f;
			if(f == null) {
				return "null";
			} else {
				return "" + f;
			}
			break;
		case 2:
			let s = c.s;
			return s;
		}
	}
	tokenString(t) {
		switch(t._hx_index) {
		case 0:
			return "<eof>";
		case 1:
			let c = t.c;
			return this.constString(c);
		case 2:
			let s = t.s;
			return s;
		case 3:
			let s1 = t.s;
			return s1;
		case 4:
			return "(";
		case 5:
			return ")";
		case 6:
			return "{";
		case 7:
			return "}";
		case 8:
			return ".";
		case 9:
			return "?.";
		case 10:
			return ",";
		case 11:
			return ";";
		case 12:
			return "[";
		case 13:
			return "]";
		case 14:
			return "?";
		case 15:
			return ":";
		case 16:
			let id = t.s;
			return "@" + id;
		case 17:
			let id1 = t.s;
			return "#" + id1;
		}
	}
}
$hxClasses["hscript.Parser"] = hscript_Parser;
hscript_Parser.__name__ = "hscript.Parser";
Object.assign(hscript_Parser.prototype, {
	__class__: hscript_Parser
	,__properties__: {get_currentPos: "get_currentPos"}
});
class hscript_Printer {
	constructor() {
	}
	exprToString(e) {
		this.buf = new StringBuf();
		this.tabs = "";
		this.expr(e);
		return this.buf.b;
	}
	typeToString(t) {
		this.buf = new StringBuf();
		this.tabs = "";
		this.type(t);
		return this.buf.b;
	}
	add(s) {
		this.buf.b += Std.string(s);
	}
	type(t) {
		switch(t._hx_index) {
		case 0:
			let path = t.path;
			let params = t.params;
			let s = path.join(".");
			this.buf.b += Std.string(s);
			if(params != null) {
				this.buf.b += "<";
				let first = true;
				let _g = 0;
				while(_g < params.length) {
					let p = params[_g];
					++_g;
					if(first) {
						first = false;
					} else {
						this.buf.b += ", ";
					}
					this.type(p);
				}
				this.buf.b += ">";
			}
			break;
		case 1:
			let _g = t.args;
			let _g1 = t.ret;
			let args = _g;
			let ret = _g1;
			if(Lambda.exists(args,function(a) {
				if(a._hx_index == 5) {
					let _g = a.n;
					let _g1 = a.t;
					return true;
				} else {
					return false;
				}
			})) {
				this.buf.b += "(";
				let _g = 0;
				while(_g < args.length) {
					let a = args[_g];
					++_g;
					if(a._hx_index == 5) {
						let _g = a.n;
						let _g1 = a.t;
						this.type(a);
					} else {
						this.type(hscript_CType.CTNamed("_",a));
					}
				}
				this.buf.b += ")->";
				this.type(ret);
			} else {
				let args = _g;
				let ret = _g1;
				if(args.length == 0) {
					this.buf.b += "Void -> ";
				} else {
					let _g = 0;
					while(_g < args.length) {
						let a = args[_g];
						++_g;
						this.type(a);
						this.buf.b += " -> ";
					}
				}
				this.type(ret);
			}
			break;
		case 2:
			let fields = t.fields;
			this.buf.b += "{";
			let first = true;
			let _g2 = 0;
			while(_g2 < fields.length) {
				let f = fields[_g2];
				++_g2;
				if(first) {
					first = false;
					this.buf.b += " ";
				} else {
					this.buf.b += ", ";
				}
				this.buf.b += Std.string(f.name + " : ");
				this.type(f.t);
			}
			this.buf.b += first ? "}" : " }";
			break;
		case 3:
			let t1 = t.t;
			this.buf.b += "(";
			this.type(t1);
			this.buf.b += ")";
			break;
		case 4:
			let t2 = t.t;
			this.buf.b += "?";
			this.type(t2);
			break;
		case 5:
			let name = t.n;
			let t3 = t.t;
			this.buf.b += name == null ? "null" : "" + name;
			this.buf.b += ":";
			this.type(t3);
			break;
		}
	}
	addType(t) {
		if(t != null) {
			this.buf.b += " : ";
			this.type(t);
		}
	}
	expr(e) {
		if(e == null) {
			this.buf.b += "??NULL??";
			return;
		}
		let _g = e.e;
		switch(_g._hx_index) {
		case 0:
			let c = _g.c;
			switch(c._hx_index) {
			case 0:
				let i = c.v;
				this.buf.b += i == null ? "null" : "" + i;
				break;
			case 1:
				let f = c.f;
				this.buf.b += f == null ? "null" : "" + f;
				break;
			case 2:
				let s = c.s;
				this.buf.b += "\"";
				let s1 = s.split("\"").join("\\\"").split("\n").join("\\n").split("\r").join("\\r").split("\t").join("\\t");
				this.buf.b += Std.string(s1);
				this.buf.b += "\"";
				break;
			}
			break;
		case 1:
			let v = _g.v;
			this.buf.b += v == null ? "null" : "" + v;
			break;
		case 2:
			let n = _g.n;
			let t = _g.t;
			let e1 = _g.e;
			this.buf.b += Std.string("var " + n);
			this.addType(t);
			if(e1 != null) {
				this.buf.b += " = ";
				this.expr(e1);
			}
			break;
		case 3:
			let e2 = _g.e;
			this.buf.b += "(";
			this.expr(e2);
			this.buf.b += ")";
			break;
		case 4:
			let el = _g.e;
			if(el.length == 0) {
				this.buf.b += "{}";
			} else {
				this.tabs += "\t";
				this.buf.b += "{\n";
				let _g = 0;
				while(_g < el.length) {
					let e = el[_g];
					++_g;
					this.buf.b += Std.string(this.tabs);
					this.expr(e);
					this.buf.b += ";\n";
				}
				this.tabs = HxOverrides.substr(this.tabs,1,null);
				this.buf.b += "}";
			}
			break;
		case 5:
			let e3 = _g.e;
			let f1 = _g.f;
			this.expr(e3);
			this.buf.b += Std.string("." + f1);
			break;
		case 6:
			let op = _g.op;
			let e11 = _g.e1;
			let e21 = _g.e2;
			this.expr(e11);
			this.buf.b += Std.string(" " + op + " ");
			this.expr(e21);
			break;
		case 7:
			let op1 = _g.op;
			let pre = _g.prefix;
			let e4 = _g.e;
			if(pre) {
				this.buf.b += op1 == null ? "null" : "" + op1;
				this.expr(e4);
			} else {
				this.expr(e4);
				this.buf.b += op1 == null ? "null" : "" + op1;
			}
			break;
		case 8:
			let e5 = _g.e;
			let args = _g.params;
			if(e5 == null) {
				this.expr(e5);
			} else {
				let _g = e5.e;
				switch(_g._hx_index) {
				case 0:
					let _g1 = _g.c;
					this.expr(e5);
					break;
				case 1:
					let _g2 = _g.v;
					this.expr(e5);
					break;
				case 5:
					let _g3 = _g.e;
					let _g4 = _g.f;
					this.expr(e5);
					break;
				default:
					this.buf.b += "(";
					this.expr(e5);
					this.buf.b += ")";
				}
			}
			this.buf.b += "(";
			let first = true;
			let _g1 = 0;
			while(_g1 < args.length) {
				let a = args[_g1];
				++_g1;
				if(first) {
					first = false;
				} else {
					this.buf.b += ", ";
				}
				this.expr(a);
			}
			this.buf.b += ")";
			break;
		case 9:
			let cond = _g.cond;
			let e12 = _g.e1;
			let e22 = _g.e2;
			this.buf.b += "if( ";
			this.expr(cond);
			this.buf.b += " ) ";
			this.expr(e12);
			if(e22 != null) {
				this.buf.b += " else ";
				this.expr(e22);
			}
			break;
		case 10:
			let cond1 = _g.cond;
			let e6 = _g.e;
			this.buf.b += "while( ";
			this.expr(cond1);
			this.buf.b += " ) ";
			this.expr(e6);
			break;
		case 11:
			let v1 = _g.v;
			let it = _g.it;
			let e7 = _g.e;
			this.buf.b += Std.string("for( " + v1 + " in ");
			this.expr(it);
			this.buf.b += " ) ";
			this.expr(e7);
			break;
		case 12:
			this.buf.b += "break";
			break;
		case 13:
			this.buf.b += "continue";
			break;
		case 14:
			let params = _g.args;
			let e8 = _g.e;
			let name = _g.name;
			let ret = _g.ret;
			this.buf.b += "function";
			if(name != null) {
				this.buf.b += Std.string(" " + name);
			}
			this.buf.b += "(";
			let first1 = true;
			let _g2 = 0;
			while(_g2 < params.length) {
				let a = params[_g2];
				++_g2;
				if(first1) {
					first1 = false;
				} else {
					this.buf.b += ", ";
				}
				if(a.opt) {
					this.buf.b += "?";
				}
				this.buf.b += Std.string(a.name);
				this.addType(a.t);
			}
			this.buf.b += ")";
			this.addType(ret);
			this.buf.b += " ";
			this.expr(e8);
			break;
		case 15:
			let e9 = _g.e;
			this.buf.b += "return";
			if(e9 != null) {
				this.buf.b += " ";
				this.expr(e9);
			}
			break;
		case 16:
			let e10 = _g.e;
			let index = _g.index;
			this.expr(e10);
			this.buf.b += "[";
			this.expr(index);
			this.buf.b += "]";
			break;
		case 17:
			let el1 = _g.e;
			this.buf.b += "[";
			let first2 = true;
			let _g3 = 0;
			while(_g3 < el1.length) {
				let e = el1[_g3];
				++_g3;
				if(first2) {
					first2 = false;
				} else {
					this.buf.b += ", ";
				}
				this.expr(e);
			}
			this.buf.b += "]";
			break;
		case 18:
			let cl = _g.cl;
			let args1 = _g.params;
			this.buf.b += Std.string("new " + cl + "(");
			let first3 = true;
			let _g4 = 0;
			while(_g4 < args1.length) {
				let e = args1[_g4];
				++_g4;
				if(first3) {
					first3 = false;
				} else {
					this.buf.b += ", ";
				}
				this.expr(e);
			}
			this.buf.b += ")";
			break;
		case 19:
			let e13 = _g.e;
			this.buf.b += "throw ";
			this.expr(e13);
			break;
		case 20:
			let e14 = _g.e;
			let v2 = _g.v;
			let t1 = _g.t;
			let ecatch = _g.ecatch;
			this.buf.b += "try ";
			this.expr(e14);
			this.buf.b += Std.string(" catch( " + v2);
			this.addType(t1);
			this.buf.b += ") ";
			this.expr(ecatch);
			break;
		case 21:
			let fl = _g.fl;
			if(fl.length == 0) {
				this.buf.b += "{}";
			} else {
				this.tabs += "\t";
				this.buf.b += "{\n";
				let _g = 0;
				while(_g < fl.length) {
					let f = fl[_g];
					++_g;
					this.buf.b += Std.string(this.tabs);
					this.buf.b += Std.string(f.name + " : ");
					this.expr(f.e);
					this.buf.b += ",\n";
				}
				this.tabs = HxOverrides.substr(this.tabs,1,null);
				this.buf.b += "}";
			}
			break;
		case 22:
			let c1 = _g.cond;
			let e15 = _g.e1;
			let e23 = _g.e2;
			this.expr(c1);
			this.buf.b += " ? ";
			this.expr(e15);
			this.buf.b += " : ";
			this.expr(e23);
			break;
		case 23:
			let e16 = _g.e;
			let cases = _g.cases;
			let def = _g.defaultExpr;
			this.buf.b += "switch( ";
			this.expr(e16);
			this.buf.b += ") {";
			let _g5 = 0;
			while(_g5 < cases.length) {
				let c = cases[_g5];
				++_g5;
				this.buf.b += "case ";
				let first = true;
				let _g = 0;
				let _g1 = c.values;
				while(_g < _g1.length) {
					let v = _g1[_g];
					++_g;
					if(first) {
						first = false;
					} else {
						this.buf.b += ", ";
					}
					this.expr(v);
				}
				this.buf.b += ": ";
				this.expr(c.expr);
				this.buf.b += ";\n";
			}
			if(def != null) {
				this.buf.b += "default: ";
				this.expr(def);
				this.buf.b += ";\n";
			}
			this.buf.b += "}";
			break;
		case 24:
			let cond2 = _g.cond;
			let e17 = _g.e;
			this.buf.b += "do ";
			this.expr(e17);
			this.buf.b += " while ( ";
			this.expr(cond2);
			this.buf.b += " )";
			break;
		case 25:
			let name1 = _g.name;
			let args2 = _g.args;
			let e18 = _g.e;
			this.buf.b += "@";
			this.buf.b += name1 == null ? "null" : "" + name1;
			if(args2 != null && args2.length > 0) {
				this.buf.b += "(";
				let first = true;
				let _g = 0;
				while(_g < args2.length) {
					let a = args2[_g];
					++_g;
					if(first) {
						first = false;
					} else {
						this.buf.b += ", ";
					}
					this.expr(e18);
				}
				this.buf.b += ")";
			}
			this.buf.b += " ";
			this.expr(e18);
			break;
		case 26:
			let e19 = _g.e;
			let t2 = _g.t;
			this.buf.b += "(";
			this.expr(e19);
			this.buf.b += " : ";
			this.addType(t2);
			this.buf.b += ")";
			break;
		}
	}
	static toString(e) {
		return new hscript_Printer().exprToString(e);
	}
	static errorToString(e) {
		let message;
		let _g = e.e;
		switch(_g._hx_index) {
		case 0:
			let c = _g.c;
			message = "Invalid character: '" + (c != c ? "EOF" : String.fromCodePoint(c)) + "' (" + c + ")";
			break;
		case 1:
			let s = _g.s;
			message = "Unexpected token: \"" + s + "\"";
			break;
		case 2:
			message = "Unterminated string";
			break;
		case 3:
			message = "Unterminated comment";
			break;
		case 4:
			let str = _g.msg;
			message = "Invalid preprocessor (" + str + ")";
			break;
		case 5:
			let v = _g.v;
			message = "Unknown variable: " + v;
			break;
		case 6:
			let v1 = _g.v;
			message = "Invalid iterator: " + v1;
			break;
		case 7:
			let op = _g.op;
			message = "Invalid operator: " + op;
			break;
		case 8:
			let f = _g.f;
			message = "Invalid access to field " + f;
			break;
		case 9:
			let msg = _g.msg;
			message = msg;
			break;
		}
		return e.origin + ":" + e.line + ": " + message;
	}
}
$hxClasses["hscript.Printer"] = hscript_Printer;
hscript_Printer.__name__ = "hscript.Printer";
Object.assign(hscript_Printer.prototype, {
	__class__: hscript_Printer
});
class hscript_Tools {
	static iter(e,f) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 0:
			let _g1 = _g.c;
			break;
		case 1:
			let _g2 = _g.v;
			break;
		case 2:
			let _g3 = _g.n;
			let _g4 = _g.t;
			let e1 = _g.e;
			if(e1 != null) {
				f(e1);
			}
			break;
		case 3:
			let e2 = _g.e;
			f(e2);
			break;
		case 4:
			let el = _g.e;
			let _g5 = 0;
			while(_g5 < el.length) {
				let e = el[_g5];
				++_g5;
				f(e);
			}
			break;
		case 5:
			let _g6 = _g.f;
			let e3 = _g.e;
			f(e3);
			break;
		case 6:
			let _g7 = _g.op;
			let e11 = _g.e1;
			let e21 = _g.e2;
			f(e11);
			f(e21);
			break;
		case 7:
			let _g8 = _g.op;
			let _g9 = _g.prefix;
			let e4 = _g.e;
			f(e4);
			break;
		case 8:
			let e5 = _g.e;
			let args = _g.params;
			f(e5);
			let _g10 = 0;
			while(_g10 < args.length) {
				let a = args[_g10];
				++_g10;
				f(a);
			}
			break;
		case 9:
			let c = _g.cond;
			let e12 = _g.e1;
			let e22 = _g.e2;
			f(c);
			f(e12);
			if(e22 != null) {
				f(e22);
			}
			break;
		case 10:
			let c1 = _g.cond;
			let e6 = _g.e;
			f(c1);
			f(e6);
			break;
		case 11:
			let _g11 = _g.v;
			let it = _g.it;
			let e7 = _g.e;
			f(it);
			f(e7);
			break;
		case 12:case 13:
			break;
		case 14:
			let _g12 = _g.args;
			let _g13 = _g.name;
			let _g14 = _g.ret;
			let e8 = _g.e;
			f(e8);
			break;
		case 15:
			let e9 = _g.e;
			if(e9 != null) {
				f(e9);
			}
			break;
		case 16:
			let e10 = _g.e;
			let i = _g.index;
			f(e10);
			f(i);
			break;
		case 17:
			let el1 = _g.e;
			let _g15 = 0;
			while(_g15 < el1.length) {
				let e = el1[_g15];
				++_g15;
				f(e);
			}
			break;
		case 18:
			let _g16 = _g.cl;
			let el2 = _g.params;
			let _g17 = 0;
			while(_g17 < el2.length) {
				let e = el2[_g17];
				++_g17;
				f(e);
			}
			break;
		case 19:
			let e13 = _g.e;
			f(e13);
			break;
		case 20:
			let _g18 = _g.v;
			let _g19 = _g.t;
			let e14 = _g.e;
			let c2 = _g.ecatch;
			f(e14);
			f(c2);
			break;
		case 21:
			let fl = _g.fl;
			let _g20 = 0;
			while(_g20 < fl.length) {
				let fi = fl[_g20];
				++_g20;
				f(fi.e);
			}
			break;
		case 22:
			let c3 = _g.cond;
			let e15 = _g.e1;
			let e23 = _g.e2;
			f(c3);
			f(e15);
			f(e23);
			break;
		case 23:
			let e16 = _g.e;
			let cases = _g.cases;
			let def = _g.defaultExpr;
			f(e16);
			let _g21 = 0;
			while(_g21 < cases.length) {
				let c = cases[_g21];
				++_g21;
				let _g = 0;
				let _g1 = c.values;
				while(_g < _g1.length) {
					let v = _g1[_g];
					++_g;
					f(v);
				}
				f(c.expr);
			}
			if(def != null) {
				f(def);
			}
			break;
		case 24:
			let c4 = _g.cond;
			let e17 = _g.e;
			f(c4);
			f(e17);
			break;
		case 25:
			let name = _g.name;
			let args1 = _g.args;
			let e18 = _g.e;
			if(args1 != null) {
				let _g = 0;
				while(_g < args1.length) {
					let a = args1[_g];
					++_g;
					f(a);
				}
			}
			f(e18);
			break;
		case 26:
			let _g22 = _g.t;
			let e19 = _g.e;
			f(e19);
			break;
		}
	}
	static map(e,f) {
		let edef;
		let _g = e.e;
		switch(_g._hx_index) {
		case 0:
			let _g1 = _g.c;
			edef = e.e;
			break;
		case 1:
			let _g2 = _g.v;
			edef = e.e;
			break;
		case 2:
			let n = _g.n;
			let t = _g.t;
			let e1 = _g.e;
			edef = hscript_ExprDef.EVar(n,t,e1 != null ? f(e1) : null);
			break;
		case 3:
			let e2 = _g.e;
			edef = hscript_ExprDef.EParent(f(e2));
			break;
		case 4:
			let el = _g.e;
			let _g3 = [];
			let _g4 = 0;
			while(_g4 < el.length) {
				let e = el[_g4];
				++_g4;
				_g3.push(f(e));
			}
			edef = hscript_ExprDef.EBlock(_g3);
			break;
		case 5:
			let e3 = _g.e;
			let fi = _g.f;
			edef = hscript_ExprDef.EField(f(e3),fi);
			break;
		case 6:
			let op = _g.op;
			let e11 = _g.e1;
			let e21 = _g.e2;
			edef = hscript_ExprDef.EBinop(op,f(e11),f(e21));
			break;
		case 7:
			let op1 = _g.op;
			let pre = _g.prefix;
			let e4 = _g.e;
			edef = hscript_ExprDef.EUnop(op1,pre,f(e4));
			break;
		case 8:
			let e5 = _g.e;
			let args = _g.params;
			let edef1 = f(e5);
			let _g5 = [];
			let _g6 = 0;
			while(_g6 < args.length) {
				let a = args[_g6];
				++_g6;
				_g5.push(f(a));
			}
			edef = hscript_ExprDef.ECall(edef1,_g5);
			break;
		case 9:
			let c = _g.cond;
			let e12 = _g.e1;
			let e22 = _g.e2;
			edef = hscript_ExprDef.EIf(f(c),f(e12),e22 != null ? f(e22) : null);
			break;
		case 10:
			let c1 = _g.cond;
			let e6 = _g.e;
			edef = hscript_ExprDef.EWhile(f(c1),f(e6));
			break;
		case 11:
			let v = _g.v;
			let it = _g.it;
			let e7 = _g.e;
			edef = hscript_ExprDef.EFor(v,f(it),f(e7));
			break;
		case 12:case 13:
			edef = e.e;
			break;
		case 14:
			let args1 = _g.args;
			let e8 = _g.e;
			let name = _g.name;
			let t1 = _g.ret;
			edef = hscript_ExprDef.EFunction(args1,f(e8),name,t1);
			break;
		case 15:
			let e9 = _g.e;
			edef = hscript_ExprDef.EReturn(e9 != null ? f(e9) : null);
			break;
		case 16:
			let e10 = _g.e;
			let i = _g.index;
			edef = hscript_ExprDef.EArray(f(e10),f(i));
			break;
		case 17:
			let el1 = _g.e;
			let _g7 = [];
			let _g8 = 0;
			while(_g8 < el1.length) {
				let e = el1[_g8];
				++_g8;
				_g7.push(f(e));
			}
			edef = hscript_ExprDef.EArrayDecl(_g7);
			break;
		case 18:
			let cl = _g.cl;
			let el2 = _g.params;
			let _g9 = [];
			let _g10 = 0;
			while(_g10 < el2.length) {
				let e = el2[_g10];
				++_g10;
				_g9.push(f(e));
			}
			edef = hscript_ExprDef.ENew(cl,_g9);
			break;
		case 19:
			let e13 = _g.e;
			edef = hscript_ExprDef.EThrow(f(e13));
			break;
		case 20:
			let e14 = _g.e;
			let v1 = _g.v;
			let t2 = _g.t;
			let c2 = _g.ecatch;
			edef = hscript_ExprDef.ETry(f(e14),v1,t2,f(c2));
			break;
		case 21:
			let fl = _g.fl;
			let _g11 = [];
			let _g12 = 0;
			while(_g12 < fl.length) {
				let fi = fl[_g12];
				++_g12;
				_g11.push({ name : fi.name, e : f(fi.e)});
			}
			edef = hscript_ExprDef.EObject(_g11);
			break;
		case 22:
			let c3 = _g.cond;
			let e15 = _g.e1;
			let e23 = _g.e2;
			edef = hscript_ExprDef.ETernary(f(c3),f(e15),f(e23));
			break;
		case 23:
			let e16 = _g.e;
			let cases = _g.cases;
			let def = _g.defaultExpr;
			let edef2 = f(e16);
			let _g13 = [];
			let _g14 = 0;
			while(_g14 < cases.length) {
				let c = cases[_g14];
				++_g14;
				let _g = [];
				let _g1 = 0;
				let _g2 = c.values;
				while(_g1 < _g2.length) {
					let v = _g2[_g1];
					++_g1;
					_g.push(f(v));
				}
				_g13.push({ values : _g, expr : f(c.expr)});
			}
			edef = hscript_ExprDef.ESwitch(edef2,_g13,def == null ? null : f(def));
			break;
		case 24:
			let c4 = _g.cond;
			let e17 = _g.e;
			edef = hscript_ExprDef.EDoWhile(f(c4),f(e17));
			break;
		case 25:
			let name1 = _g.name;
			let args2 = _g.args;
			let e18 = _g.e;
			let edef3;
			if(args2 == null) {
				edef3 = null;
			} else {
				let _g = [];
				let _g1 = 0;
				while(_g1 < args2.length) {
					let a = args2[_g1];
					++_g1;
					_g.push(f(a));
				}
				edef3 = _g;
			}
			edef = hscript_ExprDef.EMeta(name1,edef3,f(e18));
			break;
		case 26:
			let e19 = _g.e;
			let t3 = _g.t;
			edef = hscript_ExprDef.ECheckType(f(e19),t3);
			break;
		}
		return { e : edef, pmin : e.pmin, pmax : e.pmax, origin : e.origin, line : e.line};
	}
	static expr(e) {
		return e.e;
	}
	static mk(e,p) {
		return { e : e, pmin : p.pmin, pmax : p.pmax, origin : p.origin, line : p.line};
	}
}
$hxClasses["hscript.Tools"] = hscript_Tools;
hscript_Tools.__name__ = "hscript.Tools";
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __interfLoop(cc,cl) {
		if(cc == null) {
			return false;
		}
		if(cc == cl) {
			return true;
		}
		let intf = cc.__interfaces__;
		if(intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
			let _g = 0;
			let _g1 = intf.length;
			while(_g < _g1) {
				let i = _g++;
				let i1 = intf[i];
				if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
					return true;
				}
			}
		}
		return js_Boot.__interfLoop(cc.__super__,cl);
	}
	static __instanceof(o,cl) {
		if(cl == null) {
			return false;
		}
		switch(cl) {
		case Array:
			return ((o) instanceof Array);
		case Bool:
			return typeof(o) == "boolean";
		case Dynamic:
			return o != null;
		case Float:
			return typeof(o) == "number";
		case Int:
			if(typeof(o) == "number") {
				return ((o | 0) === o);
			} else {
				return false;
			}
			break;
		case String:
			return typeof(o) == "string";
		default:
			if(o != null) {
				if(typeof(cl) == "function") {
					if(js_Boot.__downcastCheck(o,cl)) {
						return true;
					}
				} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
					if(((o) instanceof cl)) {
						return true;
					}
				}
			} else {
				return false;
			}
			if(cl == Class ? o.__name__ != null : false) {
				return true;
			}
			if(cl == Enum ? o.__ename__ != null : false) {
				return true;
			}
			return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
		}
	}
	static __downcastCheck(o,cl) {
		if(!((o) instanceof cl)) {
			if(cl.__isInterface__) {
				return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static __implements(o,iface) {
		return js_Boot.__interfLoop(js_Boot.getClass(o),iface);
	}
	static __cast(o,t) {
		if(o == null || js_Boot.__instanceof(o,t)) {
			return o;
		} else {
			throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __isNativeObj(o) {
		return js_Boot.__nativeClassName(o) != null;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
class loreline_Arrays {
	static isArray(array) {
		if(((array) instanceof Array)) {
			return true;
		}
		return false;
	}
	static arrayLength(array) {
		let arr = array;
		return arr.length;
	}
	static arrayGet(array,index) {
		let i = index | 0;
		let arr = array;
		if(i >= 0 && i < arr.length) {
			return arr[i];
		} else {
			return null;
		}
	}
	static arraySet(array,index,value) {
		let i = index | 0;
		let arr = array;
		arr[i] = value;
	}
	static createArray() {
		let arr = [];
		return arr;
	}
	static arrayPush(array,value) {
		let arr = array;
		arr.push(value);
	}
	static arrayPop(array) {
		let arr = array;
		return arr.pop();
	}
	static arrayShift(array) {
		let arr = array;
		return arr.shift();
	}
	static arrayInsert(array,index,value) {
		let arr = array;
		arr.splice(index,0,value);
	}
	static arrayRemoveAt(array,index) {
		let arr = array;
		arr.splice(index,1);
	}
	static getIterator(array) {
		return new haxe_iterators_ArrayIterator(array);
	}
	static arrayCopy(array) {
		let len = loreline_Arrays.arrayLength(array);
		let copy = loreline_Arrays.createArray();
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			loreline_Arrays.arrayPush(copy,loreline_Arrays.arrayGet(array,i));
		}
		return copy;
	}
	static arraySort(array,cmp) {
		let len = loreline_Arrays.arrayLength(array);
		let _g = 1;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			let key = loreline_Arrays.arrayGet(array,i);
			let j = i - 1;
			while(j >= 0 && cmp(loreline_Arrays.arrayGet(array,j),key) > 0) {
				loreline_Arrays.arraySet(array,j + 1,loreline_Arrays.arrayGet(array,j));
				--j;
			}
			loreline_Arrays.arraySet(array,j + 1,key);
		}
	}
	static arrayReverse(array) {
		let i = 0;
		let j = loreline_Arrays.arrayLength(array) - 1;
		while(i < j) {
			let tmp = loreline_Arrays.arrayGet(array,i);
			loreline_Arrays.arraySet(array,i,loreline_Arrays.arrayGet(array,j));
			loreline_Arrays.arraySet(array,j,tmp);
			++i;
			--j;
		}
	}
	static arrayJoin(array,sep) {
		let len = loreline_Arrays.arrayLength(array);
		let buf_b = "";
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			if(i > 0) {
				buf_b += sep == null ? "null" : "" + sep;
			}
			buf_b += Std.string(loreline_Arrays.arrayGet(array,i) == null ? "null" : Std.string(loreline_Arrays.arrayGet(array,i)));
		}
		return buf_b;
	}
}
$hxClasses["loreline.Arrays"] = loreline_Arrays;
loreline_Arrays.__name__ = "loreline.Arrays";
class loreline_AstUtils {
	static addQuotes(node) {
		node.each(function(child,_) {
			if(((child) instanceof loreline_NStringLiteral)) {
				let str = child;
				if(str.quotes == 0) {
					str.quotes = 1;
					let _g = 0;
					let _g1 = str.parts.length;
					while(_g < _g1) {
						let i = _g++;
						let _g1 = str.parts[i].partType;
						if(_g1._hx_index == 0) {
							let text = _g1.text;
							let tmp = loreline_AstUtils.unquotedRawToQuotedRaw(text);
							str.parts[i].partType = loreline_StringPartType.Raw(tmp);
						}
					}
				}
			}
		});
	}
	static removeQuotes(node) {
		node.each(function(child,_) {
			if(((child) instanceof loreline_NStringLiteral)) {
				let str = child;
				if(str.quotes == 1) {
					let fullText = "";
					let _g = 0;
					let _g1 = str.parts;
					while(_g < _g1.length) {
						let part = _g1[_g];
						++_g;
						let _g2 = part.partType;
						if(_g2._hx_index == 0) {
							let text = _g2.text;
							fullText += text;
						}
					}
					if(loreline_AstUtils.canSafelyRemoveQuotes(fullText)) {
						str.quotes = 0;
						let _g = 0;
						let _g1 = str.parts.length;
						while(_g < _g1) {
							let i = _g++;
							let _g1 = str.parts[i].partType;
							if(_g1._hx_index == 0) {
								let text = _g1.text;
								let tmp = loreline_AstUtils.quotedRawToUnquotedRaw(text);
								str.parts[i].partType = loreline_StringPartType.Raw(tmp);
							}
						}
					}
				}
			}
		});
	}
	static toBraceStyle(node) {
		node.each(function(child,_) {
			if(((child) instanceof loreline_NStateDecl)) {
				(js_Boot.__cast(child , loreline_NStateDecl)).style = 1;
			} else if(((child) instanceof loreline_NCharacterDecl)) {
				(js_Boot.__cast(child , loreline_NCharacterDecl)).style = 1;
			} else if(((child) instanceof loreline_NBeatDecl)) {
				(js_Boot.__cast(child , loreline_NBeatDecl)).style = 1;
			} else if(((child) instanceof loreline_NChoiceStatement)) {
				(js_Boot.__cast(child , loreline_NChoiceStatement)).style = 1;
			} else if(((child) instanceof loreline_NChoiceOption)) {
				(js_Boot.__cast(child , loreline_NChoiceOption)).style = 1;
			} else if(((child) instanceof loreline_NBlock)) {
				(js_Boot.__cast(child , loreline_NBlock)).style = 1;
			} else if(((child) instanceof loreline_NLiteral)) {
				let lit = child;
				let _g = lit.literalType;
				if(_g._hx_index == 4) {
					let _g1 = _g.style;
					lit.literalType = loreline_LiteralType.Object(1);
				}
			}
		});
	}
	static toPlainStyle(node) {
		node.each(function(child,_) {
			if(((child) instanceof loreline_NStateDecl)) {
				(js_Boot.__cast(child , loreline_NStateDecl)).style = 0;
			} else if(((child) instanceof loreline_NCharacterDecl)) {
				(js_Boot.__cast(child , loreline_NCharacterDecl)).style = 0;
			} else if(((child) instanceof loreline_NBeatDecl)) {
				(js_Boot.__cast(child , loreline_NBeatDecl)).style = 0;
			} else if(((child) instanceof loreline_NChoiceStatement)) {
				(js_Boot.__cast(child , loreline_NChoiceStatement)).style = 0;
			} else if(((child) instanceof loreline_NChoiceOption)) {
				(js_Boot.__cast(child , loreline_NChoiceOption)).style = 0;
			} else if(((child) instanceof loreline_NBlock)) {
				(js_Boot.__cast(child , loreline_NBlock)).style = 0;
			} else if(((child) instanceof loreline_NLiteral)) {
				let lit = child;
				let _g = lit.literalType;
				if(_g._hx_index == 4) {
					let _g1 = _g.style;
					lit.literalType = loreline_LiteralType.Object(0);
				}
			}
		});
	}
	static useWordOperators(node) {
		node.each(function(child,_) {
			if(((child) instanceof loreline_NBinary)) {
				let bin = child;
				let _g = bin.op;
				switch(_g._hx_index) {
				case 30:
					let _g1 = _g.word;
					bin.op = loreline_TokenType.OpAnd(true);
					break;
				case 31:
					let _g2 = _g.word;
					bin.op = loreline_TokenType.OpOr(true);
					break;
				default:
				}
			}
		});
	}
	static useSymbolOperators(node) {
		node.each(function(child,_) {
			if(((child) instanceof loreline_NBinary)) {
				let bin = child;
				let _g = bin.op;
				switch(_g._hx_index) {
				case 30:
					let _g1 = _g.word;
					bin.op = loreline_TokenType.OpAnd(false);
					break;
				case 31:
					let _g2 = _g.word;
					bin.op = loreline_TokenType.OpOr(false);
					break;
				default:
				}
			}
		});
	}
	static useParenConditions(node) {
		node.each(function(child,_) {
			if(((child) instanceof loreline_NIfStatement)) {
				(js_Boot.__cast(child , loreline_NIfStatement)).conditionStyle = 2;
			} else if(((child) instanceof loreline_NChoiceOption)) {
				(js_Boot.__cast(child , loreline_NChoiceOption)).conditionStyle = 2;
			}
		});
	}
	static usePlainConditions(node) {
		node.each(function(child,_) {
			if(((child) instanceof loreline_NIfStatement)) {
				(js_Boot.__cast(child , loreline_NIfStatement)).conditionStyle = 0;
			} else if(((child) instanceof loreline_NChoiceOption)) {
				(js_Boot.__cast(child , loreline_NChoiceOption)).conditionStyle = 0;
			}
		});
	}
	static reindentFunctions(node,oldIndent,newIndent) {
		node.each(function(child,_) {
			if(((child) instanceof loreline_NFunctionDecl)) {
				let func = child;
				if(func.code != null && func.code.length > 0 && !func.external) {
					func.code = loreline_AstUtils.reindentCode(func.code,oldIndent,newIndent);
				}
			}
		});
	}
	static insertLocalizationKeys(content,node) {
		let rng = new loreline_Random();
		let sourceLines = content.split("\n");
		let existingIds_h = Object.create(null);
		node.each(function(child,_) {
			if(((child) instanceof loreline_AstNode)) {
				let astChild = child;
				if(astChild.trailingComments != null) {
					let _g = 0;
					let _g1 = astChild.trailingComments;
					while(_g < _g1.length) {
						let c = _g1[_g];
						++_g;
						if(c.isHash) {
							let key = StringTools.trim(c.content);
							existingIds_h[key] = true;
						}
					}
				}
				if(astChild.leadingComments != null) {
					let _g = 0;
					let _g1 = astChild.leadingComments;
					while(_g < _g1.length) {
						let c = _g1[_g];
						++_g;
						if(c.isHash) {
							let key = StringTools.trim(c.content);
							existingIds_h[key] = true;
						}
					}
				}
			}
		});
		let insertions = [];
		node.each(function(child,_) {
			let str = null;
			if(((child) instanceof loreline_NTextStatement)) {
				str = (js_Boot.__cast(child , loreline_NTextStatement)).content;
			} else if(((child) instanceof loreline_NDialogueStatement)) {
				str = (js_Boot.__cast(child , loreline_NDialogueStatement)).content;
			} else if(((child) instanceof loreline_NChoiceOption)) {
				str = (js_Boot.__cast(child , loreline_NChoiceOption)).text;
			}
			if(str != null) {
				let endLine = loreline_AstUtils.getStringEndLine(str);
				let lineIdx = endLine - 1;
				if(lineIdx >= 0 && lineIdx < sourceLines.length && loreline_AstUtils.lineHasHashComment(sourceLines[lineIdx])) {
					return;
				}
				let id;
				let iterations = 0;
				do {
					id = loreline_AstUtils.randomId(rng,4 + (iterations * 0.01 | 0));
					++iterations;
				} while(Object.prototype.hasOwnProperty.call(existingIds_h,id));
				existingIds_h[id] = true;
				insertions.push({ offset : str.pos.offset + str.pos.length, text : " #" + id});
			}
		});
		if(insertions.length == 0) {
			return content;
		}
		insertions.sort(function(a,b) {
			return b.offset - a.offset;
		});
		let result = content;
		let _g = 0;
		while(_g < insertions.length) {
			let ins = insertions[_g];
			++_g;
			result = HxOverrides.substr(result,0,ins.offset) + ins.text + HxOverrides.substr(result,ins.offset,null);
		}
		return result;
	}
	static removeLocalizationKeys(content,node) {
		let removals = [];
		node.each(function(child,_) {
			if(((child) instanceof loreline_AstNode)) {
				let astChild = child;
				let comments = astChild.trailingComments;
				if(comments != null) {
					let _g = 0;
					while(_g < comments.length) {
						let c = comments[_g];
						++_g;
						if(c.isHash) {
							let start = c.pos.offset;
							let end = c.pos.offset + c.pos.length;
							while(start > 0) {
								let ch = HxOverrides.cca(content,start - 1);
								if(ch == 32 || ch == 9) {
									--start;
								} else {
									break;
								}
							}
							removals.push({ start : start, end : end});
						}
					}
				}
				let comments1 = astChild.leadingComments;
				if(comments1 != null) {
					let _g = 0;
					while(_g < comments1.length) {
						let c = comments1[_g];
						++_g;
						if(c.isHash) {
							let start = c.pos.offset;
							let end = c.pos.offset + c.pos.length;
							while(start > 0) {
								let ch = HxOverrides.cca(content,start - 1);
								if(ch == 32 || ch == 9) {
									--start;
								} else {
									break;
								}
							}
							removals.push({ start : start, end : end});
						}
					}
				}
			}
		});
		if(removals.length == 0) {
			return content;
		}
		removals.sort(function(a,b) {
			return b.start - a.start;
		});
		let result = content;
		let _g = 0;
		while(_g < removals.length) {
			let r = removals[_g];
			++_g;
			result = HxOverrides.substr(result,0,r.start) + HxOverrides.substr(result,r.end,null);
		}
		return result;
	}
	static lineHasHashComment(line) {
		let i = 0;
		while(i < line.length) {
			if(HxOverrides.cca(line,i) == 35) {
				if(i + 1 < line.length && HxOverrides.cca(line,i + 1) == 35) {
					i += 2;
					continue;
				}
				if(i > 0 && HxOverrides.cca(line,i - 1) == 92) {
					++i;
					continue;
				}
				let j = i + 1;
				while(j < line.length) {
					let c = HxOverrides.cca(line,j);
					if(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 95 || c == 45) {
						++j;
					} else {
						break;
					}
				}
				if(j > i + 1) {
					return true;
				}
			}
			++i;
		}
		return false;
	}
	static extractTranslations(node) {
		let result = new haxe_ds_StringMap();
		node.each(function(child,_) {
			let str = null;
			let astNode = null;
			if(((child) instanceof loreline_NTextStatement)) {
				astNode = child;
				str = (js_Boot.__cast(child , loreline_NTextStatement)).content;
			} else if(((child) instanceof loreline_NDialogueStatement)) {
				astNode = child;
				str = (js_Boot.__cast(child , loreline_NDialogueStatement)).content;
			}
			if(str != null && astNode != null) {
				let hashId = loreline_AstUtils.findHashComment(astNode,str);
				if(hashId != null) {
					result.h[hashId] = str;
				}
			}
		});
		return result;
	}
	static extractTranslatableEntries(node) {
		let result = [];
		node.each(function(child,_) {
			let astNode = null;
			let str = null;
			if(((child) instanceof loreline_NTextStatement)) {
				astNode = child;
				str = (js_Boot.__cast(child , loreline_NTextStatement)).content;
			} else if(((child) instanceof loreline_NDialogueStatement)) {
				astNode = child;
				str = (js_Boot.__cast(child , loreline_NDialogueStatement)).content;
			} else if(((child) instanceof loreline_NChoiceOption)) {
				let opt = child;
				if(opt.text != null) {
					astNode = child;
					str = opt.text;
				}
			}
			if(str != null && astNode != null) {
				let hashId = loreline_AstUtils.findHashComment(astNode,str);
				if(hashId != null) {
					result.push({ id : hashId, str : str});
				}
			}
		});
		return result;
	}
	static generateTranslationFile(sourceScript,existingTranslations,printer) {
		let entries = loreline_AstUtils.extractTranslatableEntries(sourceScript);
		let buf_b = "";
		let first = true;
		buf_b += "\n";
		let _g = 0;
		while(_g < entries.length) {
			let entry = entries[_g];
			++_g;
			if(!first) {
				buf_b += "\n";
			}
			first = false;
			let refText = printer.printStringLiteralAsReference(entry.str);
			let plainText = printer.printStringLiteralAsText(entry.str);
			buf_b += "#";
			buf_b += Std.string(entry.id);
			buf_b += " // ";
			buf_b += refText == null ? "null" : "" + refText;
			buf_b += "\n";
			if(existingTranslations != null && Object.prototype.hasOwnProperty.call(existingTranslations.h,entry.id)) {
				buf_b += Std.string(printer.printStringLiteralAsText(existingTranslations.h[entry.id]));
			} else {
				buf_b += plainText == null ? "null" : "" + plainText;
			}
			buf_b += "\n";
		}
		return buf_b;
	}
	static unquotedRawToQuotedRaw(text) {
		let result_b = "";
		let i = 0;
		while(i < text.length) {
			let c = HxOverrides.cca(text,i);
			if(c == 92 && i + 1 < text.length) {
				let next = HxOverrides.cca(text,i + 1);
				if(next == 110 || next == 116 || next == 114 || next == 92 || next == 60) {
					result_b += String.fromCodePoint(c);
					result_b += String.fromCodePoint(next);
					i += 2;
				} else {
					result_b += String.fromCodePoint(next);
					i += 2;
				}
			} else if(c == 34) {
				result_b += "\\\"";
				++i;
			} else {
				result_b += String.fromCodePoint(c);
				++i;
			}
		}
		return result_b;
	}
	static quotedRawToUnquotedRaw(text) {
		let result_b = "";
		let i = 0;
		while(i < text.length) {
			let c = HxOverrides.cca(text,i);
			if(c == 92 && i + 1 < text.length) {
				let next = HxOverrides.cca(text,i + 1);
				if(next == 34) {
					result_b += String.fromCodePoint(next);
					i += 2;
				} else {
					result_b += String.fromCodePoint(c);
					result_b += String.fromCodePoint(next);
					i += 2;
				}
			} else {
				result_b += String.fromCodePoint(c);
				++i;
			}
		}
		return result_b;
	}
	static canSafelyRemoveQuotes(text) {
		if(text.length == 0) {
			return false;
		}
		if(text.indexOf("\n") != -1) {
			return false;
		}
		if(text.indexOf("{") != -1) {
			return false;
		}
		let firstChar = HxOverrides.cca(text,0);
		if(firstChar == 40 || firstChar == 91 || firstChar == 123 || firstChar == 125 || firstChar == 93 || firstChar == 58 || firstChar == 61) {
			return false;
		}
		if(text.length >= 2 && firstChar == 47) {
			let second = HxOverrides.cca(text,1);
			if(second == 47 || second == 42) {
				return false;
			}
		}
		if(text.length >= 2 && firstChar == 45 && HxOverrides.cca(text,1) == 62) {
			return false;
		}
		if(firstChar == 43 && text.length >= 3 && HxOverrides.cca(text,1) == 32) {
			return false;
		}
		let keywords = ["beat ","state ","character ","choice ","import ","new ","function ","if ","else "];
		let _g = 0;
		while(_g < keywords.length) {
			let kw = keywords[_g];
			++_g;
			if(text.startsWith(kw)) {
				return false;
			}
		}
		let colonIdx = text.indexOf(":");
		if(colonIdx > 0) {
			let allIdentChars = true;
			let _g = 0;
			let _g1 = colonIdx;
			while(_g < _g1) {
				let j = _g++;
				let ch = HxOverrides.cca(text,j);
				if(!(ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch == 95)) {
					allIdentChars = false;
					break;
				}
			}
			if(allIdentChars) {
				return false;
			}
		}
		if(text == "null" || text == "true" || text == "false") {
			return false;
		}
		if(loreline_AstUtils.isNumberLiteral(text)) {
			return false;
		}
		if(text.length >= 2) {
			let second = HxOverrides.cca(text,1);
			if(second == 61 && (firstChar == 43 || firstChar == 45 || firstChar == 42 || firstChar == 47)) {
				return false;
			}
		}
		return true;
	}
	static isNumberLiteral(text) {
		if(text.length == 0) {
			return false;
		}
		let i = 0;
		if(HxOverrides.cca(text,0) == 45) {
			++i;
		}
		if(i >= text.length) {
			return false;
		}
		let hasDigit = false;
		let hasDot = false;
		while(i < text.length) {
			let c = HxOverrides.cca(text,i);
			if(c >= 48 && c <= 57) {
				hasDigit = true;
			} else if(c == 46 && !hasDot) {
				hasDot = true;
			} else {
				return false;
			}
			++i;
		}
		return hasDigit;
	}
	static reindentCode(code,oldIndent,newIndent) {
		if(oldIndent == newIndent) {
			return code;
		}
		let lines = code.split("\n");
		let result_b = "";
		let _g = 0;
		let _g1 = lines.length;
		while(_g < _g1) {
			let i = _g++;
			if(i > 0) {
				result_b += "\n";
			}
			let line = lines[i];
			let level = 0;
			let pos = 0;
			while(HxOverrides.substr(line,pos,null).startsWith(oldIndent)) {
				++level;
				pos += oldIndent.length;
			}
			let _g1 = 0;
			let _g2 = level;
			while(_g1 < _g2) {
				let _ = _g1++;
				result_b += newIndent == null ? "null" : "" + newIndent;
			}
			result_b += Std.string(HxOverrides.substr(line,pos,null));
		}
		return result_b;
	}
	static getStringEndLine(str) {
		let endLine = str.pos.line;
		let _g = 0;
		let _g1 = str.parts;
		while(_g < _g1.length) {
			let part = _g1[_g];
			++_g;
			if(part.pos != null) {
				let partEndLine = part.pos.line;
				let _g = part.partType;
				if(_g._hx_index == 0) {
					let text = _g.text;
					let i = 0;
					while(i < text.length) {
						if(HxOverrides.cca(text,i) == 10) {
							++partEndLine;
						}
						++i;
					}
				}
				if(partEndLine > endLine) {
					endLine = partEndLine;
				}
			}
		}
		return endLine;
	}
	static findHashComment(node,str) {
		if(node.trailingComments != null) {
			let _g = 0;
			let _g1 = node.trailingComments;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				if(c.isHash) {
					return StringTools.trim(c.content);
				}
			}
		}
		if(node.leadingComments != null) {
			let _g = 0;
			let _g1 = node.leadingComments;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				if(c.isHash) {
					return StringTools.trim(c.content);
				}
			}
		}
		if(str != null) {
			if(str.trailingComments != null) {
				let _g = 0;
				let _g1 = str.trailingComments;
				while(_g < _g1.length) {
					let c = _g1[_g];
					++_g;
					if(c.isHash) {
						return StringTools.trim(c.content);
					}
				}
			}
			if(str.leadingComments != null) {
				let _g = 0;
				let _g1 = str.leadingComments;
				while(_g < _g1.length) {
					let c = _g1[_g];
					++_g;
					if(c.isHash) {
						return StringTools.trim(c.content);
					}
				}
			}
		}
		return null;
	}
	static randomId(rng,length) {
		let buf_b = "";
		let _g = 0;
		let _g1 = length;
		while(_g < _g1) {
			let _ = _g++;
			let c = HxOverrides.cca(loreline_AstUtils.randomId_chars,Math.floor(36 * ((rng.seed = rng.seed * 16807 % 2147483647) / 2147483647 + 0.000000000233)));
			buf_b += String.fromCodePoint(c);
		}
		let result = buf_b;
		let allHex = true;
		let _g2 = 0;
		let _g3 = result.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let c = HxOverrides.cca(result,i);
			if(!(c >= 48 && c <= 57 || c >= 97 && c <= 102)) {
				allHex = false;
				break;
			}
		}
		if(allHex) {
			let pos = Math.floor(length * ((rng.seed = rng.seed * 16807 % 2147483647) / 2147483647 + 0.000000000233));
			let replacement = HxOverrides.cca(loreline_AstUtils.randomId_nonHexChars,Math.floor(loreline_AstUtils.randomId_nonHexChars.length * ((rng.seed = rng.seed * 16807 % 2147483647) / 2147483647 + 0.000000000233)));
			result = HxOverrides.substr(result,0,pos) + String.fromCodePoint(replacement) + HxOverrides.substr(result,pos + 1,null);
		}
		return result;
	}
}
$hxClasses["loreline.AstUtils"] = $hx_exports["loreline"]["AstUtils"] = loreline_AstUtils;
loreline_AstUtils.__name__ = "loreline.AstUtils";
class loreline_Async {
	constructor(func) {
		this.func = func;
	}
}
$hxClasses["loreline.Async"] = loreline_Async;
loreline_Async.__name__ = "loreline.Async";
Object.assign(loreline_Async.prototype, {
	__class__: loreline_Async
});
class loreline_CodeToHscriptStackType {
	static toString(this1) {
		switch(this1) {
		case 0:
			return "ObjectBrace";
		case 1:
			return "ArrayBracket";
		case 2:
			return "Brace";
		case 3:
			return "Indent";
		case 4:
			return "Bracket";
		case 5:
			return "Paren";
		}
	}
}
class loreline_CodeToHscript {
	constructor() {
		this.indentStack = null;
		this.indentLevel = 0;
		this.inControlWithoutParens = false;
		this.inControl = false;
		this.currentPosOffset = 0;
		this.posOffsets = null;
		this.inString = false;
		this.inComment = false;
		this.indent = 0;
		this.length = 0;
		this.lineOutput = null;
		this.output = null;
		this.input = null;
		this.index = 0;
	}
	process(input) {
		input = StringTools.rtrim(input) + "\n//<END>";
		this.input = input;
		this.index = 0;
		this.output = new StringBuf();
		this.lineOutput = new StringBuf();
		this.length = input.length;
		this.indent = 0;
		this.inComment = false;
		this.inString = false;
		this.posOffsets = [];
		this.currentPosOffset = 0;
		this.inControl = false;
		this.inControlWithoutParens = false;
		this.indentStack = [];
		this.indentLevel = 0;
		this.stack = [];
		this.processInput();
		return StringTools.rtrim(this.output.b) + "\n";
	}
	toLorelinePos(funcPos,pmin,pmax) {
		let min = this.inputPosFromProcessedPos(pmin);
		let max = this.inputPosFromProcessedPos(pmax);
		let len = max + 1 - min;
		return funcPos.withOffset(this.input,min,len,funcPos.offset);
	}
	inputPosFromProcessedPos(pos) {
		if(pos < 0) {
			return 0;
		}
		if(pos >= this.posOffsets.length) {
			return this.input.length - 1 - this.posOffsets[this.input.length - 1];
		}
		return pos - this.posOffsets[pos];
	}
	processedPosFromInputPos(pos) {
		if(pos < 0) {
			return 0;
		}
		if(pos >= this.input.length) {
			return this.output.b.length - 1;
		}
		let count = 0;
		let _g = 0;
		let _g1 = this.posOffsets.length;
		while(_g < _g1) {
			let i = _g++;
			if(i - this.posOffsets[i] > pos) {
				return i - 1;
			} else if(i - this.posOffsets[i] == pos) {
				return i;
			}
			count = i;
		}
		return count;
	}
	processInput(until) {
		if(until == null) {
			until = -1;
		}
		let braceLevel = 0;
		let bracketLevel = 0;
		let parenLevel = 0;
		while(this.index < this.length) {
			let c = HxOverrides.cca(this.input,this.index);
			if(c == 34) {
				this.processString();
			} else if(c == 39) {
				this.error("Unexpected single quote");
			} else if(c == 47) {
				let cc = HxOverrides.cca(this.input,this.index + 1);
				if(cc == 47 || cc == 42) {
					this.processComment();
				} else {
					this._add(c,true);
				}
			} else if(c == 13) {
				this._add(c,true);
			} else if(c == 10) {
				this._add(c,true);
			} else if(c == 123) {
				++braceLevel;
				this._add(c,true);
			} else if(c == 125) {
				--braceLevel;
				if(c == until && braceLevel < 0) {
					return;
				} else {
					this._add(c,true);
				}
			} else if(c == 91) {
				++bracketLevel;
				this._add(c,true);
			} else if(c == 93) {
				--bracketLevel;
				if(c == until && bracketLevel < 0) {
					return;
				} else {
					this._add(c,true);
				}
			} else if(c == 40) {
				++parenLevel;
				this._add(c,true);
			} else if(c == 41) {
				--parenLevel;
				if(c == until && parenLevel < 0) {
					return;
				} else {
					this._add(c,true);
				}
			} else if(this.isAlphaNumeric(c) && this.index > 0 && !this.isAlphaNumeric(HxOverrides.cca(this.input,this.index - 1))) {
				if(c == 97) {
					if(HxOverrides.cca(this.input,this.index + 1) == 110 && HxOverrides.cca(this.input,this.index + 2) == 100 && !this.isAlphaNumeric(HxOverrides.cca(this.input,this.index + 3))) {
						this._add(38,true);
						this._add(38,true);
						this._add(32,true);
					} else {
						this._add(c,true);
					}
				} else if(c == 111) {
					if(HxOverrides.cca(this.input,this.index + 1) == 114 && !this.isAlphaNumeric(HxOverrides.cca(this.input,this.index + 2))) {
						this._add(124,true);
						this._add(124,true);
						this._add(32,true);
					} else {
						this._add(c,true);
					}
				} else {
					this._add(c,true);
				}
			} else {
				this._add(c,true);
			}
		}
		if(until == -1) {
			while(this.stack.length > 0 && this.stack[this.stack.length - 1] == 3) {
				this.stack.pop();
				this.indentStack.pop();
				this.currentPosOffset++;
				this.output.b += String.fromCodePoint(32);
				this.posOffsets.push(this.currentPosOffset);
				this.currentPosOffset++;
				this.output.b += String.fromCodePoint(125);
				this.posOffsets.push(this.currentPosOffset);
			}
		}
	}
	processString() {
		this.inString = true;
		this._add(34,true);
		let escaped = false;
		while(this.index < this.length) {
			let c = HxOverrides.cca(this.input,this.index);
			if(escaped) {
				this._add(c,true);
				escaped = false;
			} else if(c == 92) {
				escaped = true;
				this._add(92,true);
			} else if(c == 34) {
				this._add(c,true);
				this.inString = false;
				return;
			} else if(c == 36 && !escaped) {
				this.index++;
				c = HxOverrides.cca(this.input,this.index);
				if(c == 123) {
					this.currentPosOffset--;
					this._add(34,false);
					this._add(43,false);
					this._add(40,true);
					this.inString = false;
					this.processComplexInterpolation();
					this.inString = true;
					this._add(41,true);
					this.currentPosOffset--;
					this._add(43,false);
					this._add(34,false);
					this.currentPosOffset++;
				} else if(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95) {
					this.currentPosOffset--;
					this._add(34,false);
					this._add(43,false);
					this.processFieldAccessInterpolation();
					this.currentPosOffset--;
					this._add(43,false);
					this._add(34,false);
					this.currentPosOffset++;
				} else {
					this.error("Expected identifier or { after $");
				}
			} else {
				this._add(c,true);
			}
		}
		this.error("Unterminated string");
	}
	processComplexInterpolation() {
		this.processInput(125);
	}
	processFieldAccessInterpolation() {
		let c = HxOverrides.cca(this.input,this.index);
		if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
			this.error("Expected identifier in field access");
		}
		this.processIdentifier();
		_hx_loop1: while(this.index < this.length) {
			let _g = HxOverrides.cca(this.input,this.index);
			if(_g == null) {
				break;
			} else {
				switch(_g) {
				case 40:
					this._add(40,true);
					this.processInput(41);
					this._add(41,true);
					break;
				case 46:
					let tmp;
					if(this.index + 1 < this.length) {
						let c = HxOverrides.cca(this.input,this.index + 1);
						tmp = c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95;
					} else {
						tmp = false;
					}
					if(tmp) {
						this._add(46,true);
						this.processIdentifier();
					} else {
						break _hx_loop1;
					}
					break;
				case 91:
					this._add(91,true);
					this.processInput(93);
					break;
				default:
					break _hx_loop1;
				}
			}
		}
	}
	processIdentifier() {
		while(this.index < this.length) {
			let c = HxOverrides.cca(this.input,this.index);
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
				break;
			}
			this._add(c,true);
		}
	}
	isDigit(c) {
		if(c >= 48) {
			return c <= 57;
		} else {
			return false;
		}
	}
	isIdentifierStart(c) {
		if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90)) {
			return c == 95;
		} else {
			return true;
		}
	}
	isIdentifierPart(c) {
		if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
			if(c >= 48) {
				return c <= 57;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	processComment() {
		this.inComment = true;
		let c = HxOverrides.cca(this.input,this.index + 1);
		if(c == 47) {
			this._add(32,true);
			this._add(32,true);
			while(this.index < this.length) {
				let cc = HxOverrides.cca(this.input,this.index);
				if(cc == 13 || cc == 10) {
					break;
				}
				this._add(32,true);
			}
		} else if(c == 42) {
			this._add(32,true);
			this._add(32,true);
			while(this.index < this.length) {
				let cc = HxOverrides.cca(this.input,this.index);
				if(cc == 42 && this.index + 1 < this.length && HxOverrides.cca(this.input,this.index + 1) == 47) {
					this._add(32,true);
					this._add(32,true);
					break;
				} else if(cc == 13 || cc == 10) {
					this._add(cc,true);
				} else {
					this._add(32,true);
				}
			}
		}
		this.inComment = false;
	}
	endsWithChar(line,c) {
		if(line.length == 0) {
			return false;
		}
		let trimmed = StringTools.rtrim(line);
		let len = trimmed.length;
		let result = len > 0 && HxOverrides.cca(trimmed,len - 1) == c;
		return result;
	}
	followsWithChar(c,pos) {
		let tempIndex = pos;
		let result = false;
		while(tempIndex < this.length) {
			let cc = HxOverrides.cca(this.input,tempIndex);
			if(cc == 32 || cc == 9 || cc == 10 || cc == 13) {
				++tempIndex;
				continue;
			}
			if(cc == 47 && tempIndex + 1 < this.length) {
				let nextChar = HxOverrides.cca(this.input,tempIndex + 1);
				if(nextChar == 47) {
					tempIndex += 2;
					while(tempIndex < this.length && HxOverrides.cca(this.input,tempIndex) != 13 && HxOverrides.cca(this.input,tempIndex) != 10) ++tempIndex;
					if(tempIndex < this.length) {
						++tempIndex;
					}
					continue;
				}
				if(nextChar == 42) {
					tempIndex += 2;
					while(tempIndex + 1 < this.length) {
						if(HxOverrides.cca(this.input,tempIndex) == 42 && HxOverrides.cca(this.input,tempIndex + 1) == 47) {
							tempIndex += 2;
							break;
						}
						++tempIndex;
					}
					continue;
				}
			}
			result = cc == c;
			break;
		}
		return result;
	}
	endsOrFollowsWithChar(line,c,pos,hxpos) {
		if(!this.endsWithChar(line,c)) {
			return this.followsWithChar(c,pos);
		} else {
			return true;
		}
	}
	nextLineIndentOffset(line,pos) {
		let currentLine = StringTools.ltrim(line);
		if(currentLine.length == 0) {
			return 0;
		}
		let currentIndent = line.length - currentLine.length;
		let firstSkippedCommentIndent = -1;
		while(pos < this.length) {
			let endLine = this.input.indexOf("\n",pos);
			if(endLine == -1) {
				endLine = this.length;
			}
			let nextLine = this.input.substring(pos,endLine);
			let trimmed = StringTools.ltrim(nextLine);
			if(trimmed.length > 0 && (!trimmed.startsWith("//") || trimmed.startsWith("//<END>")) && !trimmed.startsWith("/*")) {
				let nextIndent = nextLine.length - trimmed.length;
				if(trimmed.startsWith("//<END>") && currentIndent == 0 && firstSkippedCommentIndent > 0) {
					return firstSkippedCommentIndent - currentIndent;
				}
				return nextIndent - currentIndent;
			}
			if(trimmed.length > 0 && firstSkippedCommentIndent == -1) {
				firstSkippedCommentIndent = nextLine.length - trimmed.length;
			}
			pos = endLine + 1;
		}
		if(currentIndent == 0 && firstSkippedCommentIndent > 0) {
			return firstSkippedCommentIndent - currentIndent;
		}
		return 0;
	}
	followsWithIf(pos) {
		let tempIndex = pos;
		while(tempIndex < this.length) {
			let cc = HxOverrides.cca(this.input,tempIndex);
			if(cc == 32 || cc == 9 || cc == 10 || cc == 13) {
				++tempIndex;
				continue;
			}
			if(cc == 47 && tempIndex + 1 < this.length) {
				let nextChar = HxOverrides.cca(this.input,tempIndex + 1);
				if(nextChar == 47) {
					tempIndex += 2;
					while(tempIndex < this.length && HxOverrides.cca(this.input,tempIndex) != 13 && HxOverrides.cca(this.input,tempIndex) != 10) ++tempIndex;
					continue;
				}
				if(nextChar == 42) {
					tempIndex += 2;
					while(tempIndex + 1 < this.length) {
						if(HxOverrides.cca(this.input,tempIndex) == 42 && HxOverrides.cca(this.input,tempIndex + 1) == 47) {
							tempIndex += 2;
							break;
						}
						++tempIndex;
					}
					continue;
				}
			}
			if(tempIndex + 1 < this.length && HxOverrides.cca(this.input,tempIndex) == 105 && HxOverrides.cca(this.input,tempIndex + 1) == 102) {
				if(tempIndex + 2 >= this.length || !this.isAlphaNumeric(HxOverrides.cca(this.input,tempIndex + 2))) {
					return true;
				}
			}
			return false;
		}
		return false;
	}
	endsWithControlKeyword(line,pos) {
		let trimmed = StringTools.rtrim(line);
		if(trimmed.length == 0) {
			return false;
		}
		let _g = 0;
		let _g1 = loreline_CodeToHscript.CONTROL_KEYWORDS;
		while(_g < _g1.length) {
			let keyword = _g1[_g];
			++_g;
			if(trimmed.endsWith(keyword)) {
				let trimmedSize = line.length - trimmed.length;
				let keywordPos = trimmed.length - keyword.length;
				let hasValidPrefix = keywordPos == 0 || !this.isAlphaNumeric(HxOverrides.cca(trimmed,keywordPos - 1));
				let nextPos = pos;
				let hasValidSuffix = nextPos < this.length && (trimmedSize > 0 || !this.isAlphaNumeric(HxOverrides.cca(this.input,nextPos)));
				if(hasValidPrefix && hasValidSuffix) {
					if(keyword != "else" || !this.followsWithIf(pos)) {
						return true;
					}
				}
			}
		}
		return false;
	}
	endsWithArrayIndexable(line) {
		let length = line.length;
		if(length == 0) {
			return false;
		}
		let lastNonWhitespacePos = length - 1;
		while(lastNonWhitespacePos >= 0) {
			let c = HxOverrides.cca(line,lastNonWhitespacePos);
			if(!this.isWhitespace(c)) {
				break;
			}
			--lastNonWhitespacePos;
		}
		if(lastNonWhitespacePos < 0) {
			return false;
		}
		let lastChar = HxOverrides.cca(line,lastNonWhitespacePos);
		if(!(lastChar == 41 || lastChar == 125 || lastChar == 93)) {
			return this.isAlphaNumeric(lastChar);
		} else {
			return true;
		}
	}
	isWhitespace(c) {
		if(!(c == 32 || c == 10 || c == 9)) {
			return c == 13;
		} else {
			return true;
		}
	}
	isAlphaNumeric(c) {
		if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57)) {
			return c == 95;
		} else {
			return true;
		}
	}
	inStatementsBlock() {
		let i = this.stack.length - 1;
		if(i >= 0) {
			if(this.stack[i] != 2) {
				return this.stack[i] == 3;
			} else {
				return true;
			}
		}
		return true;
	}
	inObjectBlock() {
		let i = this.stack.length - 1;
		while(i >= 0) {
			if(this.stack[i] != 3) {
				let res = this.stack[i] == 0;
				return res;
			}
			--i;
		}
		return false;
	}
	inArrayBlock() {
		let i = this.stack.length - 1;
		while(i >= 0) {
			if(this.stack[i] != 3) {
				let res = this.stack[i] == 1;
				return res;
			}
			--i;
		}
		return false;
	}
	isLabelStart(pos) {
		pos = this.skipWhitespaceAndComments(pos);
		let c = HxOverrides.cca(this.input,pos);
		if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
			return false;
		}
		let startPos = pos;
		++pos;
		while(true) {
			let tmp;
			if(pos < this.length) {
				let c = HxOverrides.cca(this.input,pos);
				tmp = c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			++pos;
		}
		while(pos < this.length && this.isWhitespace(HxOverrides.cca(this.input,pos))) ++pos;
		if(pos >= this.length || HxOverrides.cca(this.input,pos) != 58) {
			return false;
		}
		let word = HxOverrides.substr(this.input,startPos,pos - startPos);
		if(word == "case") {
			return false;
		}
		return true;
	}
	skipWhitespaceAndComments(pos) {
		let startPos = pos;
		let foundContent = false;
		while(pos < this.length) {
			while(pos < this.length && (HxOverrides.cca(this.input,pos) == 32 || HxOverrides.cca(this.input,pos) == 9 || HxOverrides.cca(this.input,pos) == 10 || HxOverrides.cca(this.input,pos) == 13)) {
				++pos;
				foundContent = true;
			}
			if(pos < this.length - 1) {
				if(HxOverrides.cca(this.input,pos) == 47) {
					if(HxOverrides.cca(this.input,pos + 1) == 47) {
						pos = startPos;
						return pos;
					} else if(HxOverrides.cca(this.input,pos + 1) == 42) {
						pos += 2;
						foundContent = true;
						let commentClosed = false;
						while(pos < this.length - 1) {
							if(HxOverrides.cca(this.input,pos) == 42 && HxOverrides.cca(this.input,pos + 1) == 47) {
								pos += 2;
								commentClosed = true;
								break;
							}
							++pos;
						}
						if(!commentClosed) {
							pos = startPos;
							return pos;
						}
						continue;
					}
				}
			}
			break;
		}
		if(foundContent) {
			return pos;
		} else {
			return startPos;
		}
	}
	stackPush(item) {
		this.stack.push(item);
	}
	stackPop() {
		return this.stack.pop();
	}
	_add(c,incrementIndex) {
		if(incrementIndex) {
			this.index++;
		} else {
			this.currentPosOffset++;
		}
		if(this.inString) {
			this.lineOutput.b += String.fromCodePoint((c == 34 ? c : 32));
			this.output.b += String.fromCodePoint(c);
			this.posOffsets.push(this.currentPosOffset);
		} else if(c == 13 || c == 10) {
			if(this.inControlWithoutParens) {
				this.inControlWithoutParens = false;
				if(this.stack.pop() != 5) {
					this.error("Unexpected end of line");
				}
				this.currentPosOffset++;
				this.lineOutput.b += String.fromCodePoint(41);
				this.output.b += String.fromCodePoint(41);
				this.posOffsets.push(this.currentPosOffset);
			}
			this.inControl = false;
			let line = this.lineOutput.b;
			this.lineOutput = new StringBuf();
			if(this.inStatementsBlock() || this.inObjectBlock() || this.inArrayBlock()) {
				let indent = this.nextLineIndentOffset(line,this.index);
				if(StringTools.trim(line).length != 0) {
					if(indent > 0 && !this.endsOrFollowsWithChar(line,123,this.index,{ fileName : "src/loreline/CodeToHscript.hx", lineNumber : 1052, className : "loreline.CodeToHscript", methodName : "_add"}) && !this.endsOrFollowsWithChar(line,91,this.index,{ fileName : "src/loreline/CodeToHscript.hx", lineNumber : 1052, className : "loreline.CodeToHscript", methodName : "_add"})) {
						this.stack.push(3);
						this.indentLevel += indent;
						this.indentStack.push(this.indentLevel);
						this.currentPosOffset++;
						this.output.b += String.fromCodePoint(32);
						this.posOffsets.push(this.currentPosOffset);
						this.currentPosOffset++;
						this.output.b += String.fromCodePoint(123);
						this.posOffsets.push(this.currentPosOffset);
					} else if(indent < 0 && this.stack.length > 0 && this.stack[this.stack.length - 1] == 3) {
						if(!this.inObjectBlock() && !this.endsOrFollowsWithChar(line,59,this.index,{ fileName : "src/loreline/CodeToHscript.hx", lineNumber : 1066, className : "loreline.CodeToHscript", methodName : "_add"})) {
							this.currentPosOffset++;
							this.output.b += String.fromCodePoint(59);
							this.posOffsets.push(this.currentPosOffset);
						}
						this.indentLevel += indent;
						let first = true;
						while(this.indentStack[this.indentStack.length - 1] > this.indentLevel && this.stack.length > 0 && this.stack[this.stack.length - 1] == 3) {
							this.stack.pop();
							this.indentStack.pop();
							if(first) {
								first = false;
								this.currentPosOffset++;
								this.output.b += String.fromCodePoint(32);
								this.posOffsets.push(this.currentPosOffset);
							}
							this.currentPosOffset++;
							this.output.b += String.fromCodePoint(125);
							this.posOffsets.push(this.currentPosOffset);
						}
					} else if(indent == 0 && !this.endsOrFollowsWithChar(line,59,this.index,{ fileName : "src/loreline/CodeToHscript.hx", lineNumber : 1089, className : "loreline.CodeToHscript", methodName : "_add"}) && !this.endsOrFollowsWithChar(line,44,this.index,{ fileName : "src/loreline/CodeToHscript.hx", lineNumber : 1089, className : "loreline.CodeToHscript", methodName : "_add"})) {
						if(this.inObjectBlock()) {
							this.currentPosOffset++;
							this.output.b += String.fromCodePoint(44);
							this.posOffsets.push(this.currentPosOffset);
						} else if(this.inArrayBlock()) {
							this.currentPosOffset++;
							this.output.b += String.fromCodePoint(44);
							this.posOffsets.push(this.currentPosOffset);
						} else {
							this.currentPosOffset++;
							this.output.b += String.fromCodePoint(59);
							this.posOffsets.push(this.currentPosOffset);
						}
					}
				}
			}
			this.output.b += String.fromCodePoint(c);
			this.posOffsets.push(this.currentPosOffset);
		} else if(!this.inControl && !this.isWhitespace(c) && this.endsWithControlKeyword(this.lineOutput.b,this.index - 1)) {
			this.inControl = true;
			if(!this.followsWithChar(40,this.index - 1)) {
				this.inControlWithoutParens = true;
				this.stack.push(5);
				this.currentPosOffset++;
				this.lineOutput.b += String.fromCodePoint(c);
				this.output.b += String.fromCodePoint(40);
				this.posOffsets.push(this.currentPosOffset);
			} else if(c == 40) {
				this.stack.push(5);
			}
			this.lineOutput.b += String.fromCodePoint(c);
			this.output.b += String.fromCodePoint(c);
			this.posOffsets.push(this.currentPosOffset);
		} else {
			if(c == 40) {
				this.stack.push(5);
			} else if(c == 41) {
				if(this.stack.pop() != 5) {
					this.error("Unexpected: )");
				}
			} else if(c == 91) {
				if(!this.endsWithArrayIndexable(this.lineOutput.b)) {
					this.stack.push(1);
				} else {
					this.stack.push(4);
				}
			} else if(c == 93) {
				let popped = this.stack.pop();
				if(popped != 4 && popped != 1) {
					this.error("Unexpected: ]");
				}
			} else if(c == 123) {
				if(this.isLabelStart(this.index)) {
					this.stack.push(0);
				} else {
					this.stack.push(2);
				}
			} else if(c == 125) {
				let popped = this.stack.pop();
				if(popped != 2 && popped != 0) {
					this.error("Unexpected: }");
				}
			}
			this.lineOutput.b += String.fromCodePoint(c);
			this.output.b += String.fromCodePoint(c);
			this.posOffsets.push(this.currentPosOffset);
		}
	}
	error(message) {
		throw haxe_Exception.thrown(new loreline_Error(message,loreline_Position.fromContentAndIndex(this.input,this.index)));
	}
}
$hxClasses["loreline.CodeToHscript"] = loreline_CodeToHscript;
loreline_CodeToHscript.__name__ = "loreline.CodeToHscript";
Object.assign(loreline_CodeToHscript.prototype, {
	__class__: loreline_CodeToHscript
});
class loreline_Equal {
	static equal(interpreter,a,b) {
		if(a == b) {
			return true;
		}
		if(loreline_Arrays.isArray(a)) {
			if(loreline_Arrays.isArray(b)) {
				return loreline_Equal.arrayEqual(interpreter,a,b);
			}
			return false;
		} else if(((a) instanceof haxe_ds_StringMap)) {
			if(((b) instanceof haxe_ds_StringMap)) {
				return loreline_Equal.stringMapEqual(interpreter,a,b);
			}
			return false;
		} else if(((a) instanceof haxe_ds_IntMap)) {
			if(((b) instanceof haxe_ds_IntMap)) {
				return loreline_Equal.intMapEqual(interpreter,a,b);
			}
			return false;
		} else if(loreline_Objects.isFields(a)) {
			if(loreline_Objects.isFields(b)) {
				return loreline_Equal.objectFieldsEqual(interpreter,a,b);
			}
			return false;
		}
		return false;
	}
	static objectFieldsEqual(interpreter,a,b) {
		let _g = 0;
		let _g1 = loreline_Objects.getFields(interpreter,a);
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			if(!loreline_Objects.fieldExists(interpreter,b,field) || !loreline_Equal.equal(interpreter,loreline_Objects.getField(interpreter,a,field),loreline_Objects.getField(interpreter,b,field))) {
				return false;
			}
		}
		let _g2 = 0;
		let _g3 = loreline_Objects.getFields(interpreter,b);
		while(_g2 < _g3.length) {
			let field = _g3[_g2];
			++_g2;
			if(!loreline_Objects.fieldExists(interpreter,a,field)) {
				return false;
			}
		}
		return true;
	}
	static arrayEqual(interpreter,a,b) {
		let lenA = loreline_Arrays.arrayLength(a);
		let lenB = loreline_Arrays.arrayLength(b);
		if(lenA != lenB) {
			return false;
		}
		let _g = 0;
		let _g1 = lenA;
		while(_g < _g1) {
			let i = _g++;
			if(!loreline_Equal.equal(interpreter,loreline_Arrays.arrayGet(a,i),loreline_Arrays.arrayGet(b,i))) {
				return false;
			}
		}
		return true;
	}
	static stringMapEqual(interpreter,a,b) {
		let h = a.h;
		let _g_h = h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) {
			let key = _g_keys[_g_current++];
			let _g_key = key;
			let _g_value = _g_h[key];
			let key1 = _g_key;
			let val = _g_value;
			if(!Object.prototype.hasOwnProperty.call(b.h,key1)) {
				return false;
			}
			if(!loreline_Equal.equal(interpreter,b.h[key1],val)) {
				return false;
			}
		}
		let h1 = b.h;
		let _g_h1 = h1;
		let _g_keys1 = Object.keys(h1);
		let _g_length1 = _g_keys1.length;
		let _g_current1 = 0;
		while(_g_current1 < _g_length1) {
			let key = _g_keys1[_g_current1++];
			if(!Object.prototype.hasOwnProperty.call(a.h,key)) {
				return false;
			}
		}
		return true;
	}
	static intMapEqual(interpreter,a,b) {
		let map = a;
		let _g_map = map;
		let _g_keys = map.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = _g_map.get(key);
			let _g_key = key;
			let key1 = _g_key;
			let val = _g_value;
			if(!b.h.hasOwnProperty(key1)) {
				return false;
			}
			if(!loreline_Equal.equal(interpreter,b.h[key1],val)) {
				return false;
			}
		}
		let key = b.keys();
		while(key.hasNext()) {
			let key1 = key.next();
			if(!a.h.hasOwnProperty(key1)) {
				return false;
			}
		}
		return true;
	}
}
$hxClasses["loreline.Equal"] = loreline_Equal;
loreline_Equal.__name__ = "loreline.Equal";
class loreline_Error {
	constructor(message,pos) {
		this.message = message;
		this.pos = pos;
		this.stack = haxe_CallStack.callStack();
	}
	toString() {
		if(this.pos != null) {
			return "" + this.message + " at " + this.pos.toString();
		} else {
			return this.message;
		}
	}
}
$hxClasses["loreline.Error"] = loreline_Error;
loreline_Error.__name__ = "loreline.Error";
Object.assign(loreline_Error.prototype, {
	__class__: loreline_Error
});
class loreline_Fields {
}
$hxClasses["loreline.Fields"] = $hx_exports["loreline"]["Fields"] = loreline_Fields;
loreline_Fields.__name__ = "loreline.Fields";
loreline_Fields.__isInterface__ = true;
Object.assign(loreline_Fields.prototype, {
	__class__: loreline_Fields
});
class loreline_Functions {
	constructor(interpreter) {
		this._random = null;
		this.interpreter = interpreter;
	}
	bindAll(target) {
		target.h["floor"] = $bind(this,this.floor);
		target.h["ceil"] = $bind(this,this.ceil);
		target.h["round"] = $bind(this,this.round);
		target.h["abs"] = $bind(this,this.abs);
		target.h["min"] = $bind(this,this.min);
		target.h["max"] = $bind(this,this.max);
		target.h["clamp"] = $bind(this,this.clamp);
		target.h["pow"] = $bind(this,this.pow);
		target.h["random"] = $bind(this,this.random);
		target.h["chance"] = $bind(this,this.chance);
		target.h["seed_random"] = $bind(this,this.seed_random);
		target.h["random_float"] = $bind(this,this.random_float);
		target.h["wait"] = $bind(this,this.wait);
		target.h["float"] = $bind(this,this.float_);
		target.h["string"] = $bind(this,this.string_);
		target.h["bool"] = $bind(this,this.bool);
		target.h["length"] = $bind(this,this.length);
		target.h["string_upper"] = $bind(this,this.string_upper);
		target.h["string_lower"] = $bind(this,this.string_lower);
		target.h["string_contains"] = $bind(this,this.string_contains);
		target.h["string_replace"] = $bind(this,this.string_replace);
		target.h["string_split"] = $bind(this,this.string_split);
		target.h["string_trim"] = $bind(this,this.string_trim);
		target.h["string_index"] = $bind(this,this.string_index);
		target.h["string_sub"] = $bind(this,this.string_sub);
		target.h["string_starts"] = $bind(this,this.string_starts);
		target.h["string_ends"] = $bind(this,this.string_ends);
		target.h["string_repeat"] = $bind(this,this.string_repeat);
		target.h["plural"] = $bind(this,this.plural);
		target.h["array_add"] = $bind(this,this.array_add);
		target.h["array_pop"] = $bind(this,this.array_pop);
		target.h["array_prepend"] = $bind(this,this.array_prepend);
		target.h["array_shift"] = $bind(this,this.array_shift);
		target.h["array_remove"] = $bind(this,this.array_remove);
		target.h["array_index"] = $bind(this,this.array_index);
		target.h["array_has"] = $bind(this,this.array_has);
		target.h["array_sort"] = $bind(this,this.array_sort);
		target.h["array_reverse"] = $bind(this,this.array_reverse);
		target.h["array_join"] = $bind(this,this.array_join);
		target.h["array_pick"] = $bind(this,this.array_pick);
		target.h["array_shuffle"] = $bind(this,this.array_shuffle);
		target.h["array_copy"] = $bind(this,this.array_copy);
		target.h["map_keys"] = $bind(this,this.map_keys);
		target.h["map_has"] = $bind(this,this.map_has);
		target.h["map_get"] = $bind(this,this.map_get);
		target.h["map_set"] = $bind(this,this.map_set);
		target.h["map_remove"] = $bind(this,this.map_remove);
		target.h["map_copy"] = $bind(this,this.map_copy);
		target.h["current_beat"] = $bind(this,this.current_beat);
		target.h["has_beat"] = $bind(this,this.has_beat);
	}
	rng() {
		if(this._random == null) {
			this._random = new loreline_Random();
		}
		let _this = this._random;
		return (_this.seed = _this.seed * 16807 % 2147483647) / 2147483647 + 0.000000000233;
	}
	floor(n) {
		return Math.floor(n);
	}
	ceil(n) {
		return Math.ceil(n);
	}
	round(n) {
		return Math.round(n);
	}
	abs(n) {
		return Math.abs(n);
	}
	min(a,b) {
		return Math.min(a,b);
	}
	max(a,b) {
		return Math.max(a,b);
	}
	clamp(v,lo,hi) {
		return Math.max(lo,Math.min(hi,v));
	}
	pow(base,exp) {
		return Math.pow(base,exp);
	}
	random(min,max) {
		return Math.floor(min + this.rng() * (max + 1 - min));
	}
	chance(n) {
		return Math.floor(this.rng() * n) == 0;
	}
	seed_random(seed) {
		this._random = new loreline_Random(seed);
		return null;
	}
	random_float(min,max) {
		return min + this.rng() * (max - min);
	}
	wait(seconds) {
		return new loreline_Async(function(done) {
			done();
		});
	}
	float_(value) {
		if(typeof(value) == "number") {
			return value;
		}
		if(typeof(value) == "number" && ((value | 0) === value)) {
			return value * 1.0;
		}
		if(typeof(value) == "string") {
			return parseFloat(value);
		}
		if(typeof(value) == "boolean") {
			if(value) {
				return 1.0;
			} else {
				return 0.0;
			}
		}
		return 0.0;
	}
	string_(value) {
		if(value == null) {
			return "null";
		}
		if(typeof(value) == "string") {
			return value;
		}
		if(value == null) {
			return "null";
		} else {
			return Std.string(value);
		}
	}
	bool(value) {
		if(typeof(value) == "boolean") {
			return value;
		}
		if(typeof(value) == "string") {
			return value.length > 0;
		}
		if(((value) instanceof Array)) {
			return value.length > 0;
		}
		if(typeof(value) == "number" && ((value | 0) === value)) {
			return value != 0;
		}
		if(typeof(value) == "number") {
			return value != 0;
		}
		return value != null;
	}
	length(value) {
		if(typeof(value) == "string") {
			return value.length;
		}
		if(loreline_Arrays.isArray(value)) {
			return loreline_Arrays.arrayLength(value);
		}
		return 0;
	}
	string_upper(text) {
		return text.toUpperCase();
	}
	string_lower(text) {
		return text.toLowerCase();
	}
	string_contains(text,needle) {
		return text.includes(needle);
	}
	string_replace(text,from,to) {
		return StringTools.replace(text,from,to);
	}
	string_split(text,sep) {
		return text.split(sep);
	}
	string_trim(text) {
		return StringTools.trim(text);
	}
	string_index(text,needle) {
		return text.indexOf(needle);
	}
	string_sub(text,start,len) {
		return HxOverrides.substr(text,start | 0,len | 0);
	}
	string_starts(text,prefix) {
		return text.startsWith(prefix);
	}
	string_ends(text,suffix) {
		return text.endsWith(suffix);
	}
	string_repeat(text,count) {
		let result_b = "";
		let i = 0;
		while(i < count) {
			result_b += text == null ? "null" : "" + text;
			++i;
		}
		return result_b;
	}
	plural(count,singular,plural_form) {
		let n = 0;
		if(typeof(count) == "number" && ((count | 0) === count)) {
			n = count * 1.0;
		} else if(typeof(count) == "number") {
			n = count;
		}
		if(n == 1) {
			return singular;
		} else {
			return plural_form;
		}
	}
	array_add(array,value) {
		loreline_Arrays.arrayPush(array,value);
		return null;
	}
	array_pop(array) {
		if(loreline_Arrays.isArray(array)) {
			return loreline_Arrays.arrayPop(array);
		}
		return null;
	}
	array_prepend(array,value) {
		if(loreline_Arrays.isArray(array)) {
			loreline_Arrays.arrayInsert(array,0,value);
		}
		return null;
	}
	array_shift(array) {
		if(loreline_Arrays.isArray(array)) {
			return loreline_Arrays.arrayShift(array);
		}
		return null;
	}
	array_remove(array,value) {
		if(loreline_Arrays.isArray(array)) {
			let len = loreline_Arrays.arrayLength(array);
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				if(loreline_Arrays.arrayGet(array,i) == value) {
					loreline_Arrays.arrayRemoveAt(array,i);
					return true;
				}
			}
		}
		return false;
	}
	array_index(array,value) {
		if(loreline_Arrays.isArray(array)) {
			let len = loreline_Arrays.arrayLength(array);
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				if(loreline_Arrays.arrayGet(array,i) == value) {
					return i;
				}
			}
		}
		return -1;
	}
	array_has(array,value) {
		if(loreline_Arrays.isArray(array)) {
			let len = loreline_Arrays.arrayLength(array);
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				if(loreline_Arrays.arrayGet(array,i) == value) {
					return true;
				}
			}
		}
		return false;
	}
	array_sort(array) {
		if(loreline_Arrays.isArray(array)) {
			loreline_Arrays.arraySort(array,function(a,b) {
				if(typeof(a) == "number" && typeof(b) == "number") {
					if(a < b) {
						return -1;
					} else if(a > b) {
						return 1;
					} else {
						return 0;
					}
				}
				if(typeof(a) == "number" && ((a | 0) === a) && (typeof(b) == "number" && ((b | 0) === b))) {
					if(a < b) {
						return -1;
					} else if(a > b) {
						return 1;
					} else {
						return 0;
					}
				}
				if((a == null ? "null" : Std.string(a)) < (b == null ? "null" : Std.string(b))) {
					return -1;
				} else if((a == null ? "null" : Std.string(a)) > (b == null ? "null" : Std.string(b))) {
					return 1;
				} else {
					return 0;
				}
			});
		}
		return array;
	}
	array_reverse(array) {
		if(loreline_Arrays.isArray(array)) {
			loreline_Arrays.arrayReverse(array);
		}
		return array;
	}
	array_join(array,sep) {
		if(loreline_Arrays.isArray(array)) {
			return loreline_Arrays.arrayJoin(array,sep);
		}
		return "";
	}
	array_pick(array) {
		if(loreline_Arrays.isArray(array)) {
			let len = loreline_Arrays.arrayLength(array);
			if(len == 0) {
				return null;
			}
			let idx = Math.floor(this.rng() * len);
			return loreline_Arrays.arrayGet(array,idx);
		}
		return null;
	}
	array_shuffle(array) {
		if(loreline_Arrays.isArray(array)) {
			let i = loreline_Arrays.arrayLength(array) - 1;
			while(i > 0) {
				let j = Math.floor(this.rng() * (i + 1));
				let tmp = loreline_Arrays.arrayGet(array,i);
				loreline_Arrays.arraySet(array,i,loreline_Arrays.arrayGet(array,j));
				loreline_Arrays.arraySet(array,j,tmp);
				--i;
			}
		}
		return array;
	}
	array_copy(array) {
		if(loreline_Arrays.isArray(array)) {
			return loreline_Arrays.arrayCopy(array);
		}
		return array;
	}
	map_keys(map) {
		return loreline_Objects.getFields(this.interpreter,map);
	}
	map_has(map,key) {
		return loreline_Objects.fieldExists(this.interpreter,map,key);
	}
	map_get(map,key) {
		return loreline_Objects.getField(this.interpreter,map,key);
	}
	map_set(map,key,value) {
		loreline_Objects.setField(this.interpreter,map,key,value);
		return null;
	}
	map_remove(map,key) {
		if(loreline_Objects.fieldExists(this.interpreter,map,key)) {
			loreline_Objects.setField(this.interpreter,map,key,null);
			return true;
		}
		return false;
	}
	map_copy(map) {
		let keys = loreline_Objects.getFields(this.interpreter,map);
		let copy = loreline_Objects.createFields(this.interpreter);
		let _g = 0;
		while(_g < keys.length) {
			let key = keys[_g];
			++_g;
			loreline_Objects.setField(this.interpreter,copy,key,loreline_Objects.getField(this.interpreter,map,key));
		}
		return copy;
	}
	current_beat() {
		let i = this.interpreter.stack.length - 1;
		while(i >= 0) {
			let scope = this.interpreter.stack[i];
			if(scope.beat != null) {
				return scope.beat.name;
			}
			--i;
		}
		return null;
	}
	has_beat(name) {
		let i = this.interpreter.stack.length - 1;
		while(i >= 0) {
			let scope = this.interpreter.stack[i];
			if(scope.beat != null && scope.beat.body != null) {
				let _g = 0;
				let _g1 = scope.beat.body;
				while(_g < _g1.length) {
					let node = _g1[_g];
					++_g;
					if(((node) instanceof loreline_NBeatDecl)) {
						let beatDecl = node;
						if(beatDecl.name == name) {
							return true;
						}
					}
				}
			}
			--i;
		}
		return Object.prototype.hasOwnProperty.call(this.interpreter.topLevelBeats.h,name);
	}
}
$hxClasses["loreline.Functions"] = loreline_Functions;
loreline_Functions.__name__ = "loreline.Functions";
Object.assign(loreline_Functions.prototype, {
	__class__: loreline_Functions
});
var loreline__$HscriptInterp_Stop = $hxEnums["loreline._HscriptInterp.Stop"] = { __ename__:"loreline._HscriptInterp.Stop",__constructs__:null
	,SBreak: {_hx_name:"SBreak",_hx_index:0,__enum__:"loreline._HscriptInterp.Stop",toString:$estr}
	,SContinue: {_hx_name:"SContinue",_hx_index:1,__enum__:"loreline._HscriptInterp.Stop",toString:$estr}
	,SReturn: {_hx_name:"SReturn",_hx_index:2,__enum__:"loreline._HscriptInterp.Stop",toString:$estr}
};
loreline__$HscriptInterp_Stop.__constructs__ = [loreline__$HscriptInterp_Stop.SBreak,loreline__$HscriptInterp_Stop.SContinue,loreline__$HscriptInterp_Stop.SReturn];
class loreline_HscriptInterp {
	constructor(interpreter) {
		this.interpreter = interpreter;
		this.locals = new haxe_ds_StringMap();
		this.declared = [];
		this.resetVariables();
		this.initOps();
	}
	resetVariables() {
		this.variables = new haxe_ds_StringMap();
		this.variables.h["null"] = null;
		this.variables.h["true"] = true;
		this.variables.h["false"] = false;
		let _gthis = this;
		let this1 = this.variables;
		let value = Reflect.makeVarArgs(function(el) {
			let inf = _gthis.posInfos();
			let v = el.shift();
			if(el.length > 0) {
				inf.customParams = el;
			}
			haxe_Log.trace(Std.string(v),inf);
		});
		this1.h["trace"] = value;
	}
	posInfos() {
		if(this.curExpr != null) {
			return { fileName : this.curExpr.origin, lineNumber : this.curExpr.line};
		}
		return { fileName : "hscript", lineNumber : 0};
	}
	initOps() {
		let me = this;
		this.binops = new haxe_ds_StringMap();
		this.binops.h["+"] = function(e1,e2) {
			return me.expr(e1) + me.expr(e2);
		};
		this.binops.h["-"] = function(e1,e2) {
			return me.expr(e1) - me.expr(e2);
		};
		this.binops.h["*"] = function(e1,e2) {
			return me.expr(e1) * me.expr(e2);
		};
		this.binops.h["/"] = function(e1,e2) {
			return me.expr(e1) / me.expr(e2);
		};
		this.binops.h["%"] = function(e1,e2) {
			return me.expr(e1) % me.expr(e2);
		};
		this.binops.h["&"] = function(e1,e2) {
			return me.expr(e1) & me.expr(e2);
		};
		this.binops.h["|"] = function(e1,e2) {
			return me.expr(e1) | me.expr(e2);
		};
		this.binops.h["^"] = function(e1,e2) {
			return me.expr(e1) ^ me.expr(e2);
		};
		this.binops.h["<<"] = function(e1,e2) {
			return me.expr(e1) << me.expr(e2);
		};
		this.binops.h[">>"] = function(e1,e2) {
			return me.expr(e1) >> me.expr(e2);
		};
		this.binops.h[">>>"] = function(e1,e2) {
			return me.expr(e1) >>> me.expr(e2);
		};
		this.binops.h["=="] = function(e1,e2) {
			return me.expr(e1) == me.expr(e2);
		};
		this.binops.h["!="] = function(e1,e2) {
			return me.expr(e1) != me.expr(e2);
		};
		this.binops.h[">="] = function(e1,e2) {
			return me.expr(e1) >= me.expr(e2);
		};
		this.binops.h["<="] = function(e1,e2) {
			return me.expr(e1) <= me.expr(e2);
		};
		this.binops.h[">"] = function(e1,e2) {
			return me.expr(e1) > me.expr(e2);
		};
		this.binops.h["<"] = function(e1,e2) {
			return me.expr(e1) < me.expr(e2);
		};
		this.binops.h["||"] = function(e1,e2) {
			if(me.expr(e1) != true) {
				return me.expr(e2) == true;
			} else {
				return true;
			}
		};
		this.binops.h["&&"] = function(e1,e2) {
			if(me.expr(e1) == true) {
				return me.expr(e2) == true;
			} else {
				return false;
			}
		};
		this.binops.h["="] = $bind(this,this.assign);
		this.binops.h["..."] = function(e1,e2) {
			return new IntIterator(me.expr(e1),me.expr(e2));
		};
		this.binops.h["is"] = function(e1,e2) {
			return js_Boot.__instanceof(me.expr(e1),me.expr(e2));
		};
		this.assignOp("+=",function(v1,v2) {
			return v1 + v2;
		});
		this.assignOp("-=",function(v1,v2) {
			return v1 - v2;
		});
		this.assignOp("*=",function(v1,v2) {
			return v1 * v2;
		});
		this.assignOp("/=",function(v1,v2) {
			return v1 / v2;
		});
		this.assignOp("%=",function(v1,v2) {
			return v1 % v2;
		});
		this.assignOp("&=",function(v1,v2) {
			return v1 & v2;
		});
		this.assignOp("|=",function(v1,v2) {
			return v1 | v2;
		});
		this.assignOp("^=",function(v1,v2) {
			return v1 ^ v2;
		});
		this.assignOp("<<=",function(v1,v2) {
			return v1 << v2;
		});
		this.assignOp(">>=",function(v1,v2) {
			return v1 >> v2;
		});
		this.assignOp(">>>=",function(v1,v2) {
			return v1 >>> v2;
		});
	}
	setVar(name,v) {
		if(!Object.prototype.hasOwnProperty.call(this.variables.h,name)) {
			loreline_Objects.setField(this.interpreter,this.interpreter.topLevelState.fields,name,v);
		} else {
			throw haxe_Exception.thrown("Invalid assign");
		}
		return v;
	}
	assign(e1,e2) {
		let v = this.expr(e2);
		let _g = e1.e;
		switch(_g._hx_index) {
		case 1:
			let id = _g.v;
			let l = this.locals.h[id];
			if(l == null) {
				this.setVar(id,v);
			} else {
				l.r = v;
			}
			break;
		case 5:
			let e = _g.e;
			let f = _g.f;
			v = this.set(this.expr(e),f,v);
			break;
		case 16:
			let e3 = _g.e;
			let index = _g.index;
			let arr = this.expr(e3);
			let index1 = this.expr(index);
			if(loreline_Arrays.isArray(arr)) {
				loreline_Arrays.arraySet(arr,index1,v);
			} else if(loreline_Objects.isFields(arr)) {
				loreline_Objects.setField(this.interpreter,arr,index1,v);
			} else if(js_Boot.__implements(arr,haxe_IMap)) {
				(js_Boot.__cast(arr , haxe_IMap)).set(index1,v);
			} else {
				arr[index1] = v;
			}
			break;
		default:
			let e4 = new hscript_Error(hscript_ErrorDef.EInvalidOp("="),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
			throw haxe_Exception.thrown(e4);
		}
		return v;
	}
	assignOp(op,fop) {
		let me = this;
		this.binops.h[op] = function(e1,e2) {
			return me.evalAssignOp(op,fop,e1,e2);
		};
	}
	evalAssignOp(op,fop,e1,e2) {
		let v;
		let _g = e1.e;
		switch(_g._hx_index) {
		case 1:
			let id = _g.v;
			let l = this.locals.h[id];
			v = fop(this.expr(e1),this.expr(e2));
			if(l == null) {
				this.setVar(id,v);
			} else {
				l.r = v;
			}
			break;
		case 5:
			let e = _g.e;
			let f = _g.f;
			let obj = this.expr(e);
			v = fop(this.get(obj,f),this.expr(e2));
			v = this.set(obj,f,v);
			break;
		case 16:
			let e3 = _g.e;
			let index = _g.index;
			let arr = this.expr(e3);
			let index1 = this.expr(index);
			if(loreline_Arrays.isArray(arr)) {
				v = fop(loreline_Arrays.arrayGet(arr,index1),this.expr(e2));
				loreline_Arrays.arraySet(arr,index1,v);
			} else if(loreline_Objects.isFields(arr)) {
				v = fop(loreline_Objects.getField(this.interpreter,arr,index1),this.expr(e2));
				loreline_Objects.setField(this.interpreter,arr,index1,v);
			} else if(js_Boot.__implements(arr,haxe_IMap)) {
				v = fop((js_Boot.__cast(arr , haxe_IMap)).get(index1),this.expr(e2));
				(js_Boot.__cast(arr , haxe_IMap)).set(index1,v);
			} else {
				v = fop(arr[index1],this.expr(e2));
				arr[index1] = v;
			}
			break;
		default:
			let e4 = new hscript_Error(hscript_ErrorDef.EInvalidOp(op),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
			throw haxe_Exception.thrown(e4);
		}
		return v;
	}
	increment(e,prefix,delta) {
		this.curExpr = e;
		let e1 = e.e;
		switch(e1._hx_index) {
		case 1:
			let id = e1.v;
			let l = this.locals.h[id];
			let v = l == null ? this.resolve(id) : l.r;
			if(prefix) {
				v += delta;
				if(l == null) {
					this.setVar(id,v);
				} else {
					l.r = v;
				}
			} else if(l == null) {
				this.setVar(id,v + delta);
			} else {
				l.r = v + delta;
			}
			return v;
		case 5:
			let e2 = e1.e;
			let f = e1.f;
			let obj = this.expr(e2);
			let v1 = this.get(obj,f);
			if(prefix) {
				v1 += delta;
				this.set(obj,f,v1);
			} else {
				this.set(obj,f,v1 + delta);
			}
			return v1;
		case 16:
			let e3 = e1.e;
			let index = e1.index;
			let arr = this.expr(e3);
			let index1 = this.expr(index);
			if(loreline_Arrays.isArray(arr)) {
				let v = loreline_Arrays.arrayGet(arr,index1);
				if(prefix) {
					v += delta;
					loreline_Arrays.arraySet(arr,index1,v);
				} else {
					loreline_Arrays.arraySet(arr,index1,v + delta);
				}
				return v;
			} else if(loreline_Objects.isFields(arr)) {
				let v = loreline_Objects.getField(this.interpreter,arr,index1);
				if(prefix) {
					v += delta;
					loreline_Objects.setField(this.interpreter,arr,index1,v);
				} else {
					loreline_Objects.setField(this.interpreter,arr,index1,v + delta);
				}
				return v;
			} else if(js_Boot.__implements(arr,haxe_IMap)) {
				let v = (js_Boot.__cast(arr , haxe_IMap)).get(index1);
				if(prefix) {
					v += delta;
					(js_Boot.__cast(arr , haxe_IMap)).set(index1,v);
				} else {
					(js_Boot.__cast(arr , haxe_IMap)).set(index1,v + delta);
				}
				return v;
			} else {
				let v = arr[index1];
				if(prefix) {
					v += delta;
					arr[index1] = v;
				} else {
					arr[index1] = v + delta;
				}
				return v;
			}
			break;
		default:
			let e4 = new hscript_Error(hscript_ErrorDef.EInvalidOp(delta > 0 ? "++" : "--"),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
			throw haxe_Exception.thrown(e4);
		}
	}
	execute(expr) {
		this.depth = 0;
		this.locals = new haxe_ds_StringMap();
		this.declared = [];
		return this.exprReturn(expr);
	}
	exprReturn(e) {
		try {
			return this.expr(e);
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(js_Boot.__instanceof(_g1,loreline__$HscriptInterp_Stop)) {
				let e = _g1;
				switch(e._hx_index) {
				case 0:
					throw haxe_Exception.thrown("Invalid break");
				case 1:
					throw haxe_Exception.thrown("Invalid continue");
				case 2:
					let v = this.returnValue;
					this.returnValue = null;
					return v;
				}
			} else {
				throw _g;
			}
		}
	}
	duplicate(h) {
		let h2 = new haxe_ds_StringMap();
		let h1 = h.h;
		let k_h = h1;
		let k_keys = Object.keys(h1);
		let k_length = k_keys.length;
		let k_current = 0;
		while(k_current < k_length) {
			let k = k_keys[k_current++];
			h2.h[k] = h.h[k];
		}
		return h2;
	}
	restore(old) {
		while(this.declared.length > old) {
			let d = this.declared.pop();
			this.locals.h[d.n] = d.old;
		}
	}
	error(e,rethrow) {
		if(rethrow == null) {
			rethrow = false;
		}
		let e1 = new hscript_Error(e,this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
		if(rethrow) {
			throw haxe_Exception.thrown(e1);
		} else {
			throw haxe_Exception.thrown(e1);
		}
	}
	rethrow(e) {
		throw haxe_Exception.thrown(e);
	}
	resolve(id) {
		let v = this.variables.h[id];
		if(v == null && !Object.prototype.hasOwnProperty.call(this.variables.h,id)) {
			if(loreline_Objects.fieldExists(this.interpreter,this.interpreter.topLevelState.fields,id)) {
				return loreline_Objects.getField(this.interpreter,this.interpreter.topLevelState.fields,id);
			}
			if(Object.prototype.hasOwnProperty.call(this.interpreter.topLevelCharacters.h,id)) {
				return this.interpreter.topLevelCharacters.h[id].fields;
			}
			if(Object.prototype.hasOwnProperty.call(this.interpreter.topLevelFunctions.h,id)) {
				return this.interpreter.topLevelFunctions.h[id];
			}
			let e = new hscript_Error(hscript_ErrorDef.EUnknownVariable(id),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
			throw haxe_Exception.thrown(e);
		}
		return v;
	}
	expr(e) {
		this.curExpr = e;
		let e1 = e.e;
		let _gthis = this;
		switch(e1._hx_index) {
		case 0:
			let c = e1.c;
			switch(c._hx_index) {
			case 0:
				let v = c.v;
				return v;
			case 1:
				let f = c.f;
				return f;
			case 2:
				let s = c.s;
				return s;
			}
			break;
		case 1:
			let id = e1.v;
			let l = this.locals.h[id];
			if(l != null) {
				return l.r;
			}
			return this.resolve(id);
		case 2:
			let _g = e1.t;
			let n = e1.n;
			let e2 = e1.e;
			this.declared.push({ n : n, old : this.locals.h[n]});
			let this1 = this.locals;
			let value = e2 == null ? null : this.expr(e2);
			this1.h[n] = { r : value};
			return null;
		case 3:
			let e3 = e1.e;
			return this.expr(e3);
		case 4:
			let exprs = e1.e;
			let old = this.declared.length;
			let v1 = null;
			let _g1 = 0;
			while(_g1 < exprs.length) {
				let e = exprs[_g1];
				++_g1;
				v1 = this.expr(e);
			}
			this.restore(old);
			return v1;
		case 5:
			let e4 = e1.e;
			let f1 = e1.f;
			return this.get(this.expr(e4),f1);
		case 6:
			let op = e1.op;
			let e11 = e1.e1;
			let e21 = e1.e2;
			let fop = this.binops.h[op];
			if(fop == null) {
				let e = new hscript_Error(hscript_ErrorDef.EInvalidOp(op),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
				throw haxe_Exception.thrown(e);
			}
			return fop(e11,e21);
		case 7:
			let op1 = e1.op;
			let prefix = e1.prefix;
			let e5 = e1.e;
			switch(op1) {
			case "!":
				return this.expr(e5) != true;
			case "++":
				return this.increment(e5,prefix,1);
			case "-":
				return -this.expr(e5);
			case "--":
				return this.increment(e5,prefix,-1);
			case "~":
				return ~this.expr(e5);
			default:
				let e6 = new hscript_Error(hscript_ErrorDef.EInvalidOp(op1),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
				throw haxe_Exception.thrown(e6);
			}
			break;
		case 8:
			let e7 = e1.e;
			let params = e1.params;
			let args = [];
			let _g2 = 0;
			while(_g2 < params.length) {
				let p = params[_g2];
				++_g2;
				args.push(this.expr(p));
			}
			let _g3 = e7.e;
			if(_g3._hx_index == 5) {
				let e = _g3.e;
				let f = _g3.f;
				let obj = this.expr(e);
				if(obj == null) {
					let e = new hscript_Error(hscript_ErrorDef.EInvalidAccess(f),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
					throw haxe_Exception.thrown(e);
				}
				return this.fcall(obj,f,args);
			} else {
				return this.call(null,this.expr(e7),args);
			}
			break;
		case 9:
			let econd = e1.cond;
			let e12 = e1.e1;
			let e22 = e1.e2;
			if(this.expr(econd) == true) {
				return this.expr(e12);
			} else if(e22 == null) {
				return null;
			} else {
				return this.expr(e22);
			}
			break;
		case 10:
			let econd1 = e1.cond;
			let e8 = e1.e;
			this.whileLoop(econd1,e8);
			return null;
		case 11:
			let v2 = e1.v;
			let it = e1.it;
			let e9 = e1.e;
			this.forLoop(v2,it,e9);
			return null;
		case 12:
			throw haxe_Exception.thrown(loreline__$HscriptInterp_Stop.SBreak);
		case 13:
			throw haxe_Exception.thrown(loreline__$HscriptInterp_Stop.SContinue);
		case 14:
			let _g4 = e1.ret;
			let params1 = e1.args;
			let fexpr = e1.e;
			let name = e1.name;
			let capturedLocals = this.duplicate(this.locals);
			let me = this;
			let hasOpt = false;
			let minParams = 0;
			let _g5 = 0;
			while(_g5 < params1.length) {
				let p = params1[_g5];
				++_g5;
				if(p.opt) {
					hasOpt = true;
				} else {
					minParams += 1;
				}
			}
			let f2 = function(args) {
				if((args == null ? 0 : args.length) != params1.length) {
					if(args.length < minParams) {
						let str = "Invalid number of parameters. Got " + args.length + ", required " + minParams;
						if(name != null) {
							str += " for function '" + name + "'";
						}
						let e = new hscript_Error(hscript_ErrorDef.ECustom(str),_gthis.curExpr.pmin,_gthis.curExpr.pmax,_gthis.curExpr.origin,_gthis.curExpr.line);
						throw haxe_Exception.thrown(e);
					}
					let args2 = [];
					let extraParams = args.length - minParams;
					let pos = 0;
					let _g = 0;
					while(_g < params1.length) {
						let p = params1[_g];
						++_g;
						if(p.opt) {
							if(extraParams > 0) {
								args2.push(args[pos++]);
								--extraParams;
							} else {
								args2.push(null);
							}
						} else {
							args2.push(args[pos++]);
						}
					}
					args = args2;
				}
				let old = me.locals;
				let depth = me.depth;
				me.depth++;
				me.locals = me.duplicate(capturedLocals);
				let _g = 0;
				let _g1 = params1.length;
				while(_g < _g1) {
					let i = _g++;
					me.locals.h[params1[i].name] = { r : args[i]};
				}
				let r = null;
				let oldDecl = _gthis.declared.length;
				if(_gthis.inTry) {
					try {
						r = me.exprReturn(fexpr);
					} catch( _g ) {
						let e = haxe_Exception.caught(_g).unwrap();
						_gthis.restore(oldDecl);
						me.locals = old;
						me.depth = depth;
						throw haxe_Exception.thrown(e);
					}
				} else {
					r = me.exprReturn(fexpr);
				}
				_gthis.restore(oldDecl);
				me.locals = old;
				me.depth = depth;
				return r;
			};
			let f3 = Reflect.makeVarArgs(f2);
			if(name != null) {
				if(this.depth == 0) {
					this.variables.h[name] = f3;
				} else {
					this.declared.push({ n : name, old : this.locals.h[name]});
					let ref = { r : f3};
					this.locals.h[name] = ref;
					capturedLocals.h[name] = ref;
				}
			}
			return f3;
		case 15:
			let e10 = e1.e;
			this.returnValue = e10 == null ? null : this.expr(e10);
			throw haxe_Exception.thrown(loreline__$HscriptInterp_Stop.SReturn);
		case 16:
			let e13 = e1.e;
			let index = e1.index;
			let arr = this.expr(e13);
			let index1 = this.expr(index);
			if(loreline_Arrays.isArray(arr)) {
				return loreline_Arrays.arrayGet(arr,index1);
			} else if(loreline_Objects.isFields(arr)) {
				return loreline_Objects.getField(this.interpreter,arr,index1);
			} else if(js_Boot.__implements(arr,haxe_IMap)) {
				return (js_Boot.__cast(arr , haxe_IMap)).get(index1);
			}
			return arr[index1];
		case 17:
			let arr1 = e1.e;
			let tmp;
			if(arr1.length > 0) {
				let _g = arr1[0].e;
				if(_g._hx_index == 6) {
					let _g1 = _g.e1;
					let _g2 = _g.e2;
					tmp = _g.op == "=>";
				} else {
					tmp = false;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				let keys = [];
				let values = [];
				let _g = 0;
				while(_g < arr1.length) {
					let e = arr1[_g];
					++_g;
					let _g1 = e.e;
					if(_g1._hx_index == 6) {
						if(_g1.op == "=>") {
							let eKey = _g1.e1;
							let eValue = _g1.e2;
							keys.push(this.expr(eKey));
							values.push(this.expr(eValue));
						} else {
							this.curExpr = e;
							let e1 = new hscript_Error(hscript_ErrorDef.ECustom("Invalid map key=>value expression"),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
							throw haxe_Exception.thrown(e1);
						}
					} else {
						this.curExpr = e;
						let e1 = new hscript_Error(hscript_ErrorDef.ECustom("Invalid map key=>value expression"),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
						throw haxe_Exception.thrown(e1);
					}
				}
				return this.makeMap(keys,values);
			} else {
				let a = [];
				let _g = 0;
				while(_g < arr1.length) {
					let e = arr1[_g];
					++_g;
					a.push(this.expr(e));
				}
				return a;
			}
			break;
		case 18:
			let cl = e1.cl;
			let params2 = e1.params;
			let a = [];
			let _g6 = 0;
			while(_g6 < params2.length) {
				let e = params2[_g6];
				++_g6;
				a.push(this.expr(e));
			}
			return this.cnew(cl,a);
		case 19:
			let e14 = e1.e;
			throw haxe_Exception.thrown(this.expr(e14));
		case 20:
			let _g7 = e1.t;
			let e15 = e1.e;
			let n1 = e1.v;
			let ecatch = e1.ecatch;
			let old1 = this.declared.length;
			let oldTry = this.inTry;
			try {
				this.inTry = true;
				let v = this.expr(e15);
				this.restore(old1);
				this.inTry = oldTry;
				return v;
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g).unwrap();
				if(js_Boot.__instanceof(_g1,loreline__$HscriptInterp_Stop)) {
					let err = _g1;
					this.inTry = oldTry;
					throw haxe_Exception.thrown(err);
				} else {
					let err = _g1;
					this.restore(old1);
					this.inTry = oldTry;
					this.declared.push({ n : n1, old : this.locals.h[n1]});
					this.locals.h[n1] = { r : err};
					let v = this.expr(ecatch);
					this.restore(old1);
					return v;
				}
			}
			break;
		case 21:
			let fl = e1.fl;
			let o = loreline_Objects.createFields(this.interpreter);
			let _g8 = 0;
			while(_g8 < fl.length) {
				let f = fl[_g8];
				++_g8;
				loreline_Objects.setField(this.interpreter,o,f.name,this.expr(f.e));
			}
			return o;
		case 22:
			let econd2 = e1.cond;
			let e16 = e1.e1;
			let e23 = e1.e2;
			if(this.expr(econd2) == true) {
				return this.expr(e16);
			} else {
				return this.expr(e23);
			}
			break;
		case 23:
			let e17 = e1.e;
			let cases = e1.cases;
			let def = e1.defaultExpr;
			let val = this.expr(e17);
			let match = false;
			let _g9 = 0;
			while(_g9 < cases.length) {
				let c = cases[_g9];
				++_g9;
				let _g = 0;
				let _g1 = c.values;
				while(_g < _g1.length) {
					let v = _g1[_g];
					++_g;
					if(this.expr(v) == val) {
						match = true;
						break;
					}
				}
				if(match) {
					val = this.expr(c.expr);
					break;
				}
			}
			if(!match) {
				val = def == null ? null : this.expr(def);
			}
			return val;
		case 24:
			let econd3 = e1.cond;
			let e18 = e1.e;
			this.doWhileLoop(econd3,e18);
			return null;
		case 25:
			let _g10 = e1.name;
			let _g11 = e1.args;
			let e19 = e1.e;
			return this.expr(e19);
		case 26:
			let _g12 = e1.t;
			let e20 = e1.e;
			return this.expr(e20);
		}
	}
	doWhileLoop(econd,e) {
		let old = this.declared.length;
		let _gthis = this;
		do {
			let cont = true;
			try {
				_gthis.expr(e);
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g).unwrap();
				if(js_Boot.__instanceof(_g1,loreline__$HscriptInterp_Stop)) {
					let err = _g1;
					switch(err._hx_index) {
					case 0:
						cont = false;
						break;
					case 1:
						break;
					case 2:
						throw haxe_Exception.thrown(err);
					}
				} else {
					throw _g;
				}
			}
			if(!cont) {
				break;
			}
		} while(this.expr(econd) == true);
		this.restore(old);
	}
	whileLoop(econd,e) {
		let old = this.declared.length;
		let _gthis = this;
		while(this.expr(econd) == true) {
			let cont = true;
			try {
				_gthis.expr(e);
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g).unwrap();
				if(js_Boot.__instanceof(_g1,loreline__$HscriptInterp_Stop)) {
					let err = _g1;
					switch(err._hx_index) {
					case 0:
						cont = false;
						break;
					case 1:
						break;
					case 2:
						throw haxe_Exception.thrown(err);
					}
				} else {
					throw _g;
				}
			}
			if(!cont) {
				break;
			}
		}
		this.restore(old);
	}
	makeIterator(v) {
		if(((v) instanceof Array)) {
			return new haxe_iterators_ArrayIterator(v);
		}
		if(loreline_Arrays.isArray(v)) {
			return loreline_Arrays.getIterator(v);
		}
		if(v.iterator != null) {
			v = $getIterator(v);
		}
		if(v.hasNext == null || v.next == null) {
			let e = new hscript_Error(hscript_ErrorDef.EInvalidIterator(v),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
			throw haxe_Exception.thrown(e);
		}
		return v;
	}
	forLoop(n,it,e) {
		let old = this.declared.length;
		this.declared.push({ n : n, old : this.locals.h[n]});
		let it1 = this.makeIterator(this.expr(it));
		let _gthis = this;
		while(it1.hasNext()) {
			let this1 = this.locals;
			let value = { r : it1.next()};
			this1.h[n] = value;
			let cont = true;
			try {
				_gthis.expr(e);
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g).unwrap();
				if(js_Boot.__instanceof(_g1,loreline__$HscriptInterp_Stop)) {
					let err = _g1;
					switch(err._hx_index) {
					case 0:
						cont = false;
						break;
					case 1:
						break;
					case 2:
						throw haxe_Exception.thrown(err);
					}
				} else {
					throw _g;
				}
			}
			if(!cont) {
				break;
			}
		}
		this.restore(old);
	}
	loopRun(f) {
		let cont = true;
		try {
			f();
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(js_Boot.__instanceof(_g1,loreline__$HscriptInterp_Stop)) {
				let err = _g1;
				switch(err._hx_index) {
				case 0:
					cont = false;
					break;
				case 1:
					break;
				case 2:
					throw haxe_Exception.thrown(err);
				}
			} else {
				throw _g;
			}
		}
		return cont;
	}
	isMap(o) {
		return js_Boot.__implements(o,haxe_IMap);
	}
	getMapValue(map,key) {
		return (js_Boot.__cast(map , haxe_IMap)).get(key);
	}
	setMapValue(map,key,value) {
		(js_Boot.__cast(map , haxe_IMap)).set(key,value);
	}
	makeMap(keys,values) {
		let isAllString = true;
		let isAllInt = true;
		let isAllObject = true;
		let isAllEnum = true;
		let _g = 0;
		while(_g < keys.length) {
			let key = keys[_g];
			++_g;
			isAllString = isAllString && typeof(key) == "string";
			isAllInt = isAllInt && (typeof(key) == "number" && ((key | 0) === key));
			isAllObject = isAllObject && Reflect.isObject(key);
			isAllEnum = isAllEnum && Reflect.isEnumValue(key);
		}
		if(isAllInt) {
			let m = new haxe_ds_IntMap();
			let _g_current = 0;
			let _g_array = keys;
			while(_g_current < _g_array.length) {
				let _g_value = _g_array[_g_current];
				let _g_key = _g_current++;
				let i = _g_key;
				let key = _g_value;
				m.h[key] = values[i];
			}
			return m;
		}
		if(isAllString) {
			let m = new haxe_ds_StringMap();
			let _g_current = 0;
			let _g_array = keys;
			while(_g_current < _g_array.length) {
				let _g_value = _g_array[_g_current];
				let _g_key = _g_current++;
				let i = _g_key;
				let key = _g_value;
				m.h[key] = values[i];
			}
			return m;
		}
		if(isAllEnum) {
			let m = new haxe_ds_EnumValueMap();
			let _g_current = 0;
			let _g_array = keys;
			while(_g_current < _g_array.length) {
				let _g_value = _g_array[_g_current];
				let _g_key = _g_current++;
				let i = _g_key;
				let key = _g_value;
				m.set(key,values[i]);
			}
			return m;
		}
		if(isAllObject) {
			let m = new haxe_ds_ObjectMap();
			let _g_current = 0;
			let _g_array = keys;
			while(_g_current < _g_array.length) {
				let _g_value = _g_array[_g_current];
				let _g_key = _g_current++;
				let i = _g_key;
				let key = _g_value;
				m.set(key,values[i]);
			}
			return m;
		}
		let e = new hscript_Error(hscript_ErrorDef.ECustom("Invalid map keys " + Std.string(keys)),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
		throw haxe_Exception.thrown(e);
	}
	get(o,f) {
		if(o == null) {
			let e = new hscript_Error(hscript_ErrorDef.EInvalidAccess(f),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
			throw haxe_Exception.thrown(e);
		}
		if(loreline_Objects.isFields(o)) {
			return loreline_Objects.getField(this.interpreter,o,f);
		}
		return Reflect.getProperty(o,f);
	}
	set(o,f,v) {
		if(o == null) {
			let e = new hscript_Error(hscript_ErrorDef.EInvalidAccess(f),this.curExpr.pmin,this.curExpr.pmax,this.curExpr.origin,this.curExpr.line);
			throw haxe_Exception.thrown(e);
		}
		if(loreline_Objects.isFields(o)) {
			loreline_Objects.setField(this.interpreter,o,f,v);
			return v;
		}
		Reflect.setProperty(o,f,v);
		return v;
	}
	fcall(o,f,args) {
		return this.call(o,this.get(o,f),args);
	}
	call(o,f,args) {
		return f.apply(o,args);
	}
	cnew(cl,args) {
		let c = $hxClasses[cl];
		if(c == null) {
			c = this.resolve(cl);
		}
		return Type.createInstance(c,args);
	}
}
$hxClasses["loreline.HscriptInterp"] = loreline_HscriptInterp;
loreline_HscriptInterp.__name__ = "loreline.HscriptInterp";
Object.assign(loreline_HscriptInterp.prototype, {
	__class__: loreline_HscriptInterp
});
class loreline__$Imports_ImportsLoopInfo {
	constructor(finished) {
		this.finished = finished;
	}
}
$hxClasses["loreline._Imports.ImportsLoopInfo"] = loreline__$Imports_ImportsLoopInfo;
loreline__$Imports_ImportsLoopInfo.__name__ = "loreline._Imports.ImportsLoopInfo";
Object.assign(loreline__$Imports_ImportsLoopInfo.prototype, {
	__class__: loreline__$Imports_ImportsLoopInfo
});
class loreline_Imports {
	constructor() {
		this.ext = ".lor";
		this.pendingImports = 0;
		this.hasErrors = false;
		this.done = null;
		this.resolvedImports = null;
		this.autoAddExtension = true;
	}
	resolve(rootPath,tokens,handleFile,handleError,done) {
		this.rootPath = rootPath;
		this.tokens = tokens;
		this.handleFile = handleFile;
		this.handleError = handleError;
		this.done = done;
		this.hasErrors = false;
		this.pendingImports = 0;
		if(rootPath != null && rootPath.endsWith(".lor.txt")) {
			this.ext = ".lor.txt";
		}
		let resolvedImports = new haxe_ds_StringMap();
		let toImport = [];
		let visitedImports = new haxe_ds_StringMap();
		let cwd = haxe_io_Path.directory(rootPath);
		this.extractImports(cwd,tokens,toImport,visitedImports);
		this.processImports(toImport,visitedImports,resolvedImports);
	}
	processImports(toImport,visitedImports,resolvedImports) {
		let loopInfo = new loreline__$Imports_ImportsLoopInfo(false);
		while(toImport.length > 0) {
			let item = toImport.shift();
			this.handleItemInLoop(item,loopInfo,toImport,visitedImports,resolvedImports);
		}
		loopInfo.finished = true;
		if(this.pendingImports == 0 && this.done != null) {
			this.resolvedImports = resolvedImports;
			this.done(this.hasErrors,resolvedImports);
			this.done = null;
		}
	}
	handleItemInLoop(item,loopInfo,toImport,visitedImports,resolvedImports) {
		let _gthis = this;
		this.handleFile(item,function(data) {
			_gthis.pendingImports--;
			if(data != null) {
				try {
					let lexer = new loreline_Lexer(data);
					let tokens = lexer.tokenize();
					let lexerErrors = lexer.getErrors();
					if(lexerErrors != null && lexerErrors.length > 0) {
						_gthis.handleError(lexerErrors[0]);
					}
					resolvedImports.h[item] = tokens;
					_gthis.extractImports(haxe_io_Path.directory(item),tokens,toImport,visitedImports);
					if(loopInfo.finished) {
						_gthis.processImports(toImport,visitedImports,resolvedImports);
					}
				} catch( _g ) {
					let e = haxe_Exception.caught(_g).unwrap();
					_gthis.hasErrors = true;
					if(((e) instanceof loreline_Error)) {
						_gthis.handleError(e);
					} else {
						throw haxe_Exception.thrown(e);
					}
				}
			} else {
				_gthis.hasErrors = true;
			}
			if(loopInfo.finished && _gthis.pendingImports == 0 && _gthis.done != null) {
				_gthis.resolvedImports = resolvedImports;
				_gthis.done(_gthis.hasErrors,resolvedImports);
				_gthis.done = null;
			}
		});
	}
	extractImports(cwd,tokens,toImport,visitedImports) {
		let i = 0;
		let len = tokens.length;
		while(i < len - 1) {
			if(tokens[i].type == loreline_TokenType.KwImport) {
				let _g = tokens[i + 1].type;
				if(_g._hx_index == 9) {
					let _g1 = _g.quotes;
					let _g2 = _g.attachments;
					let s = _g.s;
					let path = s;
					if(!haxe_io_Path.isAbsolute(s)) {
						path = haxe_io_Path.join([cwd,path]);
					}
					path = haxe_io_Path.normalize(path);
					if(!path.toLowerCase().endsWith(this.ext)) {
						path += this.ext;
					}
					if(!Object.prototype.hasOwnProperty.call(visitedImports.h,path)) {
						this.pendingImports++;
						visitedImports.h[path] = true;
						toImport.push(path);
					}
				}
			}
			++i;
		}
	}
}
$hxClasses["loreline.Imports"] = loreline_Imports;
loreline_Imports.__name__ = "loreline.Imports";
Object.assign(loreline_Imports.prototype, {
	__class__: loreline_Imports
});
class loreline_Int64Map {
	constructor() {
		this.mask = 0;
		this.size = 0;
		this._values = null;
		this._keys2 = null;
		this._keys1 = null;
		let oldK1 = this._keys1;
		let oldK2 = this._keys2;
		let oldVals = this._values;
		this._keys1 = new Array(16);
		this._keys2 = new Array(16);
		this._values = new Array(16);
		this.mask = 15;
		if(oldK1 != null) {
			this.size = 0;
			let _g = 0;
			let _g1 = oldK1.length;
			while(_g < _g1) {
				let i = _g++;
				if(oldVals[i] != null) {
					this._set(oldK1[i],oldK2[i],oldVals[i]);
				}
			}
		}
	}
	resize(newCapacity) {
		let oldK1 = this._keys1;
		let oldK2 = this._keys2;
		let oldVals = this._values;
		this._keys1 = new Array(newCapacity);
		this._keys2 = new Array(newCapacity);
		this._values = new Array(newCapacity);
		this.mask = newCapacity - 1;
		if(oldK1 != null) {
			this.size = 0;
			let _g = 0;
			let _g1 = oldK1.length;
			while(_g < _g1) {
				let i = _g++;
				if(oldVals[i] != null) {
					this._set(oldK1[i],oldK2[i],oldVals[i]);
				}
			}
		}
	}
	hashCoords(high,low) {
		let h = high + (low << 16);
		h = (h ^ h >>> 16) * -2048144789;
		h = (h ^ h >>> 13) * -1028477387;
		return h ^ h >>> 16;
	}
	clear() {
		this._keys1 = null;
		this._keys2 = null;
		this._values = null;
		let oldK1 = this._keys1;
		let oldK2 = this._keys2;
		let oldVals = this._values;
		this._keys1 = new Array(16);
		this._keys2 = new Array(16);
		this._values = new Array(16);
		this.mask = 15;
		if(oldK1 != null) {
			this.size = 0;
			let _g = 0;
			let _g1 = oldK1.length;
			while(_g < _g1) {
				let i = _g++;
				if(oldVals[i] != null) {
					this._set(oldK1[i],oldK2[i],oldVals[i]);
				}
			}
		}
		this.size = 0;
	}
	copy() {
		let result = new loreline_Int64Map();
		let this1 = this._keys1;
		let r = new Array(this1.length);
		haxe_ds_Vector.blit(this1,0,r,0,this1.length);
		result._keys1 = r;
		let this2 = this._keys2;
		let r1 = new Array(this2.length);
		haxe_ds_Vector.blit(this2,0,r1,0,this2.length);
		result._keys2 = r1;
		let this3 = this._values;
		let r2 = new Array(this3.length);
		haxe_ds_Vector.blit(this3,0,r2,0,this3.length);
		result._values = r2;
		result.size = this.size;
		result.mask = this.mask;
		return result;
	}
	_set(high,low,value) {
		if(this.size >= (this.mask + 1) * 0.75) {
			let newCapacity = this.mask + 1 << 1;
			let oldK1 = this._keys1;
			let oldK2 = this._keys2;
			let oldVals = this._values;
			this._keys1 = new Array(newCapacity);
			this._keys2 = new Array(newCapacity);
			this._values = new Array(newCapacity);
			this.mask = newCapacity - 1;
			if(oldK1 != null) {
				this.size = 0;
				let _g = 0;
				let _g1 = oldK1.length;
				while(_g < _g1) {
					let i = _g++;
					if(oldVals[i] != null) {
						this._set(oldK1[i],oldK2[i],oldVals[i]);
					}
				}
			}
		}
		let h = high + (low << 16);
		h = (h ^ h >>> 16) * -2048144789;
		h = (h ^ h >>> 13) * -1028477387;
		let hash = h ^ h >>> 16;
		let index = hash & this.mask;
		while(true) {
			if(this._values[index] == null) {
				this._keys1[index] = high;
				this._keys2[index] = low;
				this._values[index] = value;
				this.size++;
				return;
			}
			if(this._keys1[index] == high && this._keys2[index] == low) {
				this._values[index] = value;
				return;
			}
			index = index + 1 & this.mask;
		}
	}
	_get(high,low) {
		let h = high + (low << 16);
		h = (h ^ h >>> 16) * -2048144789;
		h = (h ^ h >>> 13) * -1028477387;
		let hash = h ^ h >>> 16;
		let index = hash & this.mask;
		while(true) {
			if(this._values[index] == null) {
				return null;
			}
			if(this._keys1[index] == high && this._keys2[index] == low) {
				return this._values[index];
			}
			index = index + 1 & this.mask;
		}
	}
	_exists(high,low) {
		let h = high + (low << 16);
		h = (h ^ h >>> 16) * -2048144789;
		h = (h ^ h >>> 13) * -1028477387;
		let hash = h ^ h >>> 16;
		let index = hash & this.mask;
		while(true) {
			if(this._values[index] == null) {
				return false;
			}
			if(this._keys1[index] == high && this._keys2[index] == low) {
				return true;
			}
			index = index + 1 & this.mask;
		}
	}
	_remove(high,low) {
		let h = high + (low << 16);
		h = (h ^ h >>> 16) * -2048144789;
		h = (h ^ h >>> 13) * -1028477387;
		let hash = h ^ h >>> 16;
		let index = hash & this.mask;
		while(true) {
			if(this._values[index] == null) {
				return false;
			}
			if(this._keys1[index] == high && this._keys2[index] == low) {
				this._values[index] = null;
				this.size--;
				index = index + 1 & this.mask;
				while(this._values[index] != null) {
					let k1 = this._keys1[index];
					let k2 = this._keys2[index];
					let v = this._values[index];
					this._values[index] = null;
					this.size--;
					this._set(k1,k2,v);
					index = index + 1 & this.mask;
				}
				return true;
			}
			index = index + 1 & this.mask;
		}
	}
	iterator() {
		return new loreline__$Int64Map_Int64MapIterator(this);
	}
	keyIterator() {
		return new loreline__$Int64Map_Int64MapKeyIterator(this);
	}
	keyValueIterator() {
		return new loreline__$Int64Map_Int64MapKeyValueIterator(this);
	}
	length() {
		return this.size;
	}
}
$hxClasses["loreline.Int64Map"] = loreline_Int64Map;
loreline_Int64Map.__name__ = "loreline.Int64Map";
Object.assign(loreline_Int64Map.prototype, {
	__class__: loreline_Int64Map
});
class loreline__$Int64Map_Int64MapIterator {
	constructor(map) {
		this.map = map;
		this.index = 0;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	skipNulls() {
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	hasNext() {
		return this.index < this.map._values.length;
	}
	next() {
		let v = this.map._values[this.index];
		this.index++;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
		return v;
	}
}
$hxClasses["loreline._Int64Map.Int64MapIterator"] = loreline__$Int64Map_Int64MapIterator;
loreline__$Int64Map_Int64MapIterator.__name__ = "loreline._Int64Map.Int64MapIterator";
Object.assign(loreline__$Int64Map_Int64MapIterator.prototype, {
	__class__: loreline__$Int64Map_Int64MapIterator
});
class loreline__$Int64Map_Int64MapKeyIterator {
	constructor(map) {
		this.map = map;
		this.index = 0;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	skipNulls() {
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	hasNext() {
		return this.index < this.map._values.length;
	}
	next() {
		let k1 = this.map._keys1[this.index];
		let k2 = this.map._keys2[this.index];
		this.index++;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
		return { high : k1, low : k2};
	}
}
$hxClasses["loreline._Int64Map.Int64MapKeyIterator"] = loreline__$Int64Map_Int64MapKeyIterator;
loreline__$Int64Map_Int64MapKeyIterator.__name__ = "loreline._Int64Map.Int64MapKeyIterator";
Object.assign(loreline__$Int64Map_Int64MapKeyIterator.prototype, {
	__class__: loreline__$Int64Map_Int64MapKeyIterator
});
class loreline__$Int64Map_Int64MapKeyValueIterator {
	constructor(map) {
		this.map = map;
		this.index = 0;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	skipNulls() {
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	hasNext() {
		return this.index < this.map._values.length;
	}
	next() {
		let k1 = this.map._keys1[this.index];
		let k2 = this.map._keys2[this.index];
		let v = this.map._values[this.index];
		this.index++;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
		return { key : { high : k1, low : k2}, value : v};
	}
}
$hxClasses["loreline._Int64Map.Int64MapKeyValueIterator"] = loreline__$Int64Map_Int64MapKeyValueIterator;
loreline__$Int64Map_Int64MapKeyValueIterator.__name__ = "loreline._Int64Map.Int64MapKeyValueIterator";
Object.assign(loreline__$Int64Map_Int64MapKeyValueIterator.prototype, {
	__class__: loreline__$Int64Map_Int64MapKeyValueIterator
});
class loreline_RuntimeState {
	constructor(interpreter,node,fields,originalFields) {
		this.scope = -1;
		if(fields != null) {
			this.fields = fields;
		} else {
			this.clear(interpreter,node);
		}
		if(originalFields != null) {
			this.originalFields = originalFields;
		} else {
			this.createOriginalFields();
		}
	}
	clear(interpreter,node) {
		this.fields = loreline_Objects.createFields(interpreter,null,node);
	}
	createOriginalFields() {
		this.originalFields = loreline_Objects.createFields();
	}
}
$hxClasses["loreline.RuntimeState"] = loreline_RuntimeState;
loreline_RuntimeState.__name__ = "loreline.RuntimeState";
Object.assign(loreline_RuntimeState.prototype, {
	__class__: loreline_RuntimeState
});
class loreline_RuntimeCharacter extends loreline_RuntimeState {
	constructor(interpreter,node,fields,originalFields) {
		super(interpreter,node,fields,originalFields);
	}
}
$hxClasses["loreline.RuntimeCharacter"] = loreline_RuntimeCharacter;
loreline_RuntimeCharacter.__name__ = "loreline.RuntimeCharacter";
loreline_RuntimeCharacter.__super__ = loreline_RuntimeState;
Object.assign(loreline_RuntimeCharacter.prototype, {
	__class__: loreline_RuntimeCharacter
});
var loreline_RuntimeAccess = $hxEnums["loreline.RuntimeAccess"] = { __ename__:"loreline.RuntimeAccess",__constructs__:null
	,FieldAccess: ($_=function(pos,obj,name) { return {_hx_index:0,pos:pos,obj:obj,name:name,__enum__:"loreline.RuntimeAccess",toString:$estr}; },$_._hx_name="FieldAccess",$_.__params__ = ["pos","obj","name"],$_)
	,ArrayAccess: ($_=function(pos,array,index) { return {_hx_index:1,pos:pos,array:array,index:index,__enum__:"loreline.RuntimeAccess",toString:$estr}; },$_._hx_name="ArrayAccess",$_.__params__ = ["pos","array","index"],$_)
	,CharacterAccess: ($_=function(pos,name) { return {_hx_index:2,pos:pos,name:name,__enum__:"loreline.RuntimeAccess",toString:$estr}; },$_._hx_name="CharacterAccess",$_.__params__ = ["pos","name"],$_)
	,FunctionAccess: ($_=function(pos,name) { return {_hx_index:3,pos:pos,name:name,__enum__:"loreline.RuntimeAccess",toString:$estr}; },$_._hx_name="FunctionAccess",$_.__params__ = ["pos","name"],$_)
};
loreline_RuntimeAccess.__constructs__ = [loreline_RuntimeAccess.FieldAccess,loreline_RuntimeAccess.ArrayAccess,loreline_RuntimeAccess.CharacterAccess,loreline_RuntimeAccess.FunctionAccess];
class loreline_RuntimeScope {
	constructor(id,beat,node,beats,state,head,insertion) {
		this.insertion = null;
		this.head = null;
		this.state = null;
		this.beats = null;
		this.id = -1;
		if(id != null) {
			this.id = id;
		}
		this.beat = beat;
		this.node = node;
		if(beats != null) {
			this.beats = beats;
		}
		if(state != null) {
			this.state = state;
		}
		if(head != null) {
			this.head = head;
		}
		if(insertion != null) {
			this.insertion = insertion;
		}
	}
	beatByName(name) {
		if(this.beats == null) {
			return null;
		}
		let _g = 0;
		let _g1 = this.beats.length;
		while(_g < _g1) {
			let i = _g++;
			let beat = this.beats[i];
			if(beat.name == name) {
				return beat;
			}
		}
		return null;
	}
}
$hxClasses["loreline.RuntimeScope"] = loreline_RuntimeScope;
loreline_RuntimeScope.__name__ = "loreline.RuntimeScope";
Object.assign(loreline_RuntimeScope.prototype, {
	__class__: loreline_RuntimeScope
});
class loreline_RuntimeInsertion {
	constructor(id,origin) {
		this.stack = [];
		this.options = null;
		this.id = id;
		this.origin = origin;
	}
}
$hxClasses["loreline.RuntimeInsertion"] = loreline_RuntimeInsertion;
loreline_RuntimeInsertion.__name__ = "loreline.RuntimeInsertion";
Object.assign(loreline_RuntimeInsertion.prototype, {
	__class__: loreline_RuntimeInsertion
});
class loreline_TextTag {
	constructor(closing,value,offset) {
		this.closing = closing;
		this.value = value;
		this.offset = offset;
	}
}
$hxClasses["loreline.TextTag"] = loreline_TextTag;
loreline_TextTag.__name__ = "loreline.TextTag";
Object.assign(loreline_TextTag.prototype, {
	__class__: loreline_TextTag
});
class loreline_ChoiceOption {
	constructor(text,tags,enabled,node,insertion) {
		this.text = text;
		this.tags = tags;
		this.enabled = enabled;
		this.node = node;
		this.insertion = insertion;
	}
}
$hxClasses["loreline.ChoiceOption"] = loreline_ChoiceOption;
loreline_ChoiceOption.__name__ = "loreline.ChoiceOption";
Object.assign(loreline_ChoiceOption.prototype, {
	__class__: loreline_ChoiceOption
});
class loreline_RuntimeError extends loreline_Error {
	constructor(message,pos) {
		super(message,pos);
	}
}
$hxClasses["loreline.RuntimeError"] = loreline_RuntimeError;
loreline_RuntimeError.__name__ = "loreline.RuntimeError";
loreline_RuntimeError.__super__ = loreline_Error;
Object.assign(loreline_RuntimeError.prototype, {
	__class__: loreline_RuntimeError
});
class loreline_EvalNext {
	constructor() {
		this.cb = null;
		this.sync = true;
	}
}
$hxClasses["loreline.EvalNext"] = loreline_EvalNext;
loreline_EvalNext.__name__ = "loreline.EvalNext";
Object.assign(loreline_EvalNext.prototype, {
	__class__: loreline_EvalNext
});
class loreline_Interpreter {
	constructor(script,handleDialogue,handleChoice,handleFinish,options) {
		this.beatToResume = null;
		this.finishTrigger = null;
		this.flushing = false;
		this.syncCallbacks = [];
		this.nextInsertionId = 1;
		this.nextScopeId = 1;
		this.stack = [];
		this.stringLiteralProcessors = [];
		this.mapHelpers = new haxe_ds_StringMap();
		this.arrayHelpers = new haxe_ds_StringMap();
		this.stringHelpers = new haxe_ds_StringMap();
		this.topLevelFunctions = new haxe_ds_StringMap();
		this.nodeStates = new loreline_NodeIdMap();
		this.topLevelBeats = new haxe_ds_StringMap();
		this.topLevelCharacters = new haxe_ds_StringMap();
		this.script = script;
		this.handleDialogue = handleDialogue;
		this.handleChoice = handleChoice;
		this.handleFinish = handleFinish;
		this.lens = new loreline_Lens(script);
		let tmp = options != null ? options.strictAccess : null;
		this.strictAccess = tmp != null && tmp;
		this.translations = options != null ? options.translations : null;
		this.topLevelState = new loreline_RuntimeState(this,script,null,null);
		this.initializeTopLevelFunctions(options != null ? options.functions : null);
		this.initializeStringLiteralProcessors(options != null ? options.stringLiteralProcessors : null);
		let decl = script.iterator();
		while(decl.hasNext()) {
			let decl1 = decl.next();
			switch(js_Boot.getClass(decl1)) {
			case loreline_NBeatDecl:
				this.initializeTopLevelBeat(decl1);
				break;
			case loreline_NCharacterDecl:
				this.initializeTopLevelCharacter(decl1);
				break;
			case loreline_NFunctionDecl:
				this.initializeTopLevelFunction(decl1);
				break;
			case loreline_NStateDecl:
				this.initializeTopLevelState(decl1);
				break;
			default:
			}
		}
	}
	get_currentScope() {
		if(this.stack.length > 0) {
			return this.stack[this.stack.length - 1];
		} else {
			return null;
		}
	}
	get_currentInsertion() {
		let i = this.stack.length - 1;
		while(i >= 0) {
			let scope = this.stack[i];
			if(scope.insertion != null) {
				return scope.insertion;
			}
			--i;
		}
		return null;
	}
	removeCurrentInsertion() {
		let i = this.stack.length - 1;
		while(i >= 0) {
			let scope = this.stack[i];
			if(scope.insertion != null) {
				scope.insertion = null;
				break;
			}
			--i;
		}
	}
	start(beatName) {
		let resolvedBeat = null;
		if(beatName != null) {
			resolvedBeat = this.topLevelBeats.h[beatName];
			if(resolvedBeat == null) {
				throw haxe_Exception.thrown(new loreline_RuntimeError("Beat " + beatName + " not found",this.script.pos));
			}
		} else {
			let decl = this.script.iterator();
			while(decl.hasNext()) {
				let decl1 = decl.next();
				if(((decl1) instanceof loreline_NBeatDecl)) {
					let beat = decl1;
					if(beat.name == "_") {
						resolvedBeat = beat;
					}
					break;
				}
			}
			if(resolvedBeat == null) {
				let decl = this.script.iterator();
				while(decl.hasNext()) {
					let decl1 = decl.next();
					if(((decl1) instanceof loreline_NBeatDecl)) {
						resolvedBeat = decl1;
						break;
					}
				}
			}
			if(resolvedBeat == null) {
				throw haxe_Exception.thrown(new loreline_RuntimeError("No beats found in script",this.script.pos));
			}
		}
		this.transitionToBeat(resolvedBeat);
		this.flush();
	}
	save() {
		let insertions = { };
		let _g = [];
		let _g1 = 0;
		let _g2 = this.stack;
		while(_g1 < _g2.length) {
			let scope = _g2[_g1];
			++_g1;
			_g.push(this.serializeScope(scope,insertions));
		}
		let result = { version : 1, stack : _g, state : this.serializeState(this.topLevelState), characters : this.serializeCharacters(), nodeStates : this.serializeNodeStates()};
		if(Reflect.fields(insertions).length > 0) {
			result.insertions = insertions;
		}
		return result;
	}
	restore(saveData) {
		if(saveData.version != 1) {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Unsupported save version: " + saveData.version,this.script.pos));
		}
		this.stack.length = 0;
		this.nodeStates.map.clear();
		this.nextScopeId = 1;
		this.nextInsertionId = 1;
		this.restoreState(this.topLevelState,saveData.state);
		this.restoreCharacters(saveData.characters);
		this.restoreNodeStates(saveData.nodeStates);
		if(!this.restoreStack(saveData.stack,saveData.insertions)) {
			this.beatToResume = this.restoreBeatToResume(saveData.stack);
		}
	}
	resume() {
		if(this.stack.length == 0) {
			this.start();
			return;
		}
		let done = this.wrapNext($bind(this,this.finish));
		this.finishTrigger = done;
		this.resumeNode(this.stack[0].node,0,done.cb);
		done.sync = false;
		this.flush();
	}
	resumeFromLevel(scopeLevel,next) {
		let done = this.wrapNext(next);
		this.finishTrigger = done;
		this.resumeNode(this.stack[scopeLevel].node,scopeLevel,done.cb);
		done.sync = false;
	}
	getCharacter(name) {
		let tmp = this.topLevelCharacters.h[name];
		if(tmp != null) {
			return tmp.fields;
		} else {
			return null;
		}
	}
	getCharacterField(character,name) {
		let tmp = this.topLevelCharacters.h[character];
		let fields = tmp != null ? tmp.fields : null;
		if(fields != null) {
			return loreline_Objects.getField(this,fields,name);
		}
		return null;
	}
	setCharacterField(character,name,value) {
		let fields = this.topLevelCharacters.h[character].fields;
		loreline_Objects.setField(this,fields,name,value);
	}
	serializeScope(scope,insertions) {
		let result = { id : scope.id};
		if(scope.beat != null) {
			result.beat = this.serializeBeatReference(scope.beat);
		}
		if(scope.node != null) {
			result.node = this.serializeNodeReference(scope.node);
		}
		if(scope.state != null) {
			result.state = this.serializeState(scope.state);
		}
		if(scope.beats != null) {
			let _g = [];
			let _g1 = 0;
			let _g2 = scope.beats;
			while(_g1 < _g2.length) {
				let beat = _g2[_g1];
				++_g1;
				_g.push(this.serializeBeatReference(beat));
			}
			result.beats = _g;
		}
		if(scope.head != null) {
			result.head = this.serializeNodeReference(scope.head);
		}
		if(scope.insertion != null) {
			result.insertion = this.serializeInsertion(scope.insertion,insertions);
		}
		return result;
	}
	serializeInsertion(insertion,insertions) {
		let key = insertion.id == null ? "null" : "" + insertion.id;
		let serialized = Reflect.field(insertions,key);
		if(serialized == null) {
			serialized = { };
			if(insertion.options != null) {
				let _g = [];
				let _g1 = 0;
				let _g2 = insertion.options;
				while(_g1 < _g2.length) {
					let opt = _g2[_g1];
					++_g1;
					_g.push(this.serializeChoiceOption(opt,insertions));
				}
				serialized.options = _g;
			}
			if(insertion.origin != null) {
				serialized.origin = this.serializeNodeReference(insertion.origin);
			}
			if(insertion.stack != null) {
				let _g = [];
				let _g1 = 0;
				let _g2 = insertion.stack;
				while(_g1 < _g2.length) {
					let scope = _g2[_g1];
					++_g1;
					_g.push(this.serializeScope(scope,insertions));
				}
				serialized.stack = _g;
			}
			insertions[key] = serialized;
		}
		return insertion.id;
	}
	serializeChoiceOption(option,insertions) {
		let result = { text : option.text};
		if(!option.enabled) {
			result.disabled = true;
		}
		if(option.tags != null) {
			let _g = [];
			let _g1 = 0;
			let _g2 = option.tags;
			while(_g1 < _g2.length) {
				let tag = _g2[_g1];
				++_g1;
				_g.push(this.serializeTextTag(tag));
			}
			result.tags = _g;
		}
		if(option.node != null) {
			result.node = this.serializeNodeReference(option.node);
		}
		if(option.insertion != null) {
			result.insertion = this.serializeInsertion(option.insertion,insertions);
		}
		return result;
	}
	serializeTextTag(tag) {
		let result = { value : tag.value, offset : tag.offset};
		if(tag.closing) {
			result.closing = true;
		}
		return result;
	}
	serializeState(state) {
		return this.serializeFields(state.fields,state.originalFields);
	}
	serializeCharacters() {
		let result = { };
		let h = this.topLevelCharacters.h;
		let _g_h = h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) {
			let key = _g_keys[_g_current++];
			let _g_key = key;
			let _g_value = _g_h[key];
			let name = _g_key;
			let character = _g_value;
			let serialized = this.serializeCharacter(character);
			if(Reflect.fields(serialized.fields).length > 0) {
				result[name] = serialized;
			}
		}
		return result;
	}
	serializeNodeStates() {
		let result = { };
		let _g_map = this.nodeStates.map;
		let _g_index = 0;
		while(_g_index < _g_map._values.length && _g_map._values[_g_index] == null) ++_g_index;
		while(_g_index < _g_map._values.length) {
			let k1 = _g_map._keys1[_g_index];
			let k2 = _g_map._keys2[_g_index];
			let v = _g_map._values[_g_index];
			++_g_index;
			while(_g_index < _g_map._values.length && _g_map._values[_g_index] == null) ++_g_index;
			let _g_key = loreline_NodeId.fromTwoInt32(k1,k2);
			let _g_value = v;
			let id = _g_key;
			let state = _g_value;
			let serialized = this.serializeState(state);
			if(Reflect.fields(serialized.fields).length > 0) {
				result[id.toString()] = serialized;
			}
		}
		return result;
	}
	serializeBeatReference(beat) {
		let path = beat.name;
		let parentBeat = beat;
		do {
			parentBeat = this.lens.getFirstParentOfType(parentBeat,loreline_NBeatDecl);
			if(parentBeat != null) {
				path = parentBeat.name + "." + path;
			}
		} while(parentBeat != null);
		return { id : beat.id.toString(), path : path};
	}
	serializeNodeReference(node) {
		return { id : node.id.toString(), type : node.type()};
	}
	serializeCharacter(character) {
		return this.serializeFields(character.fields,character.originalFields);
	}
	serializeFields(fields,originalFields) {
		let type = null;
		let result = { };
		if(js_Boot.__implements(fields,loreline_Fields)) {
			let cls = js_Boot.getClass(fields);
			if(cls != null) {
				type = cls.__name__;
			}
			let fieldMap = fields;
			let _g = 0;
			let _g1 = fieldMap.lorelineFields(this);
			while(_g < _g1.length) {
				let key = _g1[_g];
				++_g;
				result[key] = this.serializeValue(fieldMap.lorelineGet(this,key));
			}
		} else if(((fields) instanceof haxe_ds_StringMap)) {
			let map = fields;
			let h = map.h;
			let _g_h = h;
			let _g_keys = Object.keys(h);
			let _g_length = _g_keys.length;
			let _g_current = 0;
			while(_g_current < _g_length) {
				let key = _g_keys[_g_current++];
				let value = map.h[key];
				if(originalFields == null || !loreline_Objects.fieldExists(this,originalFields,key) || !loreline_Equal.equal(this,loreline_Objects.getField(this,originalFields,key),value)) {
					result[key] = this.serializeValue(value);
				}
			}
		} else {
			let cls = js_Boot.getClass(fields);
			if(cls != null) {
				type = cls.__name__;
			}
			let _g = 0;
			let _g1 = Reflect.fields(fields);
			while(_g < _g1.length) {
				let field = _g1[_g];
				++_g;
				let value = Reflect.getProperty(fields,field);
				if(originalFields == null || !loreline_Objects.fieldExists(this,originalFields,field) || !loreline_Equal.equal(this,loreline_Objects.getField(this,originalFields,field),value)) {
					result[field] = this.serializeValue(value);
				}
			}
		}
		if(type != null) {
			return { type : type, fields : result};
		} else {
			return { fields : result};
		}
	}
	serializeValue(value) {
		if(value == null) {
			return null;
		}
		if(typeof(value) == "string" || typeof(value) == "number" || typeof(value) == "number" && ((value | 0) === value) || typeof(value) == "boolean") {
			return value;
		}
		if(loreline_Arrays.isArray(value)) {
			let arr = [];
			let len = loreline_Arrays.arrayLength(value);
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				arr.push(this.serializeValue(loreline_Arrays.arrayGet(value,i)));
			}
			return arr;
		}
		return this.serializeFields(value);
	}
	resumeNode(node,scopeLevel,next) {
		let lastLevel = this.stack.length - 1;
		let isLastNode = scopeLevel >= this.stack.length;
		if(!isLastNode) {
			switch(js_Boot.getClass(node)) {
			case loreline_NBeatDecl:
				this.resumeBeatRun(node,scopeLevel,next);
				break;
			case loreline_NCall:
				if(this.isBeatCall(node,scopeLevel)) {
					this.resumeCall(node,scopeLevel,next);
				} else {
					let c = js_Boot.getClass(node);
					throw haxe_Exception.thrown(new loreline_RuntimeError("Resume execution not supported from node within stack: " + c.__name__,node.pos));
				}
				break;
			case loreline_NChoiceOption:
				this.resumeChoiceOption(node,scopeLevel,next);
				break;
			case loreline_NChoiceStatement:
				this.resumeChoice(node,scopeLevel,next);
				break;
			case loreline_NIfStatement:
				this.resumeIf(node,scopeLevel,next);
				break;
			default:
				let c = js_Boot.getClass(node);
				throw haxe_Exception.thrown(new loreline_RuntimeError("Resume execution not supported from node within stack: " + c.__name__,node.pos));
			}
		} else {
			switch(js_Boot.getClass(node)) {
			case loreline_NCall:
				if(!this.isBeatCall(node)) {
					this.evalCall(node,next);
				} else {
					let c = js_Boot.getClass(node);
					throw haxe_Exception.thrown(new loreline_RuntimeError("Resume execution not supported from last node: " + c.__name__,node.pos));
				}
				break;
			case loreline_NChoiceStatement:
				this.evalChoice(node,next);
				break;
			case loreline_NDialogueStatement:
				this.evalDialogue(node,next);
				break;
			case loreline_NTextStatement:
				this.evalText(node,next);
				break;
			default:
				let c1 = js_Boot.getClass(node);
				throw haxe_Exception.thrown(new loreline_RuntimeError("Resume execution not supported from last node: " + c1.__name__,node.pos));
			}
		}
	}
	resumeNodeBody(node,scopeLevel,body,next) {
		let currentScope = this.stack[scopeLevel];
		let index = 0;
		let resumeIndex = -1;
		if(currentScope.head == null && scopeLevel < this.stack.length - 1) {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Cannot resume through a body with a no-headed scope that is not at the bottom of the stack",node.pos));
		}
		if(currentScope.head != null) {
			index = body.indexOf(currentScope.head);
			resumeIndex = index;
			if(index == -1) {
				throw haxe_Exception.thrown(new loreline_RuntimeError("Failed to resolve head in scope when resuming through body",node.pos));
			}
		}
		let moveNext = null;
		let _gthis = this;
		moveNext = function() {
			if(index != -1 && index == resumeIndex) {
				let childNode = body[index];
				index += 1;
				let done = _gthis.wrapNext(moveNext);
				_gthis.resumeNode(childNode,scopeLevel + 1,done.cb);
				done.sync = false;
			} else if(index < body.length) {
				let childNode = body[index];
				currentScope.head = childNode;
				index += 1;
				let done = _gthis.wrapNext(moveNext);
				_gthis.evalNode(childNode,done.cb);
				done.sync = false;
			} else {
				_gthis.pop();
				next();
			}
		};
		moveNext();
	}
	resumeBeatRun(beat,scopeLevel,next) {
		this.resumeNodeBody(beat,scopeLevel,beat.body,next);
	}
	resumeChoiceOption(option,scopeLevel,next) {
		this.resumeNodeBody(option,scopeLevel,option.body,next);
	}
	resumeChoice(choice,scopeLevel,next) {
		let currentScope = this.stack[scopeLevel];
		if(currentScope.head == null) {
			this.evalChoice(choice,next);
		} else if(((currentScope.head) instanceof loreline_NChoiceOption)) {
			let option = currentScope.head;
			this.evalNodeBody(currentScope.beat,option,option.body,null,next);
		} else if(currentScope.insertion != null) {
			while(this.stack.length > scopeLevel) this.pop();
			this.evalChoice(choice,next);
		} else {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Choice head is not a choice option",currentScope.head.pos));
		}
	}
	resumeIf(ifStmt,scopeLevel,next) {
		let currentScope = this.stack[scopeLevel];
		if(currentScope.head == null) {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Failed to resolve head in scope when resuming through condition",ifStmt.pos));
		}
		let isTrue = ifStmt.thenBranch.body.indexOf(currentScope.head) != -1;
		let branch = isTrue ? ifStmt.thenBranch : ifStmt.elseBranch;
		if(branch != null && branch.body.length > 0) {
			this.resumeNodeBody(branch,scopeLevel,branch.body,next);
		} else {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Failed to resume condition: invalid scope",ifStmt.pos));
		}
	}
	resumeCall(call,scopeLevel,next) {
		if(((call.target) instanceof loreline_NAccess)) {
			let access = call.target;
			if(access.target == null) {
				let beatName = access.name;
				let resolvedBeat = null;
				let i = this.stack.length - 1;
				while(i >= 0) {
					let scope = this.stack[i];
					let beatInScope = scope.beatByName(beatName);
					if(beatInScope != null) {
						resolvedBeat = beatInScope;
						break;
					}
					--i;
				}
				if(resolvedBeat == null && Object.prototype.hasOwnProperty.call(this.topLevelBeats.h,beatName)) {
					resolvedBeat = this.topLevelBeats.h[beatName];
				}
				if(resolvedBeat != null) {
					this.resumeBeatRun(resolvedBeat,scopeLevel,next);
					return;
				}
			}
		}
		throw haxe_Exception.thrown(new loreline_RuntimeError("Cannot resume through a function call that is not at the bottom of the stack",call.pos));
	}
	restoreStack(savedStack,savedInsertions) {
		let result = [];
		let restoredInsertions = new haxe_ds_IntMap();
		let i = savedStack.length - 1;
		while(i >= 0) {
			let scope = this.restoreScopeItem(savedStack[i],savedInsertions,restoredInsertions);
			if(scope == null) {
				return false;
			}
			result.push(scope);
			--i;
		}
		i = result.length - 1;
		while(i >= 0) {
			this.push(result[i]);
			--i;
		}
		return true;
	}
	restoreScopeItem(savedScope,savedInsertions,restoredInsertions) {
		let beat = this.restoreBeat(savedScope.beat);
		if(beat == null) {
			return null;
		}
		let savedBeatId = loreline_NodeId.fromString(savedScope.beat.id);
		let savedNode = savedScope.node;
		let node = savedNode != null ? this.restoreNode(savedNode,savedBeatId,beat) : null;
		if(savedNode != null && node == null) {
			return null;
		}
		let beats = [];
		if(savedScope.beats != null) {
			let _g = 0;
			let _g1 = savedScope.beats;
			while(_g < _g1.length) {
				let savedBeat = _g1[_g];
				++_g;
				let beatInScope = this.restoreBeat(savedBeat);
				if(beatInScope == null) {
					return null;
				}
				beats.push(beatInScope);
			}
		}
		let savedState = savedScope.state;
		let state = savedState != null ? this.restoreState(null,savedScope.state) : null;
		let savedHead = savedScope.head;
		let head = savedHead != null ? this.restoreNode(savedHead,savedBeatId,beat) : null;
		if(savedHead != null && head == null) {
			return null;
		}
		let insertion = null;
		if(savedScope.insertion != null && savedInsertions != null) {
			insertion = this.restoreInsertion(savedScope.insertion,savedInsertions,restoredInsertions);
		}
		return new loreline_RuntimeScope(null,beat,node,beats,state,head,insertion);
	}
	restoreInsertion(insertionId,savedInsertions,restoredInsertions) {
		if(restoredInsertions.h.hasOwnProperty(insertionId)) {
			return restoredInsertions.h[insertionId];
		}
		let key = insertionId == null ? "null" : "" + insertionId;
		let saved = Reflect.field(savedInsertions,key);
		if(saved == null) {
			return null;
		}
		let origin = null;
		if(saved.origin != null) {
			let nodeId = loreline_NodeId.fromString(saved.origin.id);
			let node = this.lens.getNodeById(nodeId);
			if(node != null && node.type() == saved.origin.type) {
				origin = node;
			}
		}
		let insertion = new loreline_RuntimeInsertion(insertionId,origin);
		restoredInsertions.h[insertionId] = insertion;
		if(insertionId >= this.nextInsertionId) {
			this.nextInsertionId = insertionId + 1;
		}
		if(saved.options != null) {
			insertion.options = [];
			let _g = 0;
			let _g1 = saved.options;
			while(_g < _g1.length) {
				let savedOpt = _g1[_g];
				++_g;
				let opt = this.restoreChoiceOption(savedOpt,savedInsertions,restoredInsertions);
				if(opt != null) {
					insertion.options.push(opt);
				}
			}
		}
		if(saved.stack != null) {
			insertion.stack = [];
			let _g = 0;
			let _g1 = saved.stack;
			while(_g < _g1.length) {
				let savedScope = _g1[_g];
				++_g;
				let scope = this.restoreScopeItem(savedScope,savedInsertions,restoredInsertions);
				if(scope != null) {
					insertion.stack.push(scope);
				}
			}
		}
		return insertion;
	}
	restoreChoiceOption(saved,savedInsertions,restoredInsertions) {
		let node = null;
		if(saved.node != null) {
			let nodeId = loreline_NodeId.fromString(saved.node.id);
			let astNode = this.lens.getNodeById(nodeId);
			if(astNode != null && astNode.type() == saved.node.type) {
				node = astNode;
			}
		}
		let tags = null;
		if(saved.tags != null) {
			let _g = [];
			let _g1 = 0;
			let _g2 = saved.tags;
			while(_g1 < _g2.length) {
				let t = _g2[_g1];
				++_g1;
				_g.push(new loreline_TextTag(t.closing == true,t.value,t.offset));
			}
			tags = _g;
		}
		let insertion = null;
		if(saved.insertion != null && savedInsertions != null) {
			insertion = this.restoreInsertion(saved.insertion,savedInsertions,restoredInsertions);
		}
		return new loreline_ChoiceOption(saved.text,tags,saved.disabled != true,node,insertion);
	}
	restoreBeatToResume(savedStack) {
		let beat = null;
		if(savedStack.length > 0) {
			let savedScope = savedStack[0];
			beat = this.restoreBeat(savedScope.beat);
			if(beat != null) {
				let parentBeat = beat;
				do {
					parentBeat = this.lens.getFirstParentOfType(parentBeat,loreline_NBeatDecl);
					if(parentBeat != null) {
						beat = parentBeat;
					}
				} while(parentBeat != null);
			}
		}
		return beat;
	}
	restoreNode(savedNode,savedBeatId,beat) {
		let high = beat.id.thisVal.high >> 16 & 65535;
		let high1 = savedBeatId.thisVal.high >> 16 & 65535;
		let sectionOffset = (high >= 32768 ? high - 65536 : high) + 32768 - ((high1 >= 32768 ? high1 - 65536 : high1) + 32768);
		let nodeId = loreline_NodeId.fromString(savedNode.id);
		if(nodeId == savedBeatId) {
			return beat;
		}
		let high2 = nodeId.thisVal.high >> 16 & 65535;
		let section = (high2 >= 32768 ? high2 - 65536 : high2) + 32768 + sectionOffset;
		let value = section - 32768;
		if(value < 0) {
			value = value + 65536 & 65535;
		}
		nodeId.thisVal = new haxe__$Int64__$_$_$Int64(nodeId.thisVal.high & 65535 | value << 16,nodeId.thisVal.low);
		let node = this.lens.getNodeById(nodeId);
		if(node != null && node.type() == savedNode.type) {
			return node;
		}
		return null;
	}
	restoreBeat(beatRef) {
		return this.lens.findBeatByPathFromNode(beatRef.path,this.script);
	}
	restoreState(state,data) {
		let tmp = state != null ? state.fields : null;
		let fields = this.restoreFields(tmp != null ? tmp : null,data);
		if(state == null) {
			state = new loreline_RuntimeState(this,null,fields,null);
		}
		return state;
	}
	restoreCharacters(data) {
		let _g = 0;
		let _g1 = Reflect.fields(data);
		while(_g < _g1.length) {
			let name = _g1[_g];
			++_g;
			let characterData = Reflect.field(data,name);
			if(Object.prototype.hasOwnProperty.call(this.topLevelCharacters.h,name)) {
				this.restoreCharacter(this.topLevelCharacters.h[name],characterData);
			} else {
				let newCharacter = this.restoreCharacter(null,characterData);
				this.topLevelCharacters.h[name] = newCharacter;
			}
		}
	}
	restoreNodeStates(data) {
		let _g = 0;
		let _g1 = Reflect.fields(data);
		while(_g < _g1.length) {
			let idStr = _g1[_g];
			++_g;
			let id = loreline_NodeId.fromString(idStr);
			let stateData = Reflect.field(data,idStr);
			let nodeState = this.restoreState(null,stateData);
			let key = id.thisVal;
			this.nodeStates.map._set(key.high,key.low,nodeState);
		}
	}
	restoreCharacter(character,data) {
		let tmp = character != null ? character.fields : null;
		let fields = this.restoreFields(tmp != null ? tmp : null,data);
		if(character == null) {
			character = new loreline_RuntimeCharacter(this,null,fields,null);
		}
		return character;
	}
	restoreFields(target,savedFields) {
		if(savedFields == null || savedFields.fields == null) {
			return target;
		}
		if(target == null) {
			target = loreline_Objects.createFields(this,savedFields.type);
		}
		let data = savedFields.fields;
		if(loreline_Objects.isFields(target)) {
			let _g = 0;
			let _g1 = Reflect.fields(data);
			while(_g < _g1.length) {
				let key = _g1[_g];
				++_g;
				loreline_Objects.setField(this,target,key,this.restoreValue(Reflect.field(data,key)));
			}
		} else {
			let _g = 0;
			let _g1 = Reflect.fields(data);
			while(_g < _g1.length) {
				let field = _g1[_g];
				++_g;
				target[field] = this.restoreValue(Reflect.field(data,field));
			}
		}
		return target;
	}
	restoreValue(value) {
		if(value == null) {
			return null;
		}
		if(typeof(value) == "string" || typeof(value) == "number" || typeof(value) == "number" && ((value | 0) === value) || typeof(value) == "boolean") {
			return value;
		}
		if(loreline_Arrays.isArray(value)) {
			let len = loreline_Arrays.arrayLength(value);
			let arr = loreline_Arrays.createArray();
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				loreline_Arrays.arrayPush(arr,this.restoreValue(loreline_Arrays.arrayGet(value,i)));
			}
			return arr;
		}
		return this.restoreFields(null,value);
	}
	initializeTopLevelFunctions(functions) {
		let builtins = new loreline_Functions(this);
		builtins.bindAll(this.topLevelFunctions);
		if(functions != null) {
			let access = functions;
			let _g_access = access;
			let _g_keys = Reflect.fields(access);
			let _g_index = 0;
			while(_g_index < _g_keys.length) {
				let key = _g_keys[_g_index++];
				let _g_value = _g_access[key];
				let _g_key = key;
				let key1 = _g_key;
				let func = _g_value;
				this.topLevelFunctions.h[key1] = func;
			}
		}
		let h = this.topLevelFunctions.h;
		let _g_h = h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) {
			let key = _g_keys[_g_current++];
			let _g_key = key;
			let _g_value = _g_h[key];
			let key1 = _g_key;
			let func = _g_value;
			if(key1.startsWith("string_")) {
				this.stringHelpers.h[HxOverrides.substr(key1,7,null)] = func;
			} else if(key1.startsWith("array_")) {
				this.arrayHelpers.h[HxOverrides.substr(key1,6,null)] = func;
			} else if(key1.startsWith("map_")) {
				this.mapHelpers.h[HxOverrides.substr(key1,4,null)] = func;
			}
		}
	}
	initializeStringLiteralProcessors(processors) {
		let _gthis = this;
		this.stringLiteralProcessors.push(function(str) {
			return _gthis.pluralPipeProcess(str);
		});
		if(processors != null) {
			let _g = 0;
			while(_g < processors.length) {
				let p = processors[_g];
				++_g;
				this.stringLiteralProcessors.push(p);
			}
		}
	}
	initializeTopLevelFunction(func) {
		if(func.name != null) {
			if(!func.external || !Object.prototype.hasOwnProperty.call(this.topLevelFunctions.h,func.name)) {
				let codeToHscript = new loreline_CodeToHscript();
				try {
					let expr = codeToHscript.process(func.code + (func.external ? " {}" : ""));
					let parser = new hscript_Parser();
					parser.allowJSON = true;
					parser.allowTypes = true;
					let ast = parser.parseString(expr);
					let interp = new loreline_HscriptInterp(this);
					let value = interp.execute(ast);
					this.topLevelFunctions.h[func.name] = value;
				} catch( _g ) {
					let e = haxe_Exception.caught(_g).unwrap();
					throw haxe_Exception.thrown(new loreline_RuntimeError("Failed to parse function code: " + (e == null ? "null" : Std.string(e)),func.pos));
				}
			}
		} else {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Top level function must have a name",func.pos));
		}
	}
	wrapNext(cb) {
		let wrapped = new loreline_EvalNext();
		wrapped.sync = true;
		let _gthis = this;
		wrapped.cb = function() {
			if(wrapped.sync) {
				if(_gthis.syncCallbacks == null) {
					_gthis.syncCallbacks = [];
				}
				_gthis.syncCallbacks.push(wrapped.cb);
			} else {
				cb();
				_gthis.flush();
				wrapped.cb = null;
				if(_gthis.finishTrigger == wrapped) {
					_gthis.finish();
				}
			}
		};
		return wrapped;
	}
	flush() {
		if(this.flushing) {
			return;
		}
		this.flushing = true;
		if(this.syncCallbacks != null) {
			while(this.syncCallbacks.length > 0) {
				let cb = this.syncCallbacks.shift();
				let prevSyncCallbacks = this.syncCallbacks;
				this.syncCallbacks = null;
				cb();
				if(this.syncCallbacks != null) {
					let _g = 0;
					let _g1 = this.syncCallbacks.length;
					while(_g < _g1) {
						let i = _g++;
						prevSyncCallbacks.unshift(this.syncCallbacks[i]);
					}
				}
				this.syncCallbacks = prevSyncCallbacks;
			}
		}
		this.flushing = false;
	}
	pop() {
		if(this.stack.length > 0) {
			this.stack.pop();
			return true;
		}
		return false;
	}
	push(scope) {
		scope.id = this.nextScopeId++;
		this.stack.push(scope);
	}
	initializeTopLevelState(state) {
		if(state.temporary) {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Top level temporary states are not allowed",state.pos));
		}
		let _g = 0;
		let _g1 = state.fields;
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			let evaluated = this.evaluateExpression(field.value);
			loreline_Objects.setField(this,this.topLevelState.fields,field.name,evaluated);
			if(this.isOriginalScriptExpression(field.value)) {
				loreline_Objects.setField(this,this.topLevelState.originalFields,field.name,evaluated);
			}
		}
	}
	initializeTopLevelBeat(beat) {
		if(Object.prototype.hasOwnProperty.call(this.topLevelBeats.h,beat.name)) {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Duplicate top level beat: " + beat.name,beat.pos));
		}
		this.topLevelBeats.h[beat.name] = beat;
	}
	initializeTopLevelCharacter(character) {
		if(Object.prototype.hasOwnProperty.call(this.topLevelCharacters.h,character.name)) {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Duplicate top level character: " + character.name,character.pos));
		}
		let characterState = new loreline_RuntimeCharacter(this,character,null,null);
		this.topLevelCharacters.h[character.name] = characterState;
		let _g = 0;
		let _g1 = character.fields;
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			let evaluated = this.evaluateExpression(field.value);
			loreline_Objects.setField(this,characterState.fields,field.name,evaluated);
			if(this.isOriginalScriptExpression(field.value)) {
				loreline_Objects.setField(this,characterState.originalFields,field.name,evaluated);
			}
		}
	}
	initializeState(state,scope) {
		let runtimeState = null;
		if(state.temporary) {
			if(scope.state == null) {
				scope.state = new loreline_RuntimeState(this,state,null,null);
			}
			runtimeState = scope.state;
		} else {
			let key = scope.node.id.thisVal;
			runtimeState = this.nodeStates.map._get(key.high,key.low);
			if(runtimeState == null) {
				runtimeState = new loreline_RuntimeState(this,state,null,null);
				let key = scope.node.id.thisVal;
				this.nodeStates.map._set(key.high,key.low,runtimeState);
			}
		}
		let _g = 0;
		let _g1 = state.fields;
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			if(!loreline_Objects.fieldExists(this,runtimeState.fields,field.name)) {
				let evaluated = this.evaluateExpression(field.value);
				loreline_Objects.setField(this,runtimeState.fields,field.name,evaluated);
				if(!state.temporary && this.isOriginalScriptExpression(field.value)) {
					loreline_Objects.setField(this,runtimeState.originalFields,field.name,evaluated);
				}
			}
		}
	}
	finish() {
		this.finishTrigger = null;
		if(this.handleFinish != null) {
			this.handleFinish(this);
		}
	}
	transitionToBeat(beat) {
		while(this.pop()) {
		}
		this.nextScopeId = 1;
		this.nextInsertionId = 1;
		let done = this.wrapNext($bind(this,this.finish));
		this.finishTrigger = done;
		this.evalBeatRun(beat,done.cb);
		done.sync = false;
	}
	evalNode(node,next) {
		switch(js_Boot.getClass(node)) {
		case loreline_NAssign:
			this.evalAssignment(node,next);
			break;
		case loreline_NBeatDecl:
			this.evalBeatDecl(node,next);
			break;
		case loreline_NCall:
			this.evalCall(node,next);
			break;
		case loreline_NChoiceOption:
			this.evalChoiceOption(node,next);
			break;
		case loreline_NChoiceStatement:
			this.evalChoice(node,next);
			break;
		case loreline_NDialogueStatement:
			this.evalDialogue(node,next);
			break;
		case loreline_NIfStatement:
			this.evalIf(node,next);
			break;
		case loreline_NStateDecl:
			this.evalStateDecl(node,next);
			break;
		case loreline_NTextStatement:
			this.evalText(node,next);
			break;
		case loreline_NTransition:
			this.evalTransition(node);
			break;
		default:
			let c = js_Boot.getClass(node);
			throw haxe_Exception.thrown(new loreline_RuntimeError("Unsupported node type: " + c.__name__,node.pos));
		}
	}
	evalBeatDecl(beat,next) {
		if(this.get_currentScope().beats == null) {
			this.get_currentScope().beats = [];
		} else if(this.get_currentScope().beatByName(beat.name) != null) {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Duplicate beat with name: " + beat.name,beat.pos));
		}
		this.get_currentScope().beats.push(beat);
		next();
	}
	evalNodeBody(beat,node,body,insertion,next) {
		this.push(new loreline_RuntimeScope(null,beat,node,null,null,null,insertion));
		let index = 0;
		let moveNext = null;
		let currentInsertion = this.get_currentInsertion();
		let _gthis = this;
		moveNext = function() {
			if((currentInsertion != null ? currentInsertion.options : null) != null) {
				_gthis.pop();
				next();
			} else if(index < body.length) {
				let childNode = body[index];
				_gthis.get_currentScope().head = childNode;
				index += 1;
				let done = _gthis.wrapNext(moveNext);
				_gthis.evalNode(childNode,done.cb);
				done.sync = false;
			} else {
				_gthis.pop();
				next();
			}
		};
		moveNext();
	}
	evalBeatRun(beat,next) {
		this.evalNodeBody(beat,beat,beat.body,null,next);
	}
	evalStateDecl(state,next) {
		this.initializeState(state,this.get_currentScope());
		next();
	}
	evalText(text,next) {
		let str = this.getTranslatedString(text,text.content);
		let content = this.evaluateString(str);
		this.handleDialogue(this,null,content.text,content.tags,next);
	}
	evalDialogue(dialogue,next) {
		let str = this.getTranslatedString(dialogue,dialogue.content);
		let content = this.evaluateString(str);
		this.handleDialogue(this,dialogue.character,content.text,content.tags,next);
	}
	evalChoice(choice,next) {
		let options = [];
		let _gthis = this;
		let optionsDone = this.wrapNext(function() {
			let currentInsertion = _gthis.get_currentInsertion();
			if(currentInsertion != null && currentInsertion.options == null) {
				currentInsertion.stack = [].concat(_gthis.stack);
				currentInsertion.options = options;
				next();
				return;
			}
			let index = -1;
			let choiceCallback = _gthis.wrapNext(function() {
				if(index >= 0 && index < options.length) {
					let option = options[index];
					if(option.insertion != null) {
						let scopeLevel = _gthis.stack.length;
						while(_gthis.stack.length > 0) _gthis.stack.pop();
						let _g = 0;
						let _g1 = option.insertion.stack;
						while(_g < _g1.length) {
							let scope = _g1[_g];
							++_g;
							if(scope.insertion == option.insertion) {
								scope.insertion = null;
							}
							_gthis.stack.push(scope);
						}
						let lastScope = _gthis.stack[_gthis.stack.length - 1];
						_gthis.push(new loreline_RuntimeScope(null,lastScope.beat,_gthis.lens.getParentNode(option.node),null,null,option.node,null));
						_gthis.resumeFromLevel(scopeLevel,next);
					} else {
						_gthis.evalChoiceOption(option.node,next);
					}
				} else {
					next();
				}
			});
			_gthis.handleChoice(_gthis,options,function(index_) {
				index = index_;
				choiceCallback.cb();
			});
			choiceCallback.sync = false;
		});
		this.evalChoiceOptionsAndInsertions(this.get_currentScope().beat,choice,options,optionsDone.cb);
		optionsDone.sync = false;
	}
	evalChoiceOptionsAndInsertions(beat,choice,result,next) {
		let options = choice.options;
		let index = 0;
		let moveNext = null;
		let insertion = null;
		let _gthis = this;
		moveNext = function() {
			if(insertion != null && insertion.options != null) {
				let _g = 0;
				let _g1 = insertion.options.length;
				while(_g < _g1) {
					let i = _g++;
					let opt = insertion.options[i];
					result.push(opt);
				}
				insertion = null;
			}
			if(index < options.length) {
				let option = options[index];
				index += 1;
				let enabled = option.condition == null || _gthis.evaluateCondition(option.condition);
				if(option.text != null) {
					let done = _gthis.wrapNext(moveNext);
					let str = _gthis.getTranslatedString(option,option.text);
					let content = _gthis.evaluateString(str);
					result.push(new loreline_ChoiceOption(content.text,content.tags,enabled,option,_gthis.get_currentInsertion()));
					done.cb();
					done.sync = false;
				} else if(option.insertion != null) {
					let done = _gthis.wrapNext(moveNext);
					insertion = new loreline_RuntimeInsertion(_gthis.nextInsertionId++,option.insertion);
					_gthis.evalInsertion(insertion,done.cb);
					done.sync = false;
				} else {
					throw haxe_Exception.thrown(new loreline_RuntimeError("Invalid choice option",option.pos));
				}
			} else {
				next();
			}
		};
		moveNext();
	}
	evalInsertion(insertion,next) {
		let beatName = insertion.origin.target;
		let resolvedBeat = null;
		let i = this.stack.length - 1;
		while(i >= 0) {
			let scope = this.stack[i];
			let beatInScope = scope.beatByName(beatName);
			if(beatInScope != null) {
				resolvedBeat = beatInScope;
				break;
			}
			--i;
		}
		if(resolvedBeat == null) {
			if(Object.prototype.hasOwnProperty.call(this.topLevelBeats.h,beatName)) {
				resolvedBeat = this.topLevelBeats.h[beatName];
			}
		}
		if(resolvedBeat == null) {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Beat " + beatName + " not found",this.script.pos));
		}
		this.evalNodeBody(resolvedBeat,resolvedBeat,resolvedBeat.body,insertion,next);
	}
	evalChoiceOption(option,next) {
		this.evalNodeBody(this.get_currentScope().beat,option,option.body,null,next);
	}
	evalIf(ifStmt,next) {
		let isTrue = this.evaluateCondition(ifStmt.condition);
		let branch = isTrue ? ifStmt.thenBranch : ifStmt.elseBranch;
		if(branch != null && branch.body.length > 0) {
			this.evalNodeBody(this.get_currentScope().beat,branch,branch.body,null,next);
		} else {
			next();
		}
	}
	evalAssignment(assign,next) {
		let target = this.resolveAssignmentTarget(assign.target);
		let value = this.evaluateExpression(assign.value);
		let currentValue;
		switch(assign.op._hx_index) {
		case 14:
			currentValue = value;
			break;
		case 15:
			currentValue = this.performOperation(loreline_TokenType.OpPlus,this.readAccess(target),value,assign.pos);
			break;
		case 16:
			currentValue = this.performOperation(loreline_TokenType.OpMinus,this.readAccess(target),value,assign.pos);
			break;
		case 17:
			currentValue = this.performOperation(loreline_TokenType.OpMultiply,this.readAccess(target),value,assign.pos);
			break;
		case 18:
			currentValue = this.performOperation(loreline_TokenType.OpDivide,this.readAccess(target),value,assign.pos);
			break;
		default:
			throw haxe_Exception.thrown(new loreline_RuntimeError("Invalid assignment operator",assign.pos));
		}
		this.writeAccess(target,currentValue);
		next();
	}
	isOriginalScriptExpression(expr) {
		switch(js_Boot.getClass(expr)) {
		case loreline_NBinary:
			let bin = expr;
			if(this.isOriginalScriptExpression(bin.left)) {
				return this.isOriginalScriptExpression(bin.right);
			} else {
				return false;
			}
			break;
		case loreline_NAccess:case loreline_NArrayAccess:case loreline_NCall:
			return false;
		case loreline_NLiteral:
			let lit = expr;
			let _g = lit.literalType;
			switch(_g._hx_index) {
			case 0:case 1:case 2:
				return true;
			case 3:
				let arr = lit.value;
				let _g1 = 0;
				while(_g1 < arr.length) {
					let elem = arr[_g1];
					++_g1;
					if(((elem) instanceof loreline_NExpr) && !this.isOriginalScriptExpression(elem)) {
						return false;
					}
				}
				return true;
			case 4:
				let _g2 = _g.style;
				let fields = lit.value;
				let _g3 = 0;
				while(_g3 < fields.length) {
					let field = fields[_g3];
					++_g3;
					if(!this.isOriginalScriptExpression(field.value)) {
						return false;
					}
				}
				return true;
			}
			break;
		case loreline_NStringLiteral:
			let str = expr;
			let _g4 = 0;
			let _g5 = str.parts;
			while(_g4 < _g5.length) {
				let part = _g5[_g4];
				++_g4;
				let _g = part.partType;
				switch(_g._hx_index) {
				case 0:
					let _g1 = _g.text;
					continue;
				case 1:
					let _g2 = _g.expr;
					return false;
				case 2:
					let _g3 = _g.closing;
					let content = _g.expr;
					if(!this.isOriginalScriptExpression(content)) {
						return false;
					}
					break;
				}
			}
			return true;
		case loreline_NUnary:
			let un = expr;
			return this.isOriginalScriptExpression(un.operand);
		}
		return false;
	}
	isBeatCall(node,scopeLevel) {
		if(scopeLevel == null) {
			scopeLevel = -1;
		}
		if(((node) instanceof loreline_NCall)) {
			return this.resolveBeatFromCall(node,scopeLevel) != null;
		}
		return false;
	}
	resolveBeatFromCall(call,scopeLevel) {
		if(scopeLevel == null) {
			scopeLevel = -1;
		}
		if(((call.target) instanceof loreline_NAccess)) {
			let access = call.target;
			if(access.target == null) {
				let beatName = access.name;
				let resolvedBeat = null;
				let i = scopeLevel == -1 ? this.stack.length - 1 : scopeLevel;
				while(i >= 0) {
					let scope = this.stack[i];
					let beatInScope = scope.beatByName(beatName);
					if(beatInScope != null) {
						resolvedBeat = beatInScope;
						break;
					}
					--i;
				}
				if(resolvedBeat == null && Object.prototype.hasOwnProperty.call(this.topLevelBeats.h,beatName)) {
					resolvedBeat = this.topLevelBeats.h[beatName];
				}
				if(resolvedBeat != null) {
					return resolvedBeat;
				}
			}
		}
		return null;
	}
	evalCall(call,next) {
		let resolvedBeat = this.resolveBeatFromCall(call);
		if(resolvedBeat != null) {
			this.evalBeatRun(resolvedBeat,next);
			return;
		}
		this.evaluateFunctionCall(call,next);
	}
	evalTransition(transition) {
		let beatName = transition.target;
		if(beatName == ".") {
			this.finish();
			return;
		}
		let resolvedBeat = null;
		let i = this.stack.length - 1;
		while(i >= 0) {
			let scope = this.stack[i];
			let beatInScope = scope.beatByName(beatName);
			if(beatInScope != null) {
				resolvedBeat = beatInScope;
				break;
			}
			--i;
		}
		if(resolvedBeat == null) {
			if(Object.prototype.hasOwnProperty.call(this.topLevelBeats.h,beatName)) {
				resolvedBeat = this.topLevelBeats.h[beatName];
			}
		}
		if(resolvedBeat == null) {
			throw haxe_Exception.thrown(new loreline_RuntimeError("Beat " + beatName + " not found",this.script.pos));
		}
		this.transitionToBeat(resolvedBeat);
	}
	getTranslatedString(node,str) {
		if(this.translations != null) {
			let id = this.findHashCommentId(node,str);
			if(id != null) {
				let translated = this.translations.h[id];
				if(translated != null) {
					return translated;
				}
			}
		}
		return str;
	}
	findHashCommentId(node,str) {
		return loreline_AstUtils.findHashComment(node,str);
	}
	evaluateString(str) {
		let _g = 0;
		let _g1 = this.stringLiteralProcessors.length;
		while(_g < _g1) {
			let i = _g++;
			str = this.stringLiteralProcessors[i](str);
		}
		let buf_b = "";
		let tags = [];
		let offset = 0;
		let numParts = str.parts.length;
		let keepWhitespace = str.quotes != 0;
		let keepIndents = str.quotes != 0;
		let keepComments = str.quotes != 0;
		let trailingTextPartIndex = -1;
		if(!keepWhitespace) {
			let n = numParts - 1;
			_hx_loop2: while(n >= 0) {
				let part = str.parts[n];
				let _g = part.partType;
				switch(_g._hx_index) {
				case 0:
					let _g1 = _g.text;
					trailingTextPartIndex = n;
					break _hx_loop2;
				case 1:
					let _g2 = _g.expr;
					break _hx_loop2;
				case 2:
					let _g3 = _g.closing;
					let _g4 = _g.expr;
					--n;
					break;
				}
			}
		}
		let _g2 = 0;
		let _g3 = numParts;
		while(_g2 < _g3) {
			let i = _g2++;
			let part = str.parts[i];
			let _g = part.partType;
			switch(_g._hx_index) {
			case 0:
				let text = _g.text;
				if(!keepWhitespace) {
					text = StringTools.ltrim(text);
				}
				if(i == trailingTextPartIndex) {
					text = StringTools.rtrim(text);
				}
				if(!keepComments) {
					text = this.stripStringComments(text);
				}
				if(!keepIndents) {
					text = this.stripStringIndent(text);
				}
				let len = text.length;
				if(len > 0) {
					keepWhitespace = true;
				}
				let prevIsDollar = false;
				let prevIsHash = false;
				let escaped = false;
				let _g1 = 0;
				let _g3 = len;
				while(_g1 < _g3) {
					let i = _g1++;
					let c = HxOverrides.cca(text,i);
					if(escaped) {
						if(c == 110) {
							buf_b += String.fromCodePoint(10);
						} else if(c == 114) {
							buf_b += String.fromCodePoint(13);
						} else if(c == 116) {
							buf_b += String.fromCodePoint(9);
						} else {
							buf_b += String.fromCodePoint(c);
						}
						escaped = false;
						prevIsDollar = false;
						prevIsHash = false;
					} else if(c == 92) {
						escaped = true;
						prevIsDollar = false;
						prevIsHash = false;
					} else if(c == 36) {
						if(prevIsDollar) {
							buf_b += String.fromCodePoint(c);
							prevIsDollar = false;
						} else {
							prevIsDollar = true;
						}
						prevIsHash = false;
					} else if(c == 35) {
						if(prevIsHash) {
							buf_b += String.fromCodePoint(c);
							prevIsHash = false;
						} else {
							prevIsHash = true;
						}
						prevIsDollar = false;
					} else {
						if(prevIsHash) {
							buf_b += String.fromCodePoint(35);
							prevIsHash = false;
						}
						buf_b += String.fromCodePoint(c);
					}
				}
				if(prevIsHash) {
					buf_b += String.fromCodePoint(35);
				}
				offset += len;
				break;
			case 1:
				let expr = _g.expr;
				keepWhitespace = true;
				if(((expr) instanceof loreline_NAccess)) {
					let access = expr;
					let resolved = this.resolveAccess(access,access.target,access.name);
					if(resolved._hx_index == 2) {
						let _g = resolved.pos;
						let name = resolved.name;
						let characterFields = this.evaluateExpression(expr);
						let tmp = loreline_Objects.getField(this,characterFields,"name");
						let value = tmp != null ? tmp : name;
						let text = this.valueToString(value);
						offset += text.length;
						buf_b += text == null ? "null" : "" + text;
					} else {
						let value = this.evaluateExpression(expr);
						let text = this.valueToString(value);
						offset += text.length;
						buf_b += text == null ? "null" : "" + text;
					}
				} else {
					let value = this.evaluateExpression(expr);
					let text = this.valueToString(value);
					offset += text.length;
					buf_b += text == null ? "null" : "" + text;
				}
				break;
			case 2:
				let closing = _g.closing;
				let expr1 = _g.expr;
				let tagValue = this.evaluateString(expr1).text;
				tags.push(new loreline_TextTag(closing,tagValue,offset));
				break;
			}
		}
		return { text : buf_b, tags : tags};
	}
	pluralPipeProcess(str) {
		let lastExprPartIndex = -1;
		let changed = false;
		let newParts = null;
		let _g = 0;
		let _g1 = str.parts.length;
		while(_g < _g1) {
			let i = _g++;
			let part = str.parts[i];
			let _g1 = part.partType;
			switch(_g1._hx_index) {
			case 0:
				let text = _g1.text;
				if(lastExprPartIndex >= 0 && this.rawTextHasUnescapedPipe(text)) {
					let countExpr;
					let _g = str.parts[lastExprPartIndex].partType;
					if(_g._hx_index == 1) {
						let expr = _g.expr;
						countExpr = expr;
					} else {
						countExpr = null;
					}
					if(countExpr != null) {
						if(!changed) {
							let _g = [];
							let _g1 = 0;
							let _g2 = i;
							while(_g1 < _g2) {
								let j = _g1++;
								_g.push(str.parts[j]);
							}
							newParts = _g;
							changed = true;
						}
						this.transformPipeRaw(text,countExpr,part.pos,newParts);
						continue;
					}
				}
				break;
			case 1:
				let _g2 = _g1.expr;
				lastExprPartIndex = i;
				break;
			case 2:
				let _g3 = _g1.closing;
				let _g4 = _g1.expr;
				break;
			}
			if(changed) {
				newParts.push(part);
			}
		}
		if(!changed) {
			return str;
		}
		return new loreline_NStringLiteral(str.id,str.pos,str.quotes,newParts);
	}
	rawTextHasUnescapedPipe(text) {
		let len = text.length;
		let i = 0;
		while(i < len) {
			let c = HxOverrides.cca(text,i);
			if(c == 92) {
				i += 2;
				continue;
			}
			if(c == 124) {
				return true;
			}
			++i;
		}
		return false;
	}
	transformPipeRaw(text,countExpr,pos,parts) {
		let len = text.length;
		let i = 0;
		let segStart = 0;
		while(i < len) {
			let c = HxOverrides.cca(text,i);
			if(c == 92 && i + 1 < len) {
				i += 2;
				continue;
			}
			if(c == 40) {
				let pipePos = -1;
				let closePos = -1;
				let j = i + 1;
				while(j < len) {
					let cj = HxOverrides.cca(text,j);
					if(cj == 92 && j + 1 < len) {
						j += 2;
						continue;
					}
					if(cj == 124 && pipePos == -1) {
						pipePos = j;
					} else if(cj == 41) {
						closePos = j;
						break;
					}
					++j;
				}
				if(pipePos != -1 && closePos != -1 && pipePos > i + 1 && closePos > pipePos + 1) {
					let singular = HxOverrides.substr(text,i + 1,pipePos - i - 1);
					let pluralForm = HxOverrides.substr(text,pipePos + 1,closePos - pipePos - 1);
					if(i > segStart) {
						parts.push(new loreline_NStringPart(loreline_NodeId.UNDEFINED,pos,loreline_StringPartType.Raw(HxOverrides.substr(text,segStart,i - segStart))));
					}
					parts.push(new loreline_NStringPart(loreline_NodeId.UNDEFINED,pos,loreline_StringPartType.Expr(this.makePluralCall(countExpr,singular,pluralForm,pos))));
					i = closePos + 1;
					segStart = i;
					continue;
				}
			}
			if(c == 124) {
				let wordStart = i;
				while(wordStart > segStart) {
					let wc = HxOverrides.cca(text,wordStart - 1);
					if(wc == 32 || wc == 9 || wc == 10 || wc == 124 || wc == 40 || wc == 41) {
						break;
					}
					--wordStart;
				}
				let wordEnd = i + 1;
				while(wordEnd < len) {
					let wc = HxOverrides.cca(text,wordEnd);
					if(wc == 32 || wc == 9 || wc == 10 || wc == 124 || wc == 40 || wc == 41) {
						break;
					}
					++wordEnd;
				}
				let word1 = HxOverrides.substr(text,wordStart,i - wordStart);
				let word2 = HxOverrides.substr(text,i + 1,wordEnd - i - 1);
				if(word1.length > 0 && word2.length > 0) {
					if(wordStart > segStart) {
						parts.push(new loreline_NStringPart(loreline_NodeId.UNDEFINED,pos,loreline_StringPartType.Raw(HxOverrides.substr(text,segStart,wordStart - segStart))));
					}
					parts.push(new loreline_NStringPart(loreline_NodeId.UNDEFINED,pos,loreline_StringPartType.Expr(this.makePluralCall(countExpr,word1,word2,pos))));
					i = wordEnd;
					segStart = i;
					continue;
				}
			}
			++i;
		}
		if(segStart < len) {
			parts.push(new loreline_NStringPart(loreline_NodeId.UNDEFINED,pos,loreline_StringPartType.Raw(HxOverrides.substr(text,segStart,len - segStart))));
		}
	}
	makePluralCall(countExpr,singular,pluralForm,pos) {
		let target = new loreline_NAccess(loreline_NodeId.UNDEFINED,pos,null,"plural");
		let singularLiteral = new loreline_NStringLiteral(loreline_NodeId.UNDEFINED,pos,1,[new loreline_NStringPart(loreline_NodeId.UNDEFINED,pos,loreline_StringPartType.Raw(singular))]);
		let pluralLiteral = new loreline_NStringLiteral(loreline_NodeId.UNDEFINED,pos,1,[new loreline_NStringPart(loreline_NodeId.UNDEFINED,pos,loreline_StringPartType.Raw(pluralForm))]);
		return new loreline_NCall(loreline_NodeId.UNDEFINED,pos,target,[countExpr,singularLiteral,pluralLiteral]);
	}
	stripStringIndent(content) {
		let minIndent = -1;
		let currentIndent = -1;
		let len = content.length;
		let i = 0;
		while(HxOverrides.cca(content,i) == 32 && i < len) ++i;
		if(i > 0) {
			minIndent = i;
		}
		while(i < len) {
			let c = HxOverrides.cca(content,i);
			if(c == 10) {
				currentIndent = 0;
			} else if(currentIndent >= 0 && c == 32) {
				++currentIndent;
			} else if(currentIndent >= 0) {
				if(minIndent == -1 || minIndent > currentIndent) {
					minIndent = currentIndent;
				}
				currentIndent = -1;
			}
			++i;
		}
		if(minIndent > 0) {
			let indentBuf_b = "";
			let _g = 0;
			let _g1 = minIndent;
			while(_g < _g1) {
				let _ = _g++;
				indentBuf_b += String.fromCodePoint(32);
			}
			content = StringTools.replace(content,"\n" + indentBuf_b,"\n");
		}
		return content;
	}
	stripStringComments(content) {
		let result_b = "";
		let len = content.length;
		let i = 0;
		while(i < len) {
			let c = HxOverrides.cca(content,i);
			if(c == 47 && i + 1 < len && HxOverrides.cca(content,i + 1) == 47) {
				while(i < len && HxOverrides.cca(content,i) != 10) ++i;
				continue;
			}
			if(c == 47 && i + 1 < len && HxOverrides.cca(content,i + 1) == 42) {
				let hadSpaceBefore = i > 0 && HxOverrides.cca(content,i - 1) == 32;
				i += 2;
				while(i + 1 < len && !(HxOverrides.cca(content,i) == 42 && HxOverrides.cca(content,i + 1) == 47)) ++i;
				i += 2;
				let hasSpaceAfter = i < len && HxOverrides.cca(content,i) == 32;
				if(hadSpaceBefore && hasSpaceAfter) {
					++i;
				}
				if(!hadSpaceBefore && !hasSpaceAfter && i < len) {
					result_b += String.fromCodePoint(32);
				}
				continue;
			}
			result_b += String.fromCodePoint(c);
			++i;
		}
		return result_b;
	}
	evaluateCondition(expr) {
		let value = this.evaluateExpression(expr);
		if(typeof(value) == "boolean") {
			return value == true;
		} else if(typeof(value) == "string") {
			return value.length > 0;
		} else if(((value) instanceof Array)) {
			return value.length > 0;
		} else if(typeof(value) == "number" && ((value | 0) === value)) {
			return value != 0;
		} else if(typeof(value) == "number") {
			return value != 0;
		} else {
			return value != null;
		}
	}
	evaluateFunctionCall(call,next) {
		if(((call.target) instanceof loreline_NAccess)) {
			let access = call.target;
			if(access.target == null) {
				let target = this.evaluateExpression(call.target);
				if(target != null) {
					if(Reflect.isFunction(target)) {
						let _g = [];
						let _g1 = 0;
						let _g2 = call.args;
						while(_g1 < _g2.length) {
							let arg = _g2[_g1];
							++_g1;
							_g.push(this.evaluateExpression(arg));
						}
						let args = _g;
						try {
							let result = target.apply(null,args);
							if(result != null && ((result) instanceof loreline_Async)) {
								if(next == null) {
									throw haxe_Exception.thrown(new loreline_RuntimeError("Cannot call async function in expression",call.pos));
								} else {
									let asyncResult = result;
									asyncResult.func(next);
								}
							} else if(next != null) {
								next();
							}
							return result;
						} catch( _g ) {
							let e = haxe_Exception.caught(_g).unwrap();
							if(((e) instanceof hscript_Error)) {
								let hscriptErr = e;
								throw haxe_Exception.thrown(new loreline_RuntimeError("Error when evaluating function (" + hscriptErr.pmin + "-" + hscriptErr.pmax + "): " + Std.string(hscriptErr.e),call.pos));
							}
							throw haxe_Exception.thrown(new loreline_RuntimeError("Error when calling function: " + Std.string(e),call.pos));
						}
					}
				}
			} else {
				let obj = this.evaluateExpression(access.target);
				let helper = null;
				if(typeof(obj) == "string") {
					helper = loreline_Objects.getStringHelper(this,access.name);
				} else if(loreline_Arrays.isArray(obj)) {
					helper = loreline_Objects.getArrayHelper(this,access.name);
				} else if(loreline_Objects.isFields(obj)) {
					helper = loreline_Objects.getMapHelper(this,access.name);
				}
				if(helper != null && Reflect.isFunction(helper)) {
					let _g = [];
					let _g1 = 0;
					let _g2 = call.args;
					while(_g1 < _g2.length) {
						let arg = _g2[_g1];
						++_g1;
						_g.push(this.evaluateExpression(arg));
					}
					let args = _g;
					args.splice(0,0,obj);
					let result = helper.apply(null,args);
					if(result != null && ((result) instanceof loreline_Async)) {
						if(next == null) {
							throw haxe_Exception.thrown(new loreline_RuntimeError("Cannot call async function in expression",call.pos));
						} else {
							let asyncResult = result;
							asyncResult.func(next);
						}
					} else if(next != null) {
						next();
					}
					return result;
				} else if(helper == null && !(typeof(obj) == "string" || loreline_Arrays.isArray(obj) || loreline_Objects.isFields(obj))) {
					let method = Reflect.getProperty(obj,access.name);
					if(Reflect.isFunction(method)) {
						let _g = [];
						let _g1 = 0;
						let _g2 = call.args;
						while(_g1 < _g2.length) {
							let arg = _g2[_g1];
							++_g1;
							_g.push(this.evaluateExpression(arg));
						}
						let args = _g;
						let result = method.apply(obj,args);
						if(result != null && ((result) instanceof loreline_Async)) {
							if(next == null) {
								throw haxe_Exception.thrown(new loreline_RuntimeError("Cannot call async function in expression",call.pos));
							} else {
								let asyncResult = result;
								asyncResult.func(next);
							}
						} else if(next != null) {
							next();
						}
						return result;
					}
				}
			}
		}
		let tmp = this.printLoreline(call.target);
		let tmp1;
		if(tmp != null) {
			tmp1 = tmp;
		} else {
			let c = js_Boot.getClass(call.target);
			tmp1 = c.__name__;
		}
		throw haxe_Exception.thrown(new loreline_RuntimeError("Invalid call target: " + tmp1,call.pos));
	}
	evaluateArrayLiteral(expr) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < expr.length) {
			let elem = expr[_g1];
			++_g1;
			_g.push(this.evaluateExpression(elem));
		}
		return _g;
	}
	evaluateObjectLiteral(expr) {
		let obj = new haxe_ds_StringMap();
		let _g = 0;
		while(_g < expr.length) {
			let field = expr[_g];
			++_g;
			let key = field.name;
			let value = this.evaluateExpression(field.value);
			obj.h[key] = value;
		}
		return obj;
	}
	evaluateExpression(expr) {
		switch(js_Boot.getClass(expr)) {
		case loreline_NAccess:
			let access = expr;
			let resolved = this.resolveAccess(access,access.target,access.name);
			return this.readAccess(resolved);
		case loreline_NArrayAccess:
			let arrAccess = expr;
			let target = this.evaluateExpression(arrAccess.target);
			let index = this.evaluateExpression(arrAccess.index);
			if(loreline_Arrays.isArray(target) && (typeof(index) == "number" && ((index | 0) === index) || typeof(index) == "number")) {
				let i = index | 0;
				if(i < 0 || i >= loreline_Arrays.arrayLength(target)) {
					throw haxe_Exception.thrown(new loreline_RuntimeError("Array index out of bounds: " + i,arrAccess.pos));
				} else {
					return loreline_Arrays.arrayGet(target,i);
				}
			} else if(typeof(index) == "string") {
				return loreline_Objects.getField(this,target,index);
			} else {
				throw haxe_Exception.thrown(new loreline_RuntimeError("Invalid array access",arrAccess.pos));
			}
			break;
		case loreline_NBinary:
			let bin = expr;
			let left = this.evaluateExpression(bin.left);
			let right = this.evaluateExpression(bin.right);
			return this.performOperation(bin.op,left,right,bin.pos);
		case loreline_NCall:
			return this.evaluateFunctionCall(expr,null);
		case loreline_NLiteral:
			let lit = expr;
			let _g = lit.literalType;
			switch(_g._hx_index) {
			case 0:case 1:case 2:
				return lit.value;
			case 3:
				return this.evaluateArrayLiteral(lit.value);
			case 4:
				let _g1 = _g.style;
				return this.evaluateObjectLiteral(lit.value);
			}
			break;
		case loreline_NStringLiteral:
			let str = expr;
			if(str.parts.length == 1 && str.quotes == 0) {
				let _g = str.parts[0].partType;
				if(_g._hx_index == 1) {
					let expr = _g.expr;
					return this.evaluateExpression(expr);
				} else {
					return this.evaluateString(str).text;
				}
			} else {
				return this.evaluateString(str).text;
			}
			break;
		case loreline_NUnary:
			let un = expr;
			let operand = this.evaluateExpression(un.operand);
			switch(un.op._hx_index) {
			case 20:
				if(typeof(operand) == "number" && ((operand | 0) === operand)) {
					let v = operand;
					return -v;
				} else if(typeof(operand) == "number") {
					let v = operand;
					return -v;
				} else {
					throw haxe_Exception.thrown(new loreline_RuntimeError("Invalid unary operation",un.pos));
				}
				break;
			case 32:
				if(typeof(operand) == "boolean") {
					let v = operand;
					return !v;
				} else if(typeof(operand) == "string") {
					let v = operand;
					if(v != null) {
						return v.length == 0;
					} else {
						return true;
					}
				} else if(((operand) instanceof Array)) {
					let v = operand;
					if(v != null) {
						return v.length == 0;
					} else {
						return true;
					}
				} else if(typeof(operand) == "number" && ((operand | 0) === operand)) {
					let v = operand;
					return v == 0;
				} else if(typeof(operand) == "number") {
					let v = operand;
					return v == 0;
				} else {
					return operand == null;
				}
				break;
			default:
				throw haxe_Exception.thrown(new loreline_RuntimeError("Invalid unary operation",un.pos));
			}
			break;
		default:
			let c = js_Boot.getClass(expr);
			throw haxe_Exception.thrown(new loreline_RuntimeError("Unsupported expression type: " + c.__name__,expr.pos));
		}
	}
	readAccess(access) {
		switch(access._hx_index) {
		case 0:
			let pos = access.pos;
			let obj = access.obj;
			let name = access.name;
			return loreline_Objects.getField(this,obj,name);
		case 1:
			let pos1 = access.pos;
			let array = access.array;
			let index = access.index;
			return loreline_Arrays.arrayGet(array,index);
		case 2:
			let pos2 = access.pos;
			let name1 = access.name;
			if(Object.prototype.hasOwnProperty.call(this.topLevelCharacters.h,name1)) {
				return this.topLevelCharacters.h[name1].fields;
			} else {
				throw haxe_Exception.thrown(new loreline_RuntimeError("Character not found: " + name1,pos2));
			}
			break;
		case 3:
			let pos3 = access.pos;
			let name2 = access.name;
			if(Object.prototype.hasOwnProperty.call(this.topLevelFunctions.h,name2)) {
				return this.topLevelFunctions.h[name2];
			} else {
				throw haxe_Exception.thrown(new loreline_RuntimeError("Function not found: " + name2,pos3));
			}
			break;
		}
	}
	writeAccess(access,value) {
		switch(access._hx_index) {
		case 0:
			let pos = access.pos;
			let obj = access.obj;
			let name = access.name;
			loreline_Objects.setField(this,obj,name,value);
			break;
		case 1:
			let pos1 = access.pos;
			let array = access.array;
			let index = access.index;
			loreline_Arrays.arraySet(array,index,value);
			break;
		case 2:
			let pos2 = access.pos;
			let name1 = access.name;
			throw haxe_Exception.thrown(new loreline_RuntimeError("Cannot overwrite character: " + name1,pos2));
		case 3:
			let pos3 = access.pos;
			let name2 = access.name;
			throw haxe_Exception.thrown(new loreline_RuntimeError("Cannot overwrite function: " + name2,pos3));
		}
	}
	resolveAssignmentTarget(target) {
		switch(js_Boot.getClass(target)) {
		case loreline_NAccess:
			let access = target;
			return this.resolveAccess(access,access.target,access.name);
		case loreline_NArrayAccess:
			let arrAccess = target;
			let target1 = this.evaluateExpression(arrAccess.target);
			let index = this.evaluateExpression(arrAccess.index);
			if(loreline_Arrays.isArray(target1) && (typeof(index) == "number" && ((index | 0) === index) || typeof(index) == "number")) {
				let i = index | 0;
				return loreline_RuntimeAccess.ArrayAccess(arrAccess.pos,target1,i);
			} else {
				throw haxe_Exception.thrown(new loreline_RuntimeError("Invalid array access target",arrAccess.pos));
			}
			break;
		default:
			throw haxe_Exception.thrown(new loreline_RuntimeError("Invalid assignment target",target.pos));
		}
	}
	resolveAccess(access,target,name) {
		if(target != null) {
			let evaluated = this.evaluateExpression(target);
			return loreline_RuntimeAccess.FieldAccess(target.pos,evaluated,name);
		}
		let i = this.stack.length - 1;
		while(i >= 0) {
			let scope = this.stack[i];
			if(scope.state != null) {
				if(loreline_Objects.fieldExists(this,scope.state.fields,name)) {
					let tmp = access != null ? access.pos : null;
					let tmp1;
					if(tmp != null) {
						tmp1 = tmp;
					} else {
						let tmp = this.get_currentScope();
						let tmp2 = tmp != null ? tmp.node : null;
						tmp1 = tmp2 != null ? tmp2.pos : null;
					}
					return loreline_RuntimeAccess.FieldAccess(tmp1 != null ? tmp1 : this.script.pos,scope.state.fields,name);
				}
			}
			if(scope.node != null) {
				let key = scope.node.id.thisVal;
				let stateInNode = this.nodeStates.map._get(key.high,key.low);
				if(stateInNode != null) {
					if(loreline_Objects.fieldExists(this,stateInNode.fields,name)) {
						let tmp = access != null ? access.pos : null;
						let tmp1;
						if(tmp != null) {
							tmp1 = tmp;
						} else {
							let tmp = this.get_currentScope();
							let tmp2 = tmp != null ? tmp.node : null;
							tmp1 = tmp2 != null ? tmp2.pos : null;
						}
						return loreline_RuntimeAccess.FieldAccess(tmp1 != null ? tmp1 : this.script.pos,stateInNode.fields,name);
					}
				}
			}
			--i;
		}
		if(loreline_Objects.fieldExists(this,this.topLevelState.fields,name)) {
			let tmp = access != null ? access.pos : null;
			let tmp1;
			if(tmp != null) {
				tmp1 = tmp;
			} else {
				let tmp = this.get_currentScope();
				let tmp2 = tmp != null ? tmp.node : null;
				tmp1 = tmp2 != null ? tmp2.pos : null;
			}
			return loreline_RuntimeAccess.FieldAccess(tmp1 != null ? tmp1 : this.script.pos,this.topLevelState.fields,name);
		}
		if(Object.prototype.hasOwnProperty.call(this.topLevelCharacters.h,name)) {
			let tmp = access != null ? access.pos : null;
			let tmp1;
			if(tmp != null) {
				tmp1 = tmp;
			} else {
				let tmp = this.get_currentScope();
				let tmp2 = tmp != null ? tmp.node : null;
				tmp1 = tmp2 != null ? tmp2.pos : null;
			}
			return loreline_RuntimeAccess.CharacterAccess(tmp1 != null ? tmp1 : this.script.pos,name);
		}
		if(Object.prototype.hasOwnProperty.call(this.topLevelFunctions.h,name)) {
			let tmp = access != null ? access.pos : null;
			let tmp1;
			if(tmp != null) {
				tmp1 = tmp;
			} else {
				let tmp = this.get_currentScope();
				let tmp2 = tmp != null ? tmp.node : null;
				tmp1 = tmp2 != null ? tmp2.pos : null;
			}
			return loreline_RuntimeAccess.FunctionAccess(tmp1 != null ? tmp1 : this.script.pos,name);
		}
		if(!this.strictAccess) {
			let tmp = access != null ? access.pos : null;
			let tmp1;
			if(tmp != null) {
				tmp1 = tmp;
			} else {
				let tmp = this.get_currentScope();
				let tmp2 = tmp != null ? tmp.node : null;
				tmp1 = tmp2 != null ? tmp2.pos : null;
			}
			return loreline_RuntimeAccess.FieldAccess(tmp1 != null ? tmp1 : this.script.pos,this.topLevelState.fields,name);
		}
		let tmp = access != null ? access.pos : null;
		let tmp1;
		if(tmp != null) {
			tmp1 = tmp;
		} else {
			let tmp = this.get_currentScope();
			let tmp2 = tmp != null ? tmp.node : null;
			tmp1 = tmp2 != null ? tmp2.pos : null;
		}
		throw haxe_Exception.thrown(new loreline_RuntimeError("Undefined variable: " + name,tmp1 != null ? tmp1 : this.script.pos));
	}
	getTypeName(t) {
		switch(t._hx_index) {
		case 0:
			return "Null";
		case 1:
			return "Int";
		case 2:
			return "Float";
		case 3:
			return "Bool";
		case 4:
			return "Object";
		case 5:
			return "Function";
		case 6:
			let c = t.c;
			return c.__name__;
		case 7:
			let e = t.e;
			return e.__ename__;
		case 8:
			return "Unknown";
		}
	}
	performOperation(op,left,right,pos) {
		let leftType = Type.typeof(left);
		let rightType = Type.typeof(right);
		switch(op._hx_index) {
		case 19:
			switch(leftType._hx_index) {
			case 1:
				switch(rightType._hx_index) {
				case 1:case 2:
					return parseFloat(Std.string(left)) + parseFloat(Std.string(right));
				case 6:
					if(rightType.c == String) {
						return Std.string(left) + Std.string(right);
					} else {
						let tmp = "Cannot add " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
						let tmp1 = pos;
						let tmp2;
						if(tmp1 != null) {
							tmp2 = tmp1;
						} else {
							let tmp = this.get_currentScope();
							let tmp1 = tmp != null ? tmp.node : null;
							tmp2 = tmp1 != null ? tmp1.pos : null;
						}
						throw haxe_Exception.thrown(new loreline_RuntimeError(tmp,tmp2 != null ? tmp2 : this.script.pos));
					}
					break;
				default:
					let tmp = "Cannot add " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
					let tmp1 = pos;
					let tmp2;
					if(tmp1 != null) {
						tmp2 = tmp1;
					} else {
						let tmp = this.get_currentScope();
						let tmp1 = tmp != null ? tmp.node : null;
						tmp2 = tmp1 != null ? tmp1.pos : null;
					}
					throw haxe_Exception.thrown(new loreline_RuntimeError(tmp,tmp2 != null ? tmp2 : this.script.pos));
				}
				break;
			case 2:
				switch(rightType._hx_index) {
				case 1:case 2:
					return parseFloat(Std.string(left)) + parseFloat(Std.string(right));
				case 6:
					if(rightType.c == String) {
						return Std.string(left) + Std.string(right);
					} else {
						let tmp = "Cannot add " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
						let tmp1 = pos;
						let tmp2;
						if(tmp1 != null) {
							tmp2 = tmp1;
						} else {
							let tmp = this.get_currentScope();
							let tmp1 = tmp != null ? tmp.node : null;
							tmp2 = tmp1 != null ? tmp1.pos : null;
						}
						throw haxe_Exception.thrown(new loreline_RuntimeError(tmp,tmp2 != null ? tmp2 : this.script.pos));
					}
					break;
				default:
					let tmp3 = "Cannot add " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
					let tmp4 = pos;
					let tmp5;
					if(tmp4 != null) {
						tmp5 = tmp4;
					} else {
						let tmp = this.get_currentScope();
						let tmp1 = tmp != null ? tmp.node : null;
						tmp5 = tmp1 != null ? tmp1.pos : null;
					}
					throw haxe_Exception.thrown(new loreline_RuntimeError(tmp3,tmp5 != null ? tmp5 : this.script.pos));
				}
				break;
			case 6:
				if(leftType.c == String) {
					return Std.string(left) + Std.string(right);
				} else if(rightType._hx_index == 6) {
					if(rightType.c == String) {
						return Std.string(left) + Std.string(right);
					} else {
						let tmp = "Cannot add " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
						let tmp1 = pos;
						let tmp2;
						if(tmp1 != null) {
							tmp2 = tmp1;
						} else {
							let tmp = this.get_currentScope();
							let tmp1 = tmp != null ? tmp.node : null;
							tmp2 = tmp1 != null ? tmp1.pos : null;
						}
						throw haxe_Exception.thrown(new loreline_RuntimeError(tmp,tmp2 != null ? tmp2 : this.script.pos));
					}
				} else {
					let tmp = "Cannot add " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
					let tmp1 = pos;
					let tmp2;
					if(tmp1 != null) {
						tmp2 = tmp1;
					} else {
						let tmp = this.get_currentScope();
						let tmp1 = tmp != null ? tmp.node : null;
						tmp2 = tmp1 != null ? tmp1.pos : null;
					}
					throw haxe_Exception.thrown(new loreline_RuntimeError(tmp,tmp2 != null ? tmp2 : this.script.pos));
				}
				break;
			default:
				if(rightType._hx_index == 6) {
					if(rightType.c == String) {
						return Std.string(left) + Std.string(right);
					} else {
						let tmp = "Cannot add " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
						let tmp1 = pos;
						let tmp2;
						if(tmp1 != null) {
							tmp2 = tmp1;
						} else {
							let tmp = this.get_currentScope();
							let tmp1 = tmp != null ? tmp.node : null;
							tmp2 = tmp1 != null ? tmp1.pos : null;
						}
						throw haxe_Exception.thrown(new loreline_RuntimeError(tmp,tmp2 != null ? tmp2 : this.script.pos));
					}
				} else {
					let tmp = "Cannot add " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
					let tmp1 = pos;
					let tmp2;
					if(tmp1 != null) {
						tmp2 = tmp1;
					} else {
						let tmp = this.get_currentScope();
						let tmp1 = tmp != null ? tmp.node : null;
						tmp2 = tmp1 != null ? tmp1.pos : null;
					}
					throw haxe_Exception.thrown(new loreline_RuntimeError(tmp,tmp2 != null ? tmp2 : this.script.pos));
				}
			}
			break;
		case 20:case 21:case 22:case 23:
			switch(leftType._hx_index) {
			case 1:case 2:
				switch(rightType._hx_index) {
				case 1:case 2:
					let leftNum = parseFloat(Std.string(left));
					let rightNum = parseFloat(Std.string(right));
					switch(op._hx_index) {
					case 20:
						return leftNum - rightNum;
					case 21:
						return leftNum * rightNum;
					case 22:
						if(rightNum == 0) {
							let tmp = pos;
							let tmp1;
							if(tmp != null) {
								tmp1 = tmp;
							} else {
								let tmp = this.get_currentScope();
								let tmp2 = tmp != null ? tmp.node : null;
								tmp1 = tmp2 != null ? tmp2.pos : null;
							}
							throw haxe_Exception.thrown(new loreline_RuntimeError("Division by zero",tmp1 != null ? tmp1 : this.script.pos));
						}
						return leftNum / rightNum;
					case 23:
						if(rightNum == 0) {
							let tmp = pos;
							let tmp1;
							if(tmp != null) {
								tmp1 = tmp;
							} else {
								let tmp = this.get_currentScope();
								let tmp2 = tmp != null ? tmp.node : null;
								tmp1 = tmp2 != null ? tmp2.pos : null;
							}
							throw haxe_Exception.thrown(new loreline_RuntimeError("Modulo by zero",tmp1 != null ? tmp1 : this.script.pos));
						}
						return leftNum % rightNum;
					default:
						throw haxe_Exception.thrown("Unreachable");
					}
					break;
				default:
					let opName;
					switch(op._hx_index) {
					case 20:
						opName = "subtract";
						break;
					case 21:
						opName = "multiply";
						break;
					case 22:
						opName = "divide";
						break;
					case 23:
						opName = "modulo";
						break;
					default:
						opName = "perform operation on";
					}
					let tmp6 = "Cannot " + opName + " " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
					let tmp7 = pos;
					let tmp8;
					if(tmp7 != null) {
						tmp8 = tmp7;
					} else {
						let tmp = this.get_currentScope();
						let tmp1 = tmp != null ? tmp.node : null;
						tmp8 = tmp1 != null ? tmp1.pos : null;
					}
					throw haxe_Exception.thrown(new loreline_RuntimeError(tmp6,tmp8 != null ? tmp8 : this.script.pos));
				}
				break;
			default:
				let opName1;
				switch(op._hx_index) {
				case 20:
					opName1 = "subtract";
					break;
				case 21:
					opName1 = "multiply";
					break;
				case 22:
					opName1 = "divide";
					break;
				case 23:
					opName1 = "modulo";
					break;
				default:
					opName1 = "perform operation on";
				}
				let tmp9 = "Cannot " + opName1 + " " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
				let tmp10 = pos;
				let tmp11;
				if(tmp10 != null) {
					tmp11 = tmp10;
				} else {
					let tmp = this.get_currentScope();
					let tmp1 = tmp != null ? tmp.node : null;
					tmp11 = tmp1 != null ? tmp1.pos : null;
				}
				throw haxe_Exception.thrown(new loreline_RuntimeError(tmp9,tmp11 != null ? tmp11 : this.script.pos));
			}
			break;
		case 24:case 25:
			switch(op._hx_index) {
			case 24:
				return left == right;
			case 25:
				return left != right;
			default:
				throw haxe_Exception.thrown("Unreachable");
			}
			break;
		case 26:case 27:case 28:case 29:
			switch(leftType._hx_index) {
			case 1:case 2:
				switch(rightType._hx_index) {
				case 1:case 2:
					let leftNum1 = parseFloat(Std.string(left));
					let rightNum1 = parseFloat(Std.string(right));
					switch(op._hx_index) {
					case 26:
						return leftNum1 > rightNum1;
					case 27:
						return leftNum1 < rightNum1;
					case 28:
						return leftNum1 >= rightNum1;
					case 29:
						return leftNum1 <= rightNum1;
					default:
						throw haxe_Exception.thrown("Unreachable");
					}
					break;
				default:
					let tmp12 = "Cannot compare " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
					let tmp13 = pos;
					let tmp14;
					if(tmp13 != null) {
						tmp14 = tmp13;
					} else {
						let tmp = this.get_currentScope();
						let tmp1 = tmp != null ? tmp.node : null;
						tmp14 = tmp1 != null ? tmp1.pos : null;
					}
					throw haxe_Exception.thrown(new loreline_RuntimeError(tmp12,tmp14 != null ? tmp14 : this.script.pos));
				}
				break;
			default:
				let tmp15 = "Cannot compare " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
				let tmp16 = pos;
				let tmp17;
				if(tmp16 != null) {
					tmp17 = tmp16;
				} else {
					let tmp = this.get_currentScope();
					let tmp1 = tmp != null ? tmp.node : null;
					tmp17 = tmp1 != null ? tmp1.pos : null;
				}
				throw haxe_Exception.thrown(new loreline_RuntimeError(tmp15,tmp17 != null ? tmp17 : this.script.pos));
			}
			break;
		case 30:
			let _g = op.word;
			if(leftType._hx_index == 3) {
				if(rightType._hx_index == 3) {
					switch(op._hx_index) {
					case 30:
						let _g = op.word;
						if(left) {
							return right;
						} else {
							return false;
						}
						break;
					case 31:
						let _g1 = op.word;
						if(!left) {
							return right;
						} else {
							return true;
						}
						break;
					default:
						throw haxe_Exception.thrown("Unreachable");
					}
				} else {
					let tmp = "Cannot perform logical operation on " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
					let tmp1 = pos;
					let tmp2;
					if(tmp1 != null) {
						tmp2 = tmp1;
					} else {
						let tmp = this.get_currentScope();
						let tmp1 = tmp != null ? tmp.node : null;
						tmp2 = tmp1 != null ? tmp1.pos : null;
					}
					throw haxe_Exception.thrown(new loreline_RuntimeError(tmp,tmp2 != null ? tmp2 : this.script.pos));
				}
			} else {
				let tmp = "Cannot perform logical operation on " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
				let tmp1 = pos;
				let tmp2;
				if(tmp1 != null) {
					tmp2 = tmp1;
				} else {
					let tmp = this.get_currentScope();
					let tmp1 = tmp != null ? tmp.node : null;
					tmp2 = tmp1 != null ? tmp1.pos : null;
				}
				throw haxe_Exception.thrown(new loreline_RuntimeError(tmp,tmp2 != null ? tmp2 : this.script.pos));
			}
			break;
		case 31:
			let _g1 = op.word;
			if(leftType._hx_index == 3) {
				if(rightType._hx_index == 3) {
					switch(op._hx_index) {
					case 30:
						let _g = op.word;
						if(left) {
							return right;
						} else {
							return false;
						}
						break;
					case 31:
						let _g1 = op.word;
						if(!left) {
							return right;
						} else {
							return true;
						}
						break;
					default:
						throw haxe_Exception.thrown("Unreachable");
					}
				} else {
					let tmp = "Cannot perform logical operation on " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
					let tmp1 = pos;
					let tmp2;
					if(tmp1 != null) {
						tmp2 = tmp1;
					} else {
						let tmp = this.get_currentScope();
						let tmp1 = tmp != null ? tmp.node : null;
						tmp2 = tmp1 != null ? tmp1.pos : null;
					}
					throw haxe_Exception.thrown(new loreline_RuntimeError(tmp,tmp2 != null ? tmp2 : this.script.pos));
				}
			} else {
				let tmp = "Cannot perform logical operation on " + this.getTypeName(leftType) + " and " + this.getTypeName(rightType);
				let tmp1 = pos;
				let tmp2;
				if(tmp1 != null) {
					tmp2 = tmp1;
				} else {
					let tmp = this.get_currentScope();
					let tmp1 = tmp != null ? tmp.node : null;
					tmp2 = tmp1 != null ? tmp1.pos : null;
				}
				throw haxe_Exception.thrown(new loreline_RuntimeError(tmp,tmp2 != null ? tmp2 : this.script.pos));
			}
			break;
		default:
			let tmp18 = "Invalid operation: " + Std.string(op);
			let tmp19 = pos;
			let tmp20;
			if(tmp19 != null) {
				tmp20 = tmp19;
			} else {
				let tmp = this.get_currentScope();
				let tmp1 = tmp != null ? tmp.node : null;
				tmp20 = tmp1 != null ? tmp1.pos : null;
			}
			throw haxe_Exception.thrown(new loreline_RuntimeError(tmp18,tmp20 != null ? tmp20 : this.script.pos));
		}
	}
	valueToString(value) {
		if(value == null) {
			return "null";
		} else {
			return Std.string(value);
		}
	}
	printLoreline(node) {
		try {
			let printer = new loreline_Printer();
			printer.enableComments = false;
			return StringTools.trim(printer.print(node));
		} catch( _g ) {
			return null;
		}
	}
}
$hxClasses["loreline.Interpreter"] = $hx_exports["loreline"]["Interpreter"] = loreline_Interpreter;
loreline_Interpreter.__name__ = "loreline.Interpreter";
Object.assign(loreline_Interpreter.prototype, {
	__class__: loreline_Interpreter
	,__properties__: {get_currentInsertion: "get_currentInsertion",get_currentScope: "get_currentScope"}
});
class loreline_Json {
	static stringify(value,pretty) {
		if(pretty == null) {
			pretty = false;
		}
		return JSON.stringify(value,null,pretty ? "  " : null);
	}
	static parse(json) {
		return JSON.parse(json);
	}
}
$hxClasses["loreline.Json"] = loreline_Json;
loreline_Json.__name__ = "loreline.Json";
class loreline_Reference {
	constructor(target,origin) {
		this.target = target;
		this.origin = origin;
	}
}
$hxClasses["loreline.Reference"] = loreline_Reference;
loreline_Reference.__name__ = "loreline.Reference";
Object.assign(loreline_Reference.prototype, {
	__class__: loreline_Reference
});
class loreline_FuncHscript {
	constructor(func) {
		this.error = null;
		this.expr = null;
		this.hscript = null;
		this.func = func;
		this.codeToHscript = new loreline_CodeToHscript();
		try {
			this.hscript = this.codeToHscript.process(func.code);
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			if(((e) instanceof loreline_Error)) {
				this.error = e;
				this.error.pos = func.pos.withOffset(this.codeToHscript.input,this.error.pos.offset,this.error.pos.length,func.pos.offset);
			}
			this.hscript = this.codeToHscript.output.b;
		}
		try {
			let parser = new hscript_Parser();
			parser.resumeErrors = false;
			parser.allowJSON = true;
			parser.allowTypes = true;
			let tmp = func.name;
			this.expr = parser.parseString(this.hscript,tmp != null ? tmp : "?");
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			if(this.error == null) {
				if(((e) instanceof hscript_Error)) {
					let hscriptError = e;
					let tmp;
					let _g = hscriptError.e;
					switch(_g._hx_index) {
					case 0:
						let c = _g.c;
						tmp = "Invalid character: " + c;
						break;
					case 1:
						let s = _g.s;
						tmp = "Unexpected: " + s;
						break;
					case 2:
						tmp = "Unterminated string";
						break;
					case 3:
						tmp = "Unterminated comment";
						break;
					case 4:
						let msg = _g.msg;
						tmp = "Invalid preprocessor: " + msg;
						break;
					case 5:
						let v = _g.v;
						tmp = "Unknown variable: " + v;
						break;
					case 6:
						let v1 = _g.v;
						tmp = "Invalid iterator: " + v1;
						break;
					case 7:
						let op = _g.op;
						tmp = "Invalid operator: " + op;
						break;
					case 8:
						let f = _g.f;
						tmp = "Invalid access: " + f;
						break;
					case 9:
						let msg1 = _g.msg;
						tmp = msg1;
						break;
					}
					this.error = new loreline_WrappedError(hscriptError,tmp,this.codeToHscript.toLorelinePos(func.pos,hscriptError.pmin,hscriptError.pmax));
				} else if(((e) instanceof loreline_Error)) {
					this.error = e;
					this.error.pos = func.pos.withOffset(this.codeToHscript.input,this.error.pos.offset,this.error.pos.length,func.pos.offset);
				}
			}
			try {
				let parser = new hscript_Parser();
				parser.resumeErrors = true;
				parser.allowJSON = true;
				parser.allowTypes = true;
				let tmp = func.name;
				this.expr = parser.parseString(this.hscript,tmp != null ? tmp : "?");
			} catch( _g ) {
			}
		}
	}
}
$hxClasses["loreline.FuncHscript"] = loreline_FuncHscript;
loreline_FuncHscript.__name__ = "loreline.FuncHscript";
Object.assign(loreline_FuncHscript.prototype, {
	__class__: loreline_FuncHscript
});
class loreline_HscriptCompletion {
	constructor(locals,completion) {
		this.completion = null;
		this.locals = null;
		if(locals != null) {
			this.locals = locals;
		}
		if(completion != null) {
			this.completion = completion;
		}
	}
}
$hxClasses["loreline.HscriptCompletion"] = loreline_HscriptCompletion;
loreline_HscriptCompletion.__name__ = "loreline.HscriptCompletion";
Object.assign(loreline_HscriptCompletion.prototype, {
	__class__: loreline_HscriptCompletion
});
class loreline_Lens {
	constructor(script) {
		this.hscriptFunctions = new loreline_NodeIdMap();
		this.childNodes = new loreline_NodeIdMap();
		this.parentNodes = new loreline_NodeIdMap();
		this.nodesById = new loreline_NodeIdMap();
		this.script = script;
		this.initialize();
	}
	initialize() {
		let _gthis = this;
		this.script.each(function(node,parent) {
			let key = node.id.thisVal;
			_gthis.nodesById.map._set(key.high,key.low,node);
			if(parent != null) {
				let key = node.id.thisVal;
				_gthis.parentNodes.map._set(key.high,key.low,parent);
				let key1 = parent.id.thisVal;
				let children = _gthis.childNodes.map._get(key1.high,key1.low);
				if(children == null) {
					children = [];
					let key = parent.id.thisVal;
					_gthis.childNodes.map._set(key.high,key.low,children);
				}
				children.push(node);
			}
		});
	}
	getNodeById(id) {
		let key = id.thisVal;
		return this.nodesById.map._get(key.high,key.low);
	}
	getNodeAtPosition(pos) {
		let bestMatch = null;
		this.script.eachExcludingImported(function(node,parent) {
			let nodePos = node.pos;
			if(nodePos.length > 0 && nodePos.offset <= pos.offset && nodePos.offset + nodePos.length >= pos.offset) {
				bestMatch = node;
			}
		});
		return bestMatch;
	}
	getClosestNodeAtOrBeforePosition(pos) {
		let bestMatch = null;
		let bestDistance = 999999999;
		this.script.eachExcludingImported(function(node,parent) {
			let nodePos = node.pos;
			let distance = pos.offset - nodePos.offset;
			if(distance >= 0 && distance < bestDistance) {
				bestDistance = distance;
				bestMatch = node;
			}
		});
		return bestMatch;
	}
	getNodesOfType(nodeType,includeImported) {
		if(includeImported == null) {
			includeImported = false;
		}
		let matches = [];
		let _gthis = this;
		this.traverse(this.script,function(node,parent) {
			if(js_Boot.__instanceof(node,nodeType)) {
				matches.push(node);
			}
			if(!(includeImported || node == _gthis.script)) {
				return !(((node) instanceof loreline_NImportStatement) || ((node) instanceof loreline_Script));
			} else {
				return true;
			}
		});
		return matches;
	}
	getParentNode(node) {
		let key = node.id.thisVal;
		return this.parentNodes.map._get(key.high,key.low);
	}
	getFirstParentOfType(node,type) {
		let current = node;
		while(current != null) {
			current = this.getParentNode(current);
			if(current != null && js_Boot.getClass(current) == type) {
				return current;
			}
		}
		return null;
	}
	getImportedPaths(rootPath) {
		let result = [];
		this._getImportedPaths(rootPath,this.script,result,new haxe_ds_StringMap());
		return result;
	}
	_getImportedPaths(rootPath,script,result,used) {
		let rootDir = haxe_io_Path.directory(rootPath);
		if(script == null) {
			script = this.script;
		}
		let ext = ".lor";
		if(rootPath != null && rootPath.endsWith(".lor.txt")) {
			ext = ".lor.txt";
		}
		let _g = 0;
		let _g1 = script.body;
		while(_g < _g1.length) {
			let node = _g1[_g];
			++_g;
			if(((node) instanceof loreline_NImportStatement)) {
				let importNode = node;
				let importPath;
				let _g = importNode.path.parts[0].partType;
				if(_g._hx_index == 0) {
					let text = _g.text;
					importPath = text;
				} else {
					importPath = "";
				}
				if(!haxe_io_Path.isAbsolute(importPath)) {
					importPath = haxe_io_Path.join([rootDir,importPath]);
				}
				importPath = haxe_io_Path.normalize(importPath);
				if(!importPath.toLowerCase().endsWith(ext)) {
					importPath += ext;
				}
				if(!Object.prototype.hasOwnProperty.call(used.h,importPath)) {
					used.h[importPath] = true;
					result.push(importPath);
					if(importNode.script != null) {
						this._getImportedPaths(importPath,importNode.script,result,used);
					}
				}
			}
		}
		return result;
	}
	resolveArrayAccess(access) {
		let targetNode = null;
		if(((access.target) instanceof loreline_NAccess)) {
			targetNode = this.resolveAccess(access.target);
		} else if(((access.target) instanceof loreline_NArrayAccess)) {
			targetNode = this.resolveArrayAccess(access.target);
		}
		if(targetNode == null) {
			return null;
		}
		switch(js_Boot.getClass(targetNode)) {
		case loreline_NLiteral:
			let literal = targetNode;
			if(literal.literalType == loreline_LiteralType.Array) {
				let elements = literal.value;
				if(((access.index) instanceof loreline_NLiteral)) {
					let indexLit = access.index;
					if(indexLit.literalType == loreline_LiteralType.Number) {
						let index = indexLit.value | 0;
						if(index >= 0 && index < elements.length) {
							let element = elements[index];
							if(((element) instanceof loreline_Node)) {
								return element;
							}
						}
					}
				}
			}
			break;
		case loreline_NObjectField:
			let field = targetNode;
			if(((field.value) instanceof loreline_NLiteral)) {
				let literal = field.value;
				if(literal.literalType == loreline_LiteralType.Array) {
					let elements = literal.value;
					if(((access.index) instanceof loreline_NLiteral)) {
						let indexLit = access.index;
						if(indexLit.literalType == loreline_LiteralType.Number) {
							let index = indexLit.value | 0;
							if(index >= 0 && index < elements.length) {
								let element = elements[index];
								if(((element) instanceof loreline_Node)) {
									return element;
								}
							}
						}
					}
				}
			}
			break;
		default:
		}
		return null;
	}
	resolveAccess(access) {
		if(access.target != null) {
			let targetNode = ((access.target) instanceof loreline_NAccess) ? this.resolveAccess(access.target) : ((access.target) instanceof loreline_NArrayAccess) ? this.resolveArrayAccess(access.target) : null;
			if(targetNode != null) {
				if(((targetNode) instanceof loreline_NObjectField)) {
					targetNode = targetNode.value;
				}
				switch(js_Boot.getClass(targetNode)) {
				case loreline_NCharacterDecl:
					let characterDecl = targetNode;
					let _g = 0;
					let _g1 = characterDecl.fields;
					while(_g < _g1.length) {
						let prop = _g1[_g];
						++_g;
						if(prop.name == access.name) {
							return prop;
						}
					}
					break;
				case loreline_NLiteral:
					let literal = targetNode;
					let _g2 = literal.literalType;
					if(_g2._hx_index == 4) {
						let style = _g2.style;
						let fields = literal.value;
						let _g = 0;
						while(_g < fields.length) {
							let field = fields[_g];
							++_g;
							if(field.name == access.name) {
								return field;
							}
						}
					}
					break;
				default:
				}
			}
			return null;
		}
		let name = access.name;
		if(name == null) {
			return null;
		}
		let currentBeat = this.getFirstParentOfType(access,loreline_NBeatDecl);
		while(currentBeat != null) {
			let result = null;
			this.traverse(currentBeat,function(node,parent) {
				if(result != null) {
					return false;
				}
				if(((node) instanceof loreline_NStateDecl)) {
					let stateDecl = node;
					let _g = 0;
					let _g1 = stateDecl.fields;
					while(_g < _g1.length) {
						let field = _g1[_g];
						++_g;
						if(field.name == name) {
							result = field;
							return false;
						}
					}
				}
				return true;
			});
			if(result != null) {
				return result;
			}
			currentBeat = this.getFirstParentOfType(currentBeat,loreline_NBeatDecl);
		}
		let stateField = null;
		this.traverse(this.script,function(node,parent) {
			if(stateField != null) {
				return false;
			}
			if(((node) instanceof loreline_NStateDecl)) {
				let stateDecl = node;
				let _g = 0;
				let _g1 = stateDecl.fields;
				while(_g < _g1.length) {
					let field = _g1[_g];
					++_g;
					if(field.name == name) {
						stateField = field;
						return false;
					}
				}
			}
			if(!((node) instanceof loreline_NImportStatement)) {
				return ((node) instanceof loreline_Script);
			} else {
				return true;
			}
		});
		if(stateField != null) {
			return stateField;
		}
		let characterDecl = this.findCharacterByNameFromNode(name,access);
		if(characterDecl != null) {
			return characterDecl;
		}
		let beatDecl = this.findBeatByNameFromNode(name,access);
		if(beatDecl != null) {
			return beatDecl;
		}
		let functionDecl = this.findFunctionByNameFromNode(name,access);
		if(functionDecl != null) {
			return functionDecl;
		}
		return null;
	}
	findBeatFromAccess(access) {
		if(access.target == null && access.name != null) {
			return this.findBeatByNameFromNode(access.name,access);
		}
		return null;
	}
	findBeatFromTransition(transition) {
		return this.findBeatByNameFromNode(transition.target,transition);
	}
	findBeatFromInsertion(insertion) {
		return this.findBeatByNameFromNode(insertion.target,insertion);
	}
	findBeatByPathFromNode(path,node) {
		let parts = path.split(".");
		let beat = this.findBeatByNameFromNode(parts[0],node);
		let i = 1;
		while(beat != null && i < parts.length) {
			let name = parts[i];
			let foundBeat = null;
			this.traverse(beat,function(node,parent) {
				if(((node) instanceof loreline_NBeatDecl)) {
					let beat = node;
					if(beat.name == name) {
						foundBeat = beat;
					}
					return false;
				} else {
					return foundBeat == null;
				}
			});
			beat = foundBeat;
			++i;
		}
		return beat;
	}
	isTopLevelNode(node) {
		if(((node) instanceof loreline_AstNode)) {
			let astNode = node;
			return this.script.body.indexOf(astNode) != -1;
		}
		return false;
	}
	findTopLevelBeatFromNode(node) {
		if(this.isTopLevelNode(node)) {
			if(((node) instanceof loreline_NBeatDecl)) {
				return node;
			} else {
				return null;
			}
		} else {
			let resolved = this.getFirstParentOfType(node,loreline_NBeatDecl);
			while(resolved != null && !this.isTopLevelNode(resolved)) resolved = this.getFirstParentOfType(resolved,loreline_NBeatDecl);
			if(resolved != null && ((resolved) instanceof loreline_NBeatDecl)) {
				return resolved;
			}
		}
		return null;
	}
	findBeatByNameFromNode(name,node) {
		let result = null;
		let parentBeat = this.getFirstParentOfType(node,loreline_NBeatDecl);
		while(parentBeat != null) {
			this.traverse(parentBeat,function(child,parent) {
				if(result != null || child == node) {
					return false;
				} else if(((child) instanceof loreline_NBeatDecl)) {
					let beatDecl = child;
					if(beatDecl.name == name) {
						result = beatDecl;
					}
					return false;
				}
				return true;
			});
			parentBeat = this.getFirstParentOfType(parentBeat,loreline_NBeatDecl);
		}
		if(result == null) {
			this.traverse(this.script,function(child,parent) {
				if(result == null && ((child) instanceof loreline_NBeatDecl)) {
					let beatDecl = child;
					if(beatDecl.name == name) {
						result = beatDecl;
					}
				}
				if(!((child) instanceof loreline_NImportStatement)) {
					return ((child) instanceof loreline_Script);
				} else {
					return true;
				}
			});
		}
		return result;
	}
	findCharacterFromDialogue(dialogue) {
		return this.findCharacterByNameFromNode(dialogue.character,dialogue);
	}
	findCharacterByNameFromNode(name,node) {
		let result = null;
		this.traverse(this.script,function(child,parent) {
			if(result == null && ((child) instanceof loreline_NCharacterDecl)) {
				let characterDecl = child;
				if(characterDecl.name == name) {
					result = characterDecl;
				}
			}
			if(!((child) instanceof loreline_NImportStatement)) {
				return ((child) instanceof loreline_Script);
			} else {
				return true;
			}
		});
		return result;
	}
	findFunctionByNameFromNode(name,node) {
		let result = null;
		this.traverse(this.script,function(child,parent) {
			if(result == null && ((child) instanceof loreline_NFunctionDecl)) {
				let functionDecl = child;
				if(functionDecl.name == name) {
					result = functionDecl;
				}
			}
			if(!((child) instanceof loreline_NImportStatement)) {
				return ((child) instanceof loreline_Script);
			} else {
				return true;
			}
		});
		return result;
	}
	getVisibleCharacters() {
		let result = [];
		let node = this.script.iterator();
		while(node.hasNext()) {
			let node1 = node.next();
			if(((node1) instanceof loreline_NCharacterDecl)) {
				result.push(node1);
			}
		}
		return result;
	}
	getVisibleFunctions() {
		let result = [];
		let node = this.script.iterator();
		while(node.hasNext()) {
			let node1 = node.next();
			if(((node1) instanceof loreline_NFunctionDecl)) {
				result.push(node1);
			}
		}
		return result;
	}
	getVisibleStateFields(fromNode) {
		let fields = [];
		let seenFields_map = new loreline_Int64Map();
		let current = fromNode;
		while(current != null) {
			if(js_Boot.getClass(current) == loreline_NStateDecl) {
				let state = current;
				let _g = 0;
				let _g1 = state.fields;
				while(_g < _g1.length) {
					let field = _g1[_g];
					++_g;
					let key = field.id.thisVal;
					if(!seenFields_map._exists(key.high,key.low)) {
						let key = field.id.thisVal;
						seenFields_map._set(key.high,key.low,true);
						fields.push(field);
					}
				}
			}
			let key = current.id.thisVal;
			current = this.parentNodes.map._get(key.high,key.low);
		}
		this.script.each(function(node,parent) {
			if(js_Boot.getClass(node) == loreline_NStateDecl) {
				let state = node;
				if(((parent) instanceof loreline_Script)) {
					let _g = 0;
					let _g1 = state.fields;
					while(_g < _g1.length) {
						let field = _g1[_g];
						++_g;
						let key = field.id.thisVal;
						if(!seenFields_map._exists(key.high,key.low)) {
							let key = field.id.thisVal;
							seenFields_map._set(key.high,key.low,true);
							fields.push(field);
						}
					}
				}
			}
		});
		return fields;
	}
	getVisibleBeats(fromNode) {
		let beats = [];
		let seenBeats_h = Object.create(null);
		let current = this.getParentNode(fromNode);
		while(current != null) {
			if(js_Boot.getClass(current) == loreline_NBeatDecl) {
				let parent = this.getParentNode(current);
				if(parent != null) {
					let _g = 0;
					let _g1 = this.getNodesOfType(loreline_NBeatDecl);
					while(_g < _g1.length) {
						let child = _g1[_g];
						++_g;
						if(!Object.prototype.hasOwnProperty.call(seenBeats_h,child.name)) {
							seenBeats_h[child.name] = true;
							beats.push(child);
						}
					}
				}
			}
			current = this.getParentNode(current);
		}
		this.script.each(function(node,parent) {
			if(js_Boot.getClass(node) == loreline_NBeatDecl) {
				if(((parent) instanceof loreline_Script)) {
					let beat = node;
					if(!Object.prototype.hasOwnProperty.call(seenBeats_h,beat.name)) {
						seenBeats_h[beat.name] = true;
						beats.push(beat);
					}
				}
			}
		});
		return beats;
	}
	getAllTags() {
		let tags_h = Object.create(null);
		this.script.each(function(node,parent) {
			let astNode = ((node) instanceof loreline_AstNode) ? node : null;
			if(astNode != null && astNode.trailingComments != null) {
				let _g = 0;
				let _g1 = astNode.trailingComments;
				while(_g < _g1.length) {
					let comment = _g1[_g];
					++_g;
					if(comment.isHash) {
						let key = StringTools.trim(comment.content);
						tags_h[key] = true;
					}
				}
			}
		});
		let _g = [];
		let h = tags_h;
		let tag_h = h;
		let tag_keys = Object.keys(h);
		let tag_length = tag_keys.length;
		let tag_current = 0;
		while(tag_current < tag_length) {
			let tag = tag_keys[tag_current++];
			_g.push(tag);
		}
		return _g;
	}
	countTags() {
		let tags = new haxe_ds_StringMap();
		this.script.each(function(node,parent) {
			let astNode = ((node) instanceof loreline_AstNode) ? node : null;
			if(astNode != null && astNode.trailingComments != null) {
				let _g = 0;
				let _g1 = astNode.trailingComments;
				while(_g < _g1.length) {
					let comment = _g1[_g];
					++_g;
					if(comment.isHash) {
						let text = StringTools.trim(comment.content);
						let tmp = tags.h[text];
						let prevCount = tmp != null ? tmp : 0;
						tags.h[text] = prevCount + 1;
					}
				}
			}
		});
		return tags;
	}
	findStateField(access) {
		if(access.target != null) {
			return null;
		}
		let stateFields = this.getVisibleStateFields(access);
		let _g = 0;
		while(_g < stateFields.length) {
			let field = stateFields[_g];
			++_g;
			if(field.name == access.name) {
				return field;
			}
		}
		return null;
	}
	findOutboundBeats(beatDecl) {
		let targetBeats_map = new loreline_Int64Map();
		let _gthis = this;
		this.traverse(beatDecl,function(node,parent) {
			switch(js_Boot.getClass(node)) {
			case loreline_NCall:
				let call = node;
				if(((call.target) instanceof loreline_NAccess)) {
					let access = call.target;
					if(access.target == null) {
						let targetBeat = _gthis.findBeatFromAccess(access);
						if(targetBeat != null) {
							let key = targetBeat.id;
							let value = new loreline_Reference(targetBeat,call);
							let key1 = key.thisVal;
							targetBeats_map._set(key1.high,key1.low,value);
						}
					}
				}
				break;
			case loreline_NInsertion:
				let insertion = node;
				let targetBeat = _gthis.findBeatByNameFromNode(insertion.target,insertion);
				if(targetBeat != null) {
					let key = targetBeat.id;
					let value = new loreline_Reference(targetBeat,insertion);
					let key1 = key.thisVal;
					targetBeats_map._set(key1.high,key1.low,value);
				}
				break;
			case loreline_NTransition:
				let transition = node;
				let targetBeat1 = _gthis.findBeatByNameFromNode(transition.target,transition);
				if(targetBeat1 != null) {
					let key = targetBeat1.id;
					let value = new loreline_Reference(targetBeat1,transition);
					let key1 = key.thisVal;
					targetBeats_map._set(key1.high,key1.low,value);
				}
				break;
			default:
			}
			return true;
		});
		let _g = [];
		let _g_map = targetBeats_map;
		let _g_index = 0;
		while(_g_index < _g_map._values.length && _g_map._values[_g_index] == null) ++_g_index;
		while(_g_index < _g_map._values.length) {
			let v = _g_map._values[_g_index];
			++_g_index;
			while(_g_index < _g_map._values.length && _g_map._values[_g_index] == null) ++_g_index;
			let ref = v;
			_g.push(ref);
		}
		return _g;
	}
	findReferencesToBeat(beatDecl) {
		let references = [];
		let _gthis = this;
		this.script.each(function(node,parent) {
			switch(js_Boot.getClass(node)) {
			case loreline_NCall:
				let call = node;
				if(((call.target) instanceof loreline_NAccess)) {
					let access = call.target;
					if(access.target == null && access.name == beatDecl.name) {
						let foundBeat = _gthis.findBeatFromAccess(access);
						if(foundBeat != null && foundBeat.id == beatDecl.id) {
							references.push(new loreline_Reference(beatDecl,call));
						}
					}
				}
				break;
			case loreline_NInsertion:
				let insertion = node;
				if(insertion.target == beatDecl.name) {
					references.push(new loreline_Reference(beatDecl,insertion));
				}
				break;
			case loreline_NTransition:
				let transition = node;
				if(transition.target == beatDecl.name) {
					references.push(new loreline_Reference(beatDecl,transition));
				}
				break;
			default:
			}
		});
		return references;
	}
	findModifiedStateFields(beatDecl) {
		let modifiedFields_h = Object.create(null);
		let _gthis = this;
		this.traverse(beatDecl,function(node,parent) {
			if(js_Boot.getClass(node) == loreline_NAssign) {
				let assign = node;
				if(((assign.target) instanceof loreline_NAccess)) {
					let access = assign.target;
					let field = _gthis.findStateField(access);
					if(field != null) {
						let key = field.name;
						let value = new loreline_Reference(field,assign);
						modifiedFields_h[key] = value;
					}
				}
			}
			return true;
		});
		let _g = [];
		let h = modifiedFields_h;
		let ref_h = h;
		let ref_keys = Object.keys(h);
		let ref_length = ref_keys.length;
		let ref_current = 0;
		while(ref_current < ref_length) {
			let ref = ref_h[ref_keys[ref_current++]];
			_g.push(ref);
		}
		let refs = _g;
		refs.sort(function(a,b) {
			let aName = a.target.name.toLowerCase();
			let bName = b.target.name.toLowerCase();
			if(aName < bName) {
				return -1;
			} else if(aName > bName) {
				return 1;
			} else {
				return 0;
			}
		});
		return refs;
	}
	findReadStateFields(beatDecl) {
		let readFields_h = Object.create(null);
		let _gthis = this;
		this.traverse(beatDecl,function(node,parent) {
			if(js_Boot.getClass(node) == loreline_NAccess) {
				let access = node;
				if(((parent) instanceof loreline_NAssign)) {
					let assign = parent;
					if(assign.target == node) {
						return true;
					}
				}
				let field = _gthis.findStateField(access);
				if(field != null) {
					let key = field.name;
					let value = new loreline_Reference(field,access);
					readFields_h[key] = value;
				}
			}
			return true;
		});
		let _g = [];
		let h = readFields_h;
		let ref_h = h;
		let ref_keys = Object.keys(h);
		let ref_length = ref_keys.length;
		let ref_current = 0;
		while(ref_current < ref_length) {
			let ref = ref_h[ref_keys[ref_current++]];
			_g.push(ref);
		}
		let refs = _g;
		refs.sort(function(a,b) {
			let aName = a.target.name.toLowerCase();
			let bName = b.target.name.toLowerCase();
			if(aName < bName) {
				return -1;
			} else if(aName > bName) {
				return 1;
			} else {
				return 0;
			}
		});
		return refs;
	}
	findBeatCharacters(beatDecl) {
		let characters_map = new loreline_Int64Map();
		let _gthis = this;
		this.traverse(beatDecl,function(node,parent) {
			switch(js_Boot.getClass(node)) {
			case loreline_NAccess:
				let access = node;
				if(access.target == null) {
					let character = _gthis.findCharacterByNameFromNode(access.name,access);
					if(character != null) {
						let key = character.id;
						let value = new loreline_Reference(character,access);
						let key1 = key.thisVal;
						characters_map._set(key1.high,key1.low,value);
					}
				}
				break;
			case loreline_NDialogueStatement:
				let dialogue = node;
				let character = _gthis.findCharacterFromDialogue(dialogue);
				if(character != null) {
					let key = character.id;
					let value = new loreline_Reference(character,dialogue);
					let key1 = key.thisVal;
					characters_map._set(key1.high,key1.low,value);
				}
				break;
			default:
			}
			return true;
		});
		let _g = [];
		let _g_map = characters_map;
		let _g_index = 0;
		while(_g_index < _g_map._values.length && _g_map._values[_g_index] == null) ++_g_index;
		while(_g_index < _g_map._values.length) {
			let v = _g_map._values[_g_index];
			++_g_index;
			while(_g_index < _g_map._values.length && _g_map._values[_g_index] == null) ++_g_index;
			let ref = v;
			_g.push(ref);
		}
		let refs = _g;
		refs.sort(function(a,b) {
			let aName = a.target.name.toLowerCase();
			let bName = b.target.name.toLowerCase();
			if(aName < bName) {
				return -1;
			} else if(aName > bName) {
				return 1;
			} else {
				return 0;
			}
		});
		return refs;
	}
	findModifiedCharacterFields(beatDecl) {
		let used_map = new loreline_Int64Map();
		let refs = [];
		let _gthis = this;
		this.traverse(beatDecl,function(node,parent) {
			if(js_Boot.getClass(node) == loreline_NAssign) {
				let assign = node;
				if(((assign.target) instanceof loreline_NAccess)) {
					let access = assign.target;
					let resolved = _gthis.resolveAccess(access);
					if(((resolved) instanceof loreline_NObjectField)) {
						let key = resolved.id.thisVal;
						if(!used_map._exists(key.high,key.low)) {
							let parent = _gthis.getParentNode(resolved);
							if(((parent) instanceof loreline_NCharacterDecl)) {
								let key = resolved.id.thisVal;
								used_map._set(key.high,key.low,true);
								refs.push(new loreline_Reference(resolved,node));
							}
						}
					}
				}
			}
			return true;
		});
		return refs;
	}
	findReadCharacterFields(beatDecl) {
		let used_map = new loreline_Int64Map();
		let refs = [];
		let _gthis = this;
		this.traverse(beatDecl,function(node,parent) {
			if(js_Boot.getClass(node) == loreline_NAccess) {
				let access = node;
				let parent = _gthis.getParentNode(access);
				if(((parent) instanceof loreline_NAssign)) {
					let assign = parent;
					if(assign.target == access) {
						return true;
					}
				}
				let resolved = _gthis.resolveAccess(access);
				if(((resolved) instanceof loreline_NObjectField)) {
					let key = resolved.id.thisVal;
					if(!used_map._exists(key.high,key.low)) {
						let parent = _gthis.getParentNode(resolved);
						if(((parent) instanceof loreline_NCharacterDecl)) {
							let key = resolved.id.thisVal;
							used_map._set(key.high,key.low,true);
							refs.push(new loreline_Reference(resolved,node));
						}
					}
				}
			}
			return true;
		});
		return refs;
	}
	traverse(node,callback) {
		let key = node.id.thisVal;
		let children = this.childNodes.map._get(key.high,key.low);
		if(children != null) {
			let _g = 0;
			let _g1 = children.length;
			while(_g < _g1) {
				let i = _g++;
				let child = children[i];
				if(callback(child,node)) {
					this.traverse(child,callback);
				}
			}
		}
	}
	getFuncHscript(func) {
		let id = func.id;
		let key = id.thisVal;
		let info = this.hscriptFunctions.map._get(key.high,key.low);
		if(info == null) {
			info = new loreline_FuncHscript(func);
			let key = id.thisVal;
			this.hscriptFunctions.map._set(key.high,key.low,info);
		}
		return info;
	}
	getHscriptExpr(func,pos) {
		let info = this.getFuncHscript(func);
		if(info.expr == null) {
			return null;
		}
		let offset = pos.offset - func.pos.offset;
		let bestExpr = null;
		let handler = null;
		handler = function(expr) {
			if(expr != null) {
				let min = info.codeToHscript.inputPosFromProcessedPos(expr.pmin);
				let max = info.codeToHscript.inputPosFromProcessedPos(expr.pmax);
				if(offset >= min && offset <= max) {
					bestExpr = expr;
				}
				hscript_Tools.iter(expr,handler);
			}
		};
		hscript_Tools.iter(info.expr,handler);
		return bestExpr;
	}
	resolveHscriptAccess(func,expr) {
		let _g = expr.e;
		switch(_g._hx_index) {
		case 1:
			let name = _g.v;
			let stateField = null;
			this.traverse(this.script,function(node,parent) {
				if(stateField != null) {
					return false;
				}
				if(((node) instanceof loreline_NStateDecl)) {
					let stateDecl = node;
					let _g = 0;
					let _g1 = stateDecl.fields;
					while(_g < _g1.length) {
						let field = _g1[_g];
						++_g;
						if(field.name == name) {
							stateField = field;
							return false;
						}
					}
				}
				if(!((node) instanceof loreline_NImportStatement)) {
					return ((node) instanceof loreline_Script);
				} else {
					return true;
				}
			});
			if(stateField != null) {
				return stateField;
			}
			let characterDecl = this.findCharacterByNameFromNode(name,func);
			if(characterDecl != null) {
				return characterDecl;
			}
			let beatDecl = this.findBeatByNameFromNode(name,func);
			if(beatDecl != null) {
				return beatDecl;
			}
			break;
		case 5:
			let e = _g.e;
			let f = _g.f;
			let targetNode = e != null ? this.resolveHscriptAccess(func,e) : null;
			if(targetNode != null) {
				if(((targetNode) instanceof loreline_NObjectField)) {
					targetNode = targetNode.value;
				}
				switch(js_Boot.getClass(targetNode)) {
				case loreline_NCharacterDecl:
					let characterDecl = targetNode;
					let _g = 0;
					let _g1 = characterDecl.fields;
					while(_g < _g1.length) {
						let prop = _g1[_g];
						++_g;
						if(prop.name == f) {
							return prop;
						}
					}
					break;
				case loreline_NLiteral:
					let literal = targetNode;
					let _g2 = literal.literalType;
					if(_g2._hx_index == 4) {
						let style = _g2.style;
						let fields = literal.value;
						let _g = 0;
						while(_g < fields.length) {
							let field = fields[_g];
							++_g;
							if(field.name == f) {
								return field;
							}
						}
					}
					break;
				default:
				}
			}
			break;
		case 16:
			let e1 = _g.e;
			let index = _g.index;
			break;
		default:
		}
		return null;
	}
	isHscriptExpr(input) {
		if(input != null && Object.prototype.hasOwnProperty.call(input,"e")) {
			return js_Boot.__instanceof(Reflect.field(input,"e"),hscript_ExprDef);
		} else {
			return false;
		}
	}
	getHscriptCompletion(func,pos) {
		let info = this.getFuncHscript(func);
		let inputPos = pos.offset - func.pos.offset + pos.length;
		let processedPos = info.codeToHscript.processedPosFromInputPos(inputPos);
		let truncated = info.hscript.substring(0,Math.min(processedPos,info.hscript.length) | 0);
		let fullLen = truncated.length;
		truncated = truncated.substring(truncated.indexOf("{",null) + 1,fullLen);
		let truncatedLen = truncated.length;
		let spaces_b = "";
		let _g = 0;
		let _g1 = fullLen - truncatedLen;
		while(_g < _g1) {
			let i = _g++;
			spaces_b += String.fromCodePoint(32);
		}
		truncated = spaces_b + truncated;
		let completion = null;
		let checker = new hscript_Checker();
		try {
			checker.types.parser.allowJSON = true;
			checker.types.parser.allowTypes = true;
			checker.types.parser.resumeErrors = true;
			let expr = checker.types.parser.parseString(truncated);
			checker.check(expr,null,true);
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			if(((e) instanceof hscript_Completion)) {
				completion = e;
			}
		}
		let locals = checker.locals;
		return new loreline_HscriptCompletion(locals,completion);
	}
	resolveAccessInFunction(func,pos) {
		let info = this.getFuncHscript(func);
		if(info.expr == null) {
			return null;
		}
		let expr = this.getHscriptExpr(func,pos);
		if(expr != null) {
			return this.resolveHscriptAccess(func,expr);
		}
		return null;
	}
}
$hxClasses["loreline.Lens"] = loreline_Lens;
loreline_Lens.__name__ = "loreline.Lens";
Object.assign(loreline_Lens.prototype, {
	__class__: loreline_Lens
});
class loreline_LexerError extends loreline_Error {
	constructor(message,pos) {
		super(message,pos);
	}
}
$hxClasses["loreline.LexerError"] = loreline_LexerError;
loreline_LexerError.__name__ = "loreline.LexerError";
loreline_LexerError.__super__ = loreline_Error;
Object.assign(loreline_LexerError.prototype, {
	__class__: loreline_LexerError
});
var loreline_LStringAttachment = $hxEnums["loreline.LStringAttachment"] = { __ename__:"loreline.LStringAttachment",__constructs__:null
	,Interpolation: ($_=function(braces,inTag,expr,start,length) { return {_hx_index:0,braces:braces,inTag:inTag,expr:expr,start:start,length:length,__enum__:"loreline.LStringAttachment",toString:$estr}; },$_._hx_name="Interpolation",$_.__params__ = ["braces","inTag","expr","start","length"],$_)
	,Tag: ($_=function(closing,start,length) { return {_hx_index:1,closing:closing,start:start,length:length,__enum__:"loreline.LStringAttachment",toString:$estr}; },$_._hx_name="Tag",$_.__params__ = ["closing","start","length"],$_)
};
loreline_LStringAttachment.__constructs__ = [loreline_LStringAttachment.Interpolation,loreline_LStringAttachment.Tag];
class loreline_TokenStackType {
	static toString(this1) {
		switch(this1) {
		case 0:
			return "ChoiceBrace";
		case 1:
			return "ChoiceIndent";
		case 2:
			return "StateBrace";
		case 3:
			return "StateIndent";
		case 4:
			return "CharacterBrace";
		case 5:
			return "CharacterIndent";
		case 6:
			return "BeatBrace";
		case 7:
			return "BeatIndent";
		case 8:
			return "Brace";
		case 9:
			return "Indent";
		case 10:
			return "Bracket";
		}
	}
}
var loreline_TokenType = $hxEnums["loreline.TokenType"] = { __ename__:"loreline.TokenType",__constructs__:null
	,KwImport: {_hx_name:"KwImport",_hx_index:0,__enum__:"loreline.TokenType",toString:$estr}
	,KwState: {_hx_name:"KwState",_hx_index:1,__enum__:"loreline.TokenType",toString:$estr}
	,KwBeat: {_hx_name:"KwBeat",_hx_index:2,__enum__:"loreline.TokenType",toString:$estr}
	,KwCharacter: {_hx_name:"KwCharacter",_hx_index:3,__enum__:"loreline.TokenType",toString:$estr}
	,KwChoice: {_hx_name:"KwChoice",_hx_index:4,__enum__:"loreline.TokenType",toString:$estr}
	,KwIf: {_hx_name:"KwIf",_hx_index:5,__enum__:"loreline.TokenType",toString:$estr}
	,KwElse: {_hx_name:"KwElse",_hx_index:6,__enum__:"loreline.TokenType",toString:$estr}
	,KwNew: {_hx_name:"KwNew",_hx_index:7,__enum__:"loreline.TokenType",toString:$estr}
	,Function: ($_=function(name,args,code,external) { return {_hx_index:8,name:name,args:args,code:code,external:external,__enum__:"loreline.TokenType",toString:$estr}; },$_._hx_name="Function",$_.__params__ = ["name","args","code","external"],$_)
	,LString: ($_=function(quotes,s,attachments) { return {_hx_index:9,quotes:quotes,s:s,attachments:attachments,__enum__:"loreline.TokenType",toString:$estr}; },$_._hx_name="LString",$_.__params__ = ["quotes","s","attachments"],$_)
	,LNumber: ($_=function(n) { return {_hx_index:10,n:n,__enum__:"loreline.TokenType",toString:$estr}; },$_._hx_name="LNumber",$_.__params__ = ["n"],$_)
	,LBoolean: ($_=function(b) { return {_hx_index:11,b:b,__enum__:"loreline.TokenType",toString:$estr}; },$_._hx_name="LBoolean",$_.__params__ = ["b"],$_)
	,LNull: {_hx_name:"LNull",_hx_index:12,__enum__:"loreline.TokenType",toString:$estr}
	,Identifier: ($_=function(name) { return {_hx_index:13,name:name,__enum__:"loreline.TokenType",toString:$estr}; },$_._hx_name="Identifier",$_.__params__ = ["name"],$_)
	,OpAssign: {_hx_name:"OpAssign",_hx_index:14,__enum__:"loreline.TokenType",toString:$estr}
	,OpPlusAssign: {_hx_name:"OpPlusAssign",_hx_index:15,__enum__:"loreline.TokenType",toString:$estr}
	,OpMinusAssign: {_hx_name:"OpMinusAssign",_hx_index:16,__enum__:"loreline.TokenType",toString:$estr}
	,OpMultiplyAssign: {_hx_name:"OpMultiplyAssign",_hx_index:17,__enum__:"loreline.TokenType",toString:$estr}
	,OpDivideAssign: {_hx_name:"OpDivideAssign",_hx_index:18,__enum__:"loreline.TokenType",toString:$estr}
	,OpPlus: {_hx_name:"OpPlus",_hx_index:19,__enum__:"loreline.TokenType",toString:$estr}
	,OpMinus: {_hx_name:"OpMinus",_hx_index:20,__enum__:"loreline.TokenType",toString:$estr}
	,OpMultiply: {_hx_name:"OpMultiply",_hx_index:21,__enum__:"loreline.TokenType",toString:$estr}
	,OpDivide: {_hx_name:"OpDivide",_hx_index:22,__enum__:"loreline.TokenType",toString:$estr}
	,OpModulo: {_hx_name:"OpModulo",_hx_index:23,__enum__:"loreline.TokenType",toString:$estr}
	,OpEquals: {_hx_name:"OpEquals",_hx_index:24,__enum__:"loreline.TokenType",toString:$estr}
	,OpNotEquals: {_hx_name:"OpNotEquals",_hx_index:25,__enum__:"loreline.TokenType",toString:$estr}
	,OpGreater: {_hx_name:"OpGreater",_hx_index:26,__enum__:"loreline.TokenType",toString:$estr}
	,OpLess: {_hx_name:"OpLess",_hx_index:27,__enum__:"loreline.TokenType",toString:$estr}
	,OpGreaterEq: {_hx_name:"OpGreaterEq",_hx_index:28,__enum__:"loreline.TokenType",toString:$estr}
	,OpLessEq: {_hx_name:"OpLessEq",_hx_index:29,__enum__:"loreline.TokenType",toString:$estr}
	,OpAnd: ($_=function(word) { return {_hx_index:30,word:word,__enum__:"loreline.TokenType",toString:$estr}; },$_._hx_name="OpAnd",$_.__params__ = ["word"],$_)
	,OpOr: ($_=function(word) { return {_hx_index:31,word:word,__enum__:"loreline.TokenType",toString:$estr}; },$_._hx_name="OpOr",$_.__params__ = ["word"],$_)
	,OpNot: {_hx_name:"OpNot",_hx_index:32,__enum__:"loreline.TokenType",toString:$estr}
	,Arrow: {_hx_name:"Arrow",_hx_index:33,__enum__:"loreline.TokenType",toString:$estr}
	,Colon: {_hx_name:"Colon",_hx_index:34,__enum__:"loreline.TokenType",toString:$estr}
	,Comma: {_hx_name:"Comma",_hx_index:35,__enum__:"loreline.TokenType",toString:$estr}
	,Dot: {_hx_name:"Dot",_hx_index:36,__enum__:"loreline.TokenType",toString:$estr}
	,LBrace: {_hx_name:"LBrace",_hx_index:37,__enum__:"loreline.TokenType",toString:$estr}
	,RBrace: {_hx_name:"RBrace",_hx_index:38,__enum__:"loreline.TokenType",toString:$estr}
	,LParen: {_hx_name:"LParen",_hx_index:39,__enum__:"loreline.TokenType",toString:$estr}
	,RParen: {_hx_name:"RParen",_hx_index:40,__enum__:"loreline.TokenType",toString:$estr}
	,LBracket: {_hx_name:"LBracket",_hx_index:41,__enum__:"loreline.TokenType",toString:$estr}
	,RBracket: {_hx_name:"RBracket",_hx_index:42,__enum__:"loreline.TokenType",toString:$estr}
	,CommentLine: ($_=function(content) { return {_hx_index:43,content:content,__enum__:"loreline.TokenType",toString:$estr}; },$_._hx_name="CommentLine",$_.__params__ = ["content"],$_)
	,CommentMultiLine: ($_=function(content) { return {_hx_index:44,content:content,__enum__:"loreline.TokenType",toString:$estr}; },$_._hx_name="CommentMultiLine",$_.__params__ = ["content"],$_)
	,CommentHash: ($_=function(content) { return {_hx_index:45,content:content,__enum__:"loreline.TokenType",toString:$estr}; },$_._hx_name="CommentHash",$_.__params__ = ["content"],$_)
	,Indent: {_hx_name:"Indent",_hx_index:46,__enum__:"loreline.TokenType",toString:$estr}
	,Unindent: {_hx_name:"Unindent",_hx_index:47,__enum__:"loreline.TokenType",toString:$estr}
	,LineBreak: {_hx_name:"LineBreak",_hx_index:48,__enum__:"loreline.TokenType",toString:$estr}
	,Eof: {_hx_name:"Eof",_hx_index:49,__enum__:"loreline.TokenType",toString:$estr}
};
loreline_TokenType.__constructs__ = [loreline_TokenType.KwImport,loreline_TokenType.KwState,loreline_TokenType.KwBeat,loreline_TokenType.KwCharacter,loreline_TokenType.KwChoice,loreline_TokenType.KwIf,loreline_TokenType.KwElse,loreline_TokenType.KwNew,loreline_TokenType.Function,loreline_TokenType.LString,loreline_TokenType.LNumber,loreline_TokenType.LBoolean,loreline_TokenType.LNull,loreline_TokenType.Identifier,loreline_TokenType.OpAssign,loreline_TokenType.OpPlusAssign,loreline_TokenType.OpMinusAssign,loreline_TokenType.OpMultiplyAssign,loreline_TokenType.OpDivideAssign,loreline_TokenType.OpPlus,loreline_TokenType.OpMinus,loreline_TokenType.OpMultiply,loreline_TokenType.OpDivide,loreline_TokenType.OpModulo,loreline_TokenType.OpEquals,loreline_TokenType.OpNotEquals,loreline_TokenType.OpGreater,loreline_TokenType.OpLess,loreline_TokenType.OpGreaterEq,loreline_TokenType.OpLessEq,loreline_TokenType.OpAnd,loreline_TokenType.OpOr,loreline_TokenType.OpNot,loreline_TokenType.Arrow,loreline_TokenType.Colon,loreline_TokenType.Comma,loreline_TokenType.Dot,loreline_TokenType.LBrace,loreline_TokenType.RBrace,loreline_TokenType.LParen,loreline_TokenType.RParen,loreline_TokenType.LBracket,loreline_TokenType.RBracket,loreline_TokenType.CommentLine,loreline_TokenType.CommentMultiLine,loreline_TokenType.CommentHash,loreline_TokenType.Indent,loreline_TokenType.Unindent,loreline_TokenType.LineBreak,loreline_TokenType.Eof];
class loreline_TokenTypeHelpers {
	static equals(a,b) {
		switch(a._hx_index) {
		case 1:
			if(b._hx_index == 1) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 2:
			if(b._hx_index == 2) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 3:
			if(b._hx_index == 3) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 4:
			if(b._hx_index == 4) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 5:
			if(b._hx_index == 5) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 6:
			if(b._hx_index == 6) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 7:
			if(b._hx_index == 7) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 9:
			let _g = a.s;
			let _g1 = a.attachments;
			if(b._hx_index == 9) {
				let _g = b.s;
				let _g1 = b.attachments;
				let s2 = b.quotes;
				let s1 = a.quotes;
				return s1 == s2;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 10:
			if(b._hx_index == 10) {
				let n2 = b.n;
				let n1 = a.n;
				return n1 == n2;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 11:
			if(b._hx_index == 11) {
				let b2 = b.b;
				let b1 = a.b;
				return b1 == b2;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 12:
			if(b._hx_index == 12) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 13:
			if(b._hx_index == 13) {
				let n2 = b.name;
				let n1 = a.name;
				return n1 == n2;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 14:
			if(b._hx_index == 14) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 15:
			if(b._hx_index == 15) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 16:
			if(b._hx_index == 16) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 17:
			if(b._hx_index == 17) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 18:
			if(b._hx_index == 18) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 19:
			if(b._hx_index == 19) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 20:
			if(b._hx_index == 20) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 21:
			if(b._hx_index == 21) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 22:
			if(b._hx_index == 22) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 23:
			if(b._hx_index == 23) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 24:
			if(b._hx_index == 24) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 25:
			if(b._hx_index == 25) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 26:
			if(b._hx_index == 26) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 27:
			if(b._hx_index == 27) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 28:
			if(b._hx_index == 28) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 29:
			if(b._hx_index == 29) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 30:
			let _g2 = a.word;
			if(b._hx_index == 30) {
				let _g = b.word;
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 31:
			let _g3 = a.word;
			if(b._hx_index == 31) {
				let _g = b.word;
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 32:
			if(b._hx_index == 32) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 33:
			if(b._hx_index == 33) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 34:
			if(b._hx_index == 34) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 36:
			if(b._hx_index == 36) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 37:
			if(b._hx_index == 37) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 38:
			if(b._hx_index == 38) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 39:
			if(b._hx_index == 39) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 40:
			if(b._hx_index == 40) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 41:
			if(b._hx_index == 41) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 42:
			if(b._hx_index == 42) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 43:
			if(b._hx_index == 43) {
				let c2 = b.content;
				let c1 = a.content;
				return c1 == c2;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 44:
			if(b._hx_index == 44) {
				let c2 = b.content;
				let c1 = a.content;
				return c1 == c2;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 45:
			if(b._hx_index == 45) {
				let c2 = b.content;
				let c1 = a.content;
				return c1 == c2;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 46:
			if(b._hx_index == 46) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 47:
			if(b._hx_index == 47) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 48:
			if(b._hx_index == 48) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		case 49:
			if(b._hx_index == 49) {
				return true;
			} else {
				return Type.enumEq(a,b);
			}
			break;
		default:
			return Type.enumEq(a,b);
		}
	}
	static isComment(a) {
		switch(a._hx_index) {
		case 43:
			let _g = a.content;
			return true;
		case 44:
			let _g1 = a.content;
			return true;
		case 45:
			let _g2 = a.content;
			return true;
		default:
			return false;
		}
	}
	static isAssignOp(a) {
		switch(a._hx_index) {
		case 14:case 15:case 16:case 17:case 18:
			return true;
		default:
			return false;
		}
	}
	static isIdentifier(a) {
		if(a._hx_index == 13) {
			let _g = a.name;
			return true;
		} else {
			return false;
		}
	}
	static isBlockStart(a) {
		switch(a._hx_index) {
		case 1:case 2:case 3:case 4:case 5:
			return true;
		default:
			return false;
		}
	}
	static toCodeString(a) {
		switch(a._hx_index) {
		case 0:
			return "import";
		case 1:
			return "state";
		case 2:
			return "beat";
		case 3:
			return "character";
		case 4:
			return "choice";
		case 5:
			return "if";
		case 6:
			return "else";
		case 7:
			return "new";
		case 8:
			let _g = a.name;
			let _g1 = a.args;
			let _g2 = a.code;
			let _g3 = a.external;
			return "function";
		case 9:
			let _g4 = a.quotes;
			let _g5 = a.s;
			let _g6 = a.attachments;
			return "string";
		case 10:
			let _g7 = a.n;
			return "number";
		case 11:
			let _g8 = a.b;
			return "boolean";
		case 12:
			return "null";
		case 13:
			let name = a.name;
			return "identifier";
		case 14:
			return "=";
		case 15:
			return "+=";
		case 16:
			return "-=";
		case 17:
			return "*=";
		case 18:
			return "/=";
		case 19:
			return "+";
		case 20:
			return "-";
		case 21:
			return "*";
		case 22:
			return "/";
		case 23:
			return "%";
		case 24:
			return "==";
		case 25:
			return "!=";
		case 26:
			return ">";
		case 27:
			return "<";
		case 28:
			return ">=";
		case 29:
			return "<=";
		case 30:
			let word = a.word;
			if(word) {
				return "and";
			} else {
				return "&&";
			}
			break;
		case 31:
			let word1 = a.word;
			if(word1) {
				return "or";
			} else {
				return "||";
			}
			break;
		case 32:
			return "!";
		case 33:
			return "->";
		case 34:
			return ":";
		case 35:
			return ",";
		case 36:
			return ".";
		case 37:
			return "{";
		case 38:
			return "}";
		case 39:
			return "(";
		case 40:
			return ")";
		case 41:
			return "[";
		case 42:
			return "]";
		case 43:
			let content = a.content;
			return "comment";
		case 44:
			let content1 = a.content;
			return "multiline comment";
		case 45:
			let content2 = a.content;
			return "hash comment";
		case 46:
			return "indent";
		case 47:
			return "unindent";
		case 48:
			return "line break";
		case 49:
			return "end of file";
		}
	}
}
$hxClasses["loreline.TokenTypeHelpers"] = loreline_TokenTypeHelpers;
loreline_TokenTypeHelpers.__name__ = "loreline.TokenTypeHelpers";
class loreline_Token {
	constructor(type,pos) {
		this.type = type;
		this.pos = pos;
	}
	toString() {
		return "" + Std.string(this.type) + " at " + this.pos.toString();
	}
}
$hxClasses["loreline.Token"] = loreline_Token;
loreline_Token.__name__ = "loreline.Token";
Object.assign(loreline_Token.prototype, {
	__class__: loreline_Token
});
class loreline_Lexer {
	constructor(input) {
		this.errors = null;
		this.allowTabs = true;
		this.detectedIndentSize = 2;
		this.indentSize = 4;
		this.indentTokens = [];
		this.indentStack = [];
		this.indentLevel = 0;
		this.input = input;
		this.length = input.length;
		this.reset();
	}
	reset() {
		this.pos = 0;
		this.line = 1;
		this.column = 1;
		this.startLine = 1;
		this.startColumn = 1;
		this.previous = null;
		this.stack = [];
		this.nextBlock = 8;
		this.tokenized = null;
		this.strictExprs = [];
		this.indentLevel = 0;
		this.indentStack = [0];
		this.indentTokens = [];
	}
	tokenize() {
		let tokens = [];
		this.tokenized = tokens;
		while(true) {
			let token = this.nextToken();
			if(token.type == loreline_TokenType.Eof) {
				if(this.indentStack.length > 1) {
					let count = this.indentStack.length - 1;
					let _g = 0;
					let _g1 = count;
					while(_g < _g1) {
						let _ = _g++;
						let position = null;
						if(position == null) {
							position = new loreline_Position(this.startLine,this.startColumn,this.pos);
						}
						position.length = this.pos - position.offset;
						let token = new loreline_Token(loreline_TokenType.Unindent,position);
						this.previous = token;
						tokens.push(token);
					}
				}
				break;
			}
			tokens.push(token);
			switch(token.type._hx_index) {
			case 1:
				this.nextBlock = 3;
				break;
			case 2:
				this.nextBlock = 7;
				break;
			case 3:
				this.nextBlock = 5;
				break;
			case 4:
				this.nextBlock = 1;
				break;
			case 37:
				let tmp;
				switch(this.nextBlock) {
				case 0:case 1:
					tmp = 0;
					break;
				case 2:case 3:
					tmp = 2;
					break;
				case 4:case 5:
					tmp = 4;
					break;
				case 6:case 7:
					tmp = 7;
					break;
				case 8:case 9:case 10:
					tmp = 8;
					break;
				}
				this.stack.push(tmp);
				this.nextBlock = 8;
				break;
			case 41:
				this.stack.push(10);
				this.nextBlock = 8;
				break;
			case 38:case 42:case 47:
				this.stack.pop();
				this.nextBlock = 8;
				break;
			case 46:
				let tmp1;
				switch(this.nextBlock) {
				case 0:case 1:
					tmp1 = 1;
					break;
				case 2:case 3:
					tmp1 = 3;
					break;
				case 4:case 5:
					tmp1 = 5;
					break;
				case 6:case 7:
					tmp1 = 7;
					break;
				case 8:case 9:case 10:
					tmp1 = 9;
					break;
				}
				this.stack.push(tmp1);
				this.nextBlock = 8;
				break;
			default:
			}
		}
		return tokens;
	}
	nextToken() {
		if(this.indentTokens.length > 0) {
			return this.indentTokens.shift();
		}
		this.skipWhitespace();
		if(this.pos >= this.length) {
			let position = null;
			if(position == null) {
				position = new loreline_Position(this.startLine,this.startColumn,this.pos);
			}
			position.length = this.pos - position.offset;
			let token = new loreline_Token(loreline_TokenType.Eof,position);
			this.previous = token;
			return token;
		}
		this.startLine = this.line;
		this.startColumn = this.column;
		let c = HxOverrides.cca(this.input,this.pos);
		if(c == 10 || c == 13) {
			let lineBreakToken = this.readLineBreak();
			let currentIndent = this.countIndentation();
			if(currentIndent > this.indentStack[this.indentStack.length - 1]) {
				if(this.indentStack.length == 1) {
					this.detectedIndentSize = currentIndent - this.indentStack[0];
				}
				this.indentStack.push(currentIndent);
				let tmp = this.indentTokens;
				let position = null;
				if(position == null) {
					position = new loreline_Position(this.startLine,this.startColumn,this.pos);
				}
				position.length = this.pos - position.offset;
				let token = new loreline_Token(loreline_TokenType.Indent,position);
				this.previous = token;
				tmp.push(token);
			} else if(currentIndent < this.indentStack[this.indentStack.length - 1]) {
				while(this.indentStack.length > 0 && currentIndent < this.indentStack[this.indentStack.length - 1]) {
					this.indentStack.pop();
					let tmp = this.indentTokens;
					let position = null;
					if(position == null) {
						position = new loreline_Position(this.startLine,this.startColumn,this.pos);
					}
					position.length = this.pos - position.offset;
					let token = new loreline_Token(loreline_TokenType.Unindent,position);
					this.previous = token;
					tmp.push(token);
				}
			}
			return lineBreakToken;
		}
		let startPos = new loreline_Position(this.startLine,this.startColumn,this.pos);
		if(this.tokenized.length > 0 && this.tokenized[this.tokenized.length - 1].type == loreline_TokenType.KwImport) {
			return this.readImportValue(c,startPos);
		}
		if(c == null) {
			let tmp = this.tryReadUnquotedString();
			if(tmp != null) {
				return tmp;
			} else if(c == null) {
				let c1 = c;
				if(c1 >= 48 && c1 <= 57) {
					return this.readNumber();
				} else {
					let c1 = c;
					if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
						return this.readIdentifier();
					} else {
						this.error("Unexpected character: " + String.fromCodePoint(c),true);
						return null;
					}
				}
			} else {
				switch(c) {
				case 33:
					let c1 = c;
					if(c1 >= 48 && c1 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
							let count = 2;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpNotEquals,position);
							this.previous = token;
							return token;
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpNot,position);
							this.previous = token;
							return token;
						}
					}
					break;
				case 35:
					let c2 = c;
					if(c2 >= 48 && c2 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else {
							let nextC = this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0;
							if(nextC >= 97 && nextC <= 122 || nextC >= 65 && nextC <= 90 || nextC == 95 || nextC >= 48 && nextC <= 57 || nextC == 45) {
								return this.readHashComment();
							} else {
								this.error("Unexpected character: #",true);
								return null;
							}
						}
					}
					break;
				case 37:
					let c3 = c;
					if(c3 >= 48 && c3 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpModulo,position);
							this.previous = token;
							return token;
						}
					}
					break;
				case 38:
					let c4 = c;
					if(c4 >= 48 && c4 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 38) {
							let count = 2;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpAnd(false),position);
							this.previous = token;
							return token;
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							this.error("Expected &",false);
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpAnd(false),position);
							this.previous = token;
							return token;
						}
					}
					break;
				case 40:
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					this.makeStrictIfFollowingCallable();
					let position = startPos;
					if(position == null) {
						position = new loreline_Position(this.startLine,this.startColumn,this.pos);
					}
					position.length = this.pos - position.offset;
					let token = new loreline_Token(loreline_TokenType.LParen,position);
					this.previous = token;
					return token;
				case 41:
					let count1 = 1;
					while(count1-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					this.strictExprs.pop();
					let position1 = startPos;
					if(position1 == null) {
						position1 = new loreline_Position(this.startLine,this.startColumn,this.pos);
					}
					position1.length = this.pos - position1.offset;
					let token1 = new loreline_Token(loreline_TokenType.RParen,position1);
					this.previous = token1;
					return token1;
				case 42:
					let c5 = c;
					if(c5 >= 48 && c5 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
							let count = 2;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpMultiplyAssign,position);
							this.previous = token;
							return token;
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpMultiply,position);
							this.previous = token;
							return token;
						}
					}
					break;
				case 43:
					let c6 = c;
					if(c6 >= 48 && c6 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
							let count = 2;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpPlusAssign,position);
							this.previous = token;
							return token;
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpPlus,position);
							this.previous = token;
							return token;
						}
					}
					break;
				case 44:
					let count2 = 1;
					while(count2-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					let position2 = startPos;
					if(position2 == null) {
						position2 = new loreline_Position(this.startLine,this.startColumn,this.pos);
					}
					position2.length = this.pos - position2.offset;
					let token2 = new loreline_Token(loreline_TokenType.Comma,position2);
					this.previous = token2;
					return token2;
				case 45:
					let c7 = c;
					if(c7 >= 48 && c7 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 62) {
							let count = 2;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.Arrow,position);
							this.previous = token;
							return token;
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
							let count = 2;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpMinusAssign,position);
							this.previous = token;
							return token;
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpMinus,position);
							this.previous = token;
							return token;
						}
					}
					break;
				case 46:
					let count3 = 1;
					while(count3-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					let position3 = startPos;
					if(position3 == null) {
						position3 = new loreline_Position(this.startLine,this.startColumn,this.pos);
					}
					position3.length = this.pos - position3.offset;
					let token3 = new loreline_Token(loreline_TokenType.Dot,position3);
					this.previous = token3;
					return token3;
				case 47:
					let c8 = c;
					if(c8 >= 48 && c8 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
							let count = 2;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpDivideAssign,position);
							this.previous = token;
							return token;
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 47) {
							return this.readLineComment();
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 42) {
							return this.readMultiLineComment();
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpDivide,position);
							this.previous = token;
							return token;
						}
					}
					break;
				case 58:
					let count4 = 1;
					while(count4-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					let position4 = startPos;
					if(position4 == null) {
						position4 = new loreline_Position(this.startLine,this.startColumn,this.pos);
					}
					position4.length = this.pos - position4.offset;
					let token4 = new loreline_Token(loreline_TokenType.Colon,position4);
					this.previous = token4;
					return token4;
				case 60:
					let c9 = c;
					if(c9 >= 48 && c9 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
							let count = 2;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpLessEq,position);
							this.previous = token;
							return token;
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpLess,position);
							this.previous = token;
							return token;
						}
					}
					break;
				case 61:
					let c10 = c;
					if(c10 >= 48 && c10 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
							let count = 2;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpEquals,position);
							this.previous = token;
							return token;
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpAssign,position);
							this.previous = token;
							return token;
						}
					}
					break;
				case 62:
					let c11 = c;
					if(c11 >= 48 && c11 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
							let count = 2;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpGreaterEq,position);
							this.previous = token;
							return token;
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpGreater,position);
							this.previous = token;
							return token;
						}
					}
					break;
				case 93:
					let count5 = 1;
					while(count5-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					this.strictExprs.pop();
					let position5 = startPos;
					if(position5 == null) {
						position5 = new loreline_Position(this.startLine,this.startColumn,this.pos);
					}
					position5.length = this.pos - position5.offset;
					let token5 = new loreline_Token(loreline_TokenType.RBracket,position5);
					this.previous = token5;
					return token5;
				case 124:
					let c12 = c;
					if(c12 >= 48 && c12 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 124) {
							let count = 2;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpOr(false),position);
							this.previous = token;
							return token;
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							this.error("Expected |",false);
							let position = startPos;
							if(position == null) {
								position = new loreline_Position(this.startLine,this.startColumn,this.pos);
							}
							position.length = this.pos - position.offset;
							let token = new loreline_Token(loreline_TokenType.OpOr(false),position);
							this.previous = token;
							return token;
						}
					}
					break;
				default:
					let c13 = c;
					if(c13 >= 48 && c13 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else {
							this.error("Unexpected character: " + String.fromCodePoint(c),true);
							return null;
						}
					}
				}
			}
		} else {
			switch(c) {
			case 34:
				return this.readString(startPos);
			case 91:
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				this.makeLooseOrStrictAfterBracket();
				let position = startPos;
				if(position == null) {
					position = new loreline_Position(this.startLine,this.startColumn,this.pos);
				}
				position.length = this.pos - position.offset;
				let token = new loreline_Token(loreline_TokenType.LBracket,position);
				this.previous = token;
				return token;
			case 123:
				let count1 = 1;
				while(count1-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				let position1 = startPos;
				if(position1 == null) {
					position1 = new loreline_Position(this.startLine,this.startColumn,this.pos);
				}
				position1.length = this.pos - position1.offset;
				let token1 = new loreline_Token(loreline_TokenType.LBrace,position1);
				this.previous = token1;
				return token1;
			case 125:
				let count2 = 1;
				while(count2-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				let position2 = startPos;
				if(position2 == null) {
					position2 = new loreline_Position(this.startLine,this.startColumn,this.pos);
				}
				position2.length = this.pos - position2.offset;
				let token2 = new loreline_Token(loreline_TokenType.RBrace,position2);
				this.previous = token2;
				return token2;
			default:
				let tmp = this.tryReadUnquotedString();
				if(tmp != null) {
					return tmp;
				} else if(c == null) {
					let c1 = c;
					if(c1 >= 48 && c1 <= 57) {
						return this.readNumber();
					} else {
						let c1 = c;
						if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
							return this.readIdentifier();
						} else {
							this.error("Unexpected character: " + String.fromCodePoint(c),true);
							return null;
						}
					}
				} else {
					switch(c) {
					case 33:
						let c1 = c;
						if(c1 >= 48 && c1 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
								let count = 2;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpNotEquals,position);
								this.previous = token;
								return token;
							} else {
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpNot,position);
								this.previous = token;
								return token;
							}
						}
						break;
					case 35:
						let c2 = c;
						if(c2 >= 48 && c2 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else {
								let nextC = this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0;
								if(nextC >= 97 && nextC <= 122 || nextC >= 65 && nextC <= 90 || nextC == 95 || nextC >= 48 && nextC <= 57 || nextC == 45) {
									return this.readHashComment();
								} else {
									this.error("Unexpected character: #",true);
									return null;
								}
							}
						}
						break;
					case 37:
						let c3 = c;
						if(c3 >= 48 && c3 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else {
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpModulo,position);
								this.previous = token;
								return token;
							}
						}
						break;
					case 38:
						let c4 = c;
						if(c4 >= 48 && c4 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 38) {
								let count = 2;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpAnd(false),position);
								this.previous = token;
								return token;
							} else {
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								this.error("Expected &",false);
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpAnd(false),position);
								this.previous = token;
								return token;
							}
						}
						break;
					case 40:
						let count3 = 1;
						while(count3-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
						this.makeStrictIfFollowingCallable();
						let position3 = startPos;
						if(position3 == null) {
							position3 = new loreline_Position(this.startLine,this.startColumn,this.pos);
						}
						position3.length = this.pos - position3.offset;
						let token3 = new loreline_Token(loreline_TokenType.LParen,position3);
						this.previous = token3;
						return token3;
					case 41:
						let count4 = 1;
						while(count4-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
						this.strictExprs.pop();
						let position4 = startPos;
						if(position4 == null) {
							position4 = new loreline_Position(this.startLine,this.startColumn,this.pos);
						}
						position4.length = this.pos - position4.offset;
						let token4 = new loreline_Token(loreline_TokenType.RParen,position4);
						this.previous = token4;
						return token4;
					case 42:
						let c5 = c;
						if(c5 >= 48 && c5 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
								let count = 2;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpMultiplyAssign,position);
								this.previous = token;
								return token;
							} else {
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpMultiply,position);
								this.previous = token;
								return token;
							}
						}
						break;
					case 43:
						let c6 = c;
						if(c6 >= 48 && c6 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
								let count = 2;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpPlusAssign,position);
								this.previous = token;
								return token;
							} else {
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpPlus,position);
								this.previous = token;
								return token;
							}
						}
						break;
					case 44:
						let count5 = 1;
						while(count5-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
						let position5 = startPos;
						if(position5 == null) {
							position5 = new loreline_Position(this.startLine,this.startColumn,this.pos);
						}
						position5.length = this.pos - position5.offset;
						let token5 = new loreline_Token(loreline_TokenType.Comma,position5);
						this.previous = token5;
						return token5;
					case 45:
						let c7 = c;
						if(c7 >= 48 && c7 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 62) {
								let count = 2;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.Arrow,position);
								this.previous = token;
								return token;
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
								let count = 2;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpMinusAssign,position);
								this.previous = token;
								return token;
							} else {
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpMinus,position);
								this.previous = token;
								return token;
							}
						}
						break;
					case 46:
						let count6 = 1;
						while(count6-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
						let position6 = startPos;
						if(position6 == null) {
							position6 = new loreline_Position(this.startLine,this.startColumn,this.pos);
						}
						position6.length = this.pos - position6.offset;
						let token6 = new loreline_Token(loreline_TokenType.Dot,position6);
						this.previous = token6;
						return token6;
					case 47:
						let c8 = c;
						if(c8 >= 48 && c8 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
								let count = 2;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpDivideAssign,position);
								this.previous = token;
								return token;
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 47) {
								return this.readLineComment();
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 42) {
								return this.readMultiLineComment();
							} else {
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpDivide,position);
								this.previous = token;
								return token;
							}
						}
						break;
					case 58:
						let count7 = 1;
						while(count7-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
						let position7 = startPos;
						if(position7 == null) {
							position7 = new loreline_Position(this.startLine,this.startColumn,this.pos);
						}
						position7.length = this.pos - position7.offset;
						let token7 = new loreline_Token(loreline_TokenType.Colon,position7);
						this.previous = token7;
						return token7;
					case 60:
						let c9 = c;
						if(c9 >= 48 && c9 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
								let count = 2;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpLessEq,position);
								this.previous = token;
								return token;
							} else {
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpLess,position);
								this.previous = token;
								return token;
							}
						}
						break;
					case 61:
						let c10 = c;
						if(c10 >= 48 && c10 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
								let count = 2;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpEquals,position);
								this.previous = token;
								return token;
							} else {
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpAssign,position);
								this.previous = token;
								return token;
							}
						}
						break;
					case 62:
						let c11 = c;
						if(c11 >= 48 && c11 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 61) {
								let count = 2;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpGreaterEq,position);
								this.previous = token;
								return token;
							} else {
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpGreater,position);
								this.previous = token;
								return token;
							}
						}
						break;
					case 93:
						let count8 = 1;
						while(count8-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
						this.strictExprs.pop();
						let position8 = startPos;
						if(position8 == null) {
							position8 = new loreline_Position(this.startLine,this.startColumn,this.pos);
						}
						position8.length = this.pos - position8.offset;
						let token8 = new loreline_Token(loreline_TokenType.RBracket,position8);
						this.previous = token8;
						return token8;
					case 124:
						let c12 = c;
						if(c12 >= 48 && c12 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else if((this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 124) {
								let count = 2;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpOr(false),position);
								this.previous = token;
								return token;
							} else {
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								this.error("Expected |",false);
								let position = startPos;
								if(position == null) {
									position = new loreline_Position(this.startLine,this.startColumn,this.pos);
								}
								position.length = this.pos - position.offset;
								let token = new loreline_Token(loreline_TokenType.OpOr(false),position);
								this.previous = token;
								return token;
							}
						}
						break;
					default:
						let c13 = c;
						if(c13 >= 48 && c13 <= 57) {
							return this.readNumber();
						} else {
							let c1 = c;
							if(c1 >= 97 && c1 <= 122 || c1 >= 65 && c1 <= 90 || c1 == 95) {
								return this.readIdentifier();
							} else {
								this.error("Unexpected character: " + String.fromCodePoint(c),true);
								return null;
							}
						}
					}
				}
			}
		}
	}
	countIndentation() {
		let pos = this.pos;
		let spaces = 0;
		while(pos < this.length) {
			let c = HxOverrides.cca(this.input,pos);
			if(c == 32) {
				++spaces;
			} else if(c == 9) {
				++spaces;
			} else {
				break;
			}
			++pos;
		}
		if(pos >= this.length || HxOverrides.cca(this.input,pos) == 10 || HxOverrides.cca(this.input,pos) == 13) {
			return this.indentStack[this.indentStack.length - 1];
		}
		return spaces;
	}
	parentBlockType() {
		let i = this.stack.length - 1;
		while(i >= 0) {
			if(this.stack[i] != 8 && this.stack[i] != 9 && this.stack[i] != 10) {
				switch(this.stack[i]) {
				case 0:case 1:
					return loreline_TokenType.KwBeat;
				case 2:case 3:
					return loreline_TokenType.KwState;
				case 4:case 5:
					return loreline_TokenType.KwCharacter;
				case 6:case 7:
					return loreline_TokenType.KwBeat;
				case 8:
					return loreline_TokenType.LBrace;
				case 9:
					return loreline_TokenType.Indent;
				case 10:
					return loreline_TokenType.LBracket;
				}
			}
			--i;
		}
		return loreline_TokenType.KwBeat;
	}
	inBeat() {
		return this.parentBlockType() == loreline_TokenType.KwBeat;
	}
	inChoiceRoot() {
		if(this.stack.length > 0) {
			if(this.stack[this.stack.length - 1] != 1) {
				return this.stack[this.stack.length - 1] == 0;
			} else {
				return true;
			}
		} else {
			return false;
		}
	}
	inStateOrCharacter() {
		let parent = this.parentBlockType();
		if(parent != loreline_TokenType.KwState) {
			return parent == loreline_TokenType.KwCharacter;
		} else {
			return true;
		}
	}
	readLineBreak() {
		let start = new loreline_Position(this.startLine,this.startColumn,this.pos);
		if(HxOverrides.cca(this.input,this.pos) == 13) {
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
			if(this.pos < this.length && HxOverrides.cca(this.input,this.pos) == 10) {
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			}
		} else {
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		}
		let position = start;
		if(position == null) {
			position = new loreline_Position(this.startLine,this.startColumn,this.pos);
		}
		position.length = this.pos - position.offset;
		let token = new loreline_Token(loreline_TokenType.LineBreak,position);
		this.previous = token;
		return token;
	}
	isWhitespace(c) {
		if(c != 32) {
			return c == 9;
		} else {
			return true;
		}
	}
	matchIdentifier(pos) {
		if(this.length == 0) {
			return null;
		}
		let firstChar = HxOverrides.cca(this.input,pos);
		if(!(firstChar >= 97 && firstChar <= 122 || firstChar >= 65 && firstChar <= 90 || firstChar == 95)) {
			return null;
		}
		let identifierLength = 1;
		while(identifierLength < this.length) {
			let c = HxOverrides.cca(this.input,pos + identifierLength);
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
				break;
			}
			++identifierLength;
		}
		return HxOverrides.substr(this.input,pos,identifierLength);
	}
	_skipWhitespaceAndComments(pos,stopNextLine) {
		if(stopNextLine == null) {
			stopNextLine = false;
		}
		if(stopNextLine) {
			return this._skipWhitespaceAndCommentsStopNextLine(pos);
		} else {
			let startPos = pos;
			let foundContent = false;
			while(pos < this.length) {
				while(pos < this.length && (HxOverrides.cca(this.input,pos) == 32 || HxOverrides.cca(this.input,pos) == 9)) {
					++pos;
					foundContent = true;
				}
				if(pos < this.length - 1) {
					if(HxOverrides.cca(this.input,pos) == 47) {
						if(HxOverrides.cca(this.input,pos + 1) == 47) {
							pos = startPos;
							return pos;
						} else if(HxOverrides.cca(this.input,pos + 1) == 42) {
							pos += 2;
							foundContent = true;
							let commentClosed = false;
							while(pos < this.length - 1) {
								if(HxOverrides.cca(this.input,pos) == 42 && HxOverrides.cca(this.input,pos + 1) == 47) {
									pos += 2;
									commentClosed = true;
									break;
								}
								++pos;
							}
							if(!commentClosed) {
								pos = startPos;
								return pos;
							}
							continue;
						}
					}
				}
				break;
			}
			if(foundContent) {
				return pos;
			} else {
				return startPos;
			}
		}
	}
	_skipWhitespaceAndCommentsStopNextLine(pos) {
		let startPos = pos;
		let foundContent = false;
		let isNextLine = false;
		while(pos < this.length) {
			while(pos < this.length) {
				let c = HxOverrides.cca(this.input,pos);
				if(c == 32 || c == 9 || c == 13 || !isNextLine && c == 10) {
					if(c == 10) {
						isNextLine = true;
					}
					++pos;
					foundContent = true;
				} else {
					break;
				}
			}
			if(pos < this.length - 1 && !isNextLine) {
				if(HxOverrides.cca(this.input,pos) == 47) {
					if(HxOverrides.cca(this.input,pos + 1) == 47) {
						pos += 2;
						foundContent = true;
						while(pos < this.length && HxOverrides.cca(this.input,pos) != 10 && HxOverrides.cca(this.input,pos) != 13) ++pos;
						continue;
					} else if(HxOverrides.cca(this.input,pos + 1) == 42) {
						pos += 2;
						foundContent = true;
						let commentClosed = false;
						while(pos < this.length - 1) {
							if(HxOverrides.cca(this.input,pos) == 42 && HxOverrides.cca(this.input,pos + 1) == 47) {
								pos += 2;
								commentClosed = true;
								break;
							}
							++pos;
						}
						if(!commentClosed) {
							pos = startPos;
							return pos;
						}
						continue;
					}
				}
			}
			break;
		}
		if(foundContent) {
			return pos;
		} else {
			return startPos;
		}
	}
	isIfStart(pos) {
		pos = this._skipWhitespaceAndComments(pos,false);
		if(HxOverrides.cca(this.input,pos) != 105) {
			return false;
		}
		++pos;
		if(HxOverrides.cca(this.input,pos) != 102) {
			return false;
		}
		let startPos = ++pos;
		pos = this._skipWhitespaceAndComments(pos,false);
		if(pos < this.length && HxOverrides.cca(this.input,pos) == 33) {
			++pos;
			pos = this._skipWhitespaceAndComments(pos,false);
		}
		if(HxOverrides.cca(this.input,pos) == 40) {
			return true;
		}
		let tmp;
		if(pos == startPos) {
			let c = HxOverrides.cca(this.input,startPos);
			tmp = c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		let tmp1;
		if(pos < this.length) {
			let c = HxOverrides.cca(this.input,pos);
			tmp1 = !(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95);
		} else {
			tmp1 = true;
		}
		if(tmp1) {
			return false;
		}
		let _gthis = this;
		while(pos < this.length) {
			if(HxOverrides.cca(this.input,pos) == 40) {
				return true;
			} else {
				let result = true;
				let len = _gthis.length;
				if(pos >= len) {
					result = false;
				} else {
					let tmp;
					if(pos + 1 < len && HxOverrides.cca(_gthis.input,pos) == 111 && HxOverrides.cca(_gthis.input,pos + 1) == 114) {
						let c = HxOverrides.cca(_gthis.input,pos + 2);
						tmp = !(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95);
					} else {
						tmp = false;
					}
					if(tmp) {
						result = false;
					} else {
						let tmp;
						if(pos + 2 < len && HxOverrides.cca(_gthis.input,pos) == 97 && HxOverrides.cca(_gthis.input,pos + 1) == 110 && HxOverrides.cca(_gthis.input,pos + 2) == 100) {
							let c = HxOverrides.cca(_gthis.input,pos + 3);
							tmp = !(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95);
						} else {
							tmp = false;
						}
						if(tmp) {
							result = false;
						} else {
							let c = HxOverrides.cca(_gthis.input,pos);
							if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
								result = false;
							} else {
								++pos;
								while(pos < _gthis.length) {
									c = HxOverrides.cca(_gthis.input,pos);
									if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
										break;
									}
									++pos;
								}
							}
						}
					}
				}
				if(!result) {
					return false;
				}
			}
			pos = this._skipWhitespaceAndComments(pos,false);
			if(pos >= this.length) {
				return true;
			}
			let c = HxOverrides.cca(this.input,pos);
			if(c == 46) {
				++pos;
				pos = this._skipWhitespaceAndComments(pos,false);
				let result = true;
				let len = _gthis.length;
				if(pos >= len) {
					result = false;
				} else {
					let tmp;
					if(pos + 1 < len && HxOverrides.cca(_gthis.input,pos) == 111 && HxOverrides.cca(_gthis.input,pos + 1) == 114) {
						let c = HxOverrides.cca(_gthis.input,pos + 2);
						tmp = !(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95);
					} else {
						tmp = false;
					}
					if(tmp) {
						result = false;
					} else {
						let tmp;
						if(pos + 2 < len && HxOverrides.cca(_gthis.input,pos) == 97 && HxOverrides.cca(_gthis.input,pos + 1) == 110 && HxOverrides.cca(_gthis.input,pos + 2) == 100) {
							let c = HxOverrides.cca(_gthis.input,pos + 3);
							tmp = !(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95);
						} else {
							tmp = false;
						}
						if(tmp) {
							result = false;
						} else {
							let c = HxOverrides.cca(_gthis.input,pos);
							if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
								result = false;
							} else {
								++pos;
								while(pos < _gthis.length) {
									c = HxOverrides.cca(_gthis.input,pos);
									if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
										break;
									}
									++pos;
								}
							}
						}
					}
				}
				if(!result) {
					return true;
				}
				pos = this._skipWhitespaceAndComments(pos,false);
				if(pos >= this.length) {
					return true;
				}
				c = HxOverrides.cca(this.input,pos);
			}
			if(c == 91) {
				++pos;
				let bracketLevel = 1;
				while(pos < this.length && bracketLevel > 0) {
					c = HxOverrides.cca(this.input,pos);
					if(c == 91) {
						++bracketLevel;
					}
					if(c == 93) {
						--bracketLevel;
					}
					++pos;
				}
				pos = this._skipWhitespaceAndComments(pos,false);
				if(pos >= this.length) {
					return true;
				}
				c = HxOverrides.cca(this.input,pos);
			}
			let tmp;
			if(c == 97 && HxOverrides.cca(this.input,pos + 1) == 110 && HxOverrides.cca(this.input,pos + 2) == 100) {
				let c = HxOverrides.cca(this.input,pos + 3);
				tmp = !(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95);
			} else {
				tmp = false;
			}
			if(tmp) {
				return true;
			}
			let tmp1;
			if(c == 111 && HxOverrides.cca(this.input,pos + 1) == 114) {
				let c = HxOverrides.cca(this.input,pos + 2);
				tmp1 = !(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95);
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				return true;
			}
			if(c == 40 || c == 38 || c == 124 || HxOverrides.cca(this.input,pos + 1) == 61 && c == 61 || c == 62 || c == 60 || c == 33 && HxOverrides.cca(this.input,pos + 1) == 61 || HxOverrides.cca(this.input,pos + 1) != 61 && (c == 43 || c == 45 || c == 42 || c == 47 || c == 123)) {
				return true;
			}
			if(c == 10 || c == 13 || pos >= this.length) {
				pos = startPos;
				return true;
			}
			return false;
		}
		return true;
	}
	isIdentifierExpressionStart(pos,lowercaseIdentOnly) {
		pos = this._skipWhitespaceAndComments(pos,false);
		pos = this._skipWhitespaceAndComments(pos,false);
		if(pos >= this.length) {
			return false;
		}
		if(HxOverrides.cca(this.input,pos) == 40) {
			return true;
		}
		let _gthis = this;
		let lowercaseIdentOnly1 = lowercaseIdentOnly;
		if(lowercaseIdentOnly1 == null) {
			lowercaseIdentOnly1 = false;
		}
		let result = true;
		if(pos >= _gthis.length) {
			result = false;
		} else {
			let isUnderscore = false;
			let c = HxOverrides.cca(_gthis.input,pos);
			isUnderscore = c == 95;
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95) || lowercaseIdentOnly1 && !isUnderscore && !(c >= 97 && c <= 122)) {
				result = false;
			} else {
				++pos;
				while(pos < _gthis.length) {
					let wasUnderscore = isUnderscore;
					c = HxOverrides.cca(_gthis.input,pos);
					isUnderscore = c == 95;
					if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
						break;
					}
					if(lowercaseIdentOnly1 && wasUnderscore && !isUnderscore && !(c >= 97 && c <= 122)) {
						result = false;
						break;
					}
					++pos;
				}
			}
		}
		if(!result) {
			return false;
		}
		while(pos < this.length) {
			pos = this._skipWhitespaceAndComments(pos,false);
			if(pos >= this.length) {
				return true;
			}
			let c = HxOverrides.cca(this.input,pos);
			if(!(c == 32 || c == 9) && c != 46 && c != 91 && c != 10 && c != 13 && c != 47) {
				return false;
			}
			if(c == 10 || c == 13 || c == 47 && pos + 1 < this.length && (HxOverrides.cca(this.input,pos + 1) == 47 || HxOverrides.cca(this.input,pos + 1) == 42)) {
				return true;
			}
			if(c == 46) {
				++pos;
				pos = this._skipWhitespaceAndComments(pos,false);
				if(pos >= this.length) {
					return true;
				}
				let result = true;
				if(pos >= _gthis.length) {
					result = false;
				} else {
					let isUnderscore = false;
					let c = HxOverrides.cca(_gthis.input,pos);
					isUnderscore = c == 95;
					if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
						result = false;
					} else {
						++pos;
						while(pos < _gthis.length) {
							let wasUnderscore = isUnderscore;
							c = HxOverrides.cca(_gthis.input,pos);
							isUnderscore = c == 95;
							if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
								break;
							}
							++pos;
						}
					}
				}
				if(!result) {
					return true;
				}
				continue;
			}
			if(c == 91) {
				++pos;
				let bracketLevel = 1;
				while(pos < this.length && bracketLevel > 0) {
					c = HxOverrides.cca(this.input,pos);
					if(c == 91) {
						++bracketLevel;
					}
					if(c == 93) {
						--bracketLevel;
					}
					++pos;
				}
				continue;
			}
			if(c == 32 || c == 9) {
				++pos;
				continue;
			}
			break;
		}
		return true;
	}
	isTransitionStart(pos) {
		if(HxOverrides.cca(this.input,pos) != 45 || pos >= this.length - 1 || HxOverrides.cca(this.input,pos + 1) != 62) {
			return false;
		}
		pos += 2;
		pos = this._skipWhitespaceAndComments(pos,false);
		if(pos >= this.length) {
			return false;
		}
		let char = HxOverrides.cca(this.input,pos);
		if(char == 46) {
			++pos;
		} else {
			let c = HxOverrides.cca(this.input,pos);
			if(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57) {
				++pos;
				while(true) {
					let tmp;
					if(pos < this.length) {
						let c = HxOverrides.cca(this.input,pos);
						tmp = c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57;
					} else {
						tmp = false;
					}
					if(!tmp) {
						break;
					}
					++pos;
				}
			} else {
				return false;
			}
		}
		pos = this._skipWhitespaceAndComments(pos,false);
		if(pos < this.length) {
			let c = HxOverrides.cca(this.input,pos);
			if(c != 10 && c != 13 && c != 32 && c != 9 && c != 47 && c != 35) {
				return false;
			}
		}
		return true;
	}
	isInsertionStart(pos) {
		if(HxOverrides.cca(this.input,pos) != 43) {
			return false;
		}
		++pos;
		pos = this._skipWhitespaceAndComments(pos,false);
		if(pos >= this.length) {
			return false;
		}
		let char = HxOverrides.cca(this.input,pos);
		if(char == 46) {
			++pos;
		} else {
			let c = HxOverrides.cca(this.input,pos);
			if(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57) {
				++pos;
				while(true) {
					let tmp;
					if(pos < this.length) {
						let c = HxOverrides.cca(this.input,pos);
						tmp = c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57;
					} else {
						tmp = false;
					}
					if(!tmp) {
						break;
					}
					++pos;
				}
			} else {
				return false;
			}
		}
		pos = this._skipWhitespaceAndComments(pos,false);
		if(pos < this.length) {
			let c = HxOverrides.cca(this.input,pos);
			if(c != 10 && c != 13 && c != 32 && c != 9 && c != 47) {
				return false;
			}
		}
		return true;
	}
	isLabelStart(pos) {
		pos = this._skipWhitespaceAndComments(pos,false);
		let c = HxOverrides.cca(this.input,pos);
		if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
			return false;
		}
		let startPos = pos;
		++pos;
		while(true) {
			let tmp;
			if(pos < this.length) {
				let c = HxOverrides.cca(this.input,pos);
				tmp = c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			++pos;
		}
		while(true) {
			let tmp;
			if(pos < this.length) {
				let c = HxOverrides.cca(this.input,pos);
				tmp = c == 32 || c == 9;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			++pos;
		}
		if(pos >= this.length || HxOverrides.cca(this.input,pos) != 58) {
			return false;
		}
		let word = HxOverrides.substr(this.input,startPos,pos - startPos);
		if(Object.prototype.hasOwnProperty.call(loreline_Lexer.KEYWORDS.h,word)) {
			return false;
		}
		return true;
	}
	isCallStart(pos) {
		let startPos = pos;
		let _gthis = this;
		let result = true;
		if(pos >= _gthis.length) {
			result = false;
		} else {
			let c = HxOverrides.cca(_gthis.input,pos);
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
				result = false;
			} else {
				++pos;
				while(pos < _gthis.length) {
					c = HxOverrides.cca(_gthis.input,pos);
					if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
						break;
					}
					++pos;
				}
			}
		}
		if(!result) {
			pos = startPos;
			return false;
		}
		while(pos < this.length) {
			pos = this._skipWhitespaceAndComments(pos,false);
			if(pos >= this.length) {
				pos = startPos;
				return false;
			}
			let c = HxOverrides.cca(this.input,pos);
			if(c == 40) {
				pos = startPos;
				return true;
			}
			if(c == 46) {
				++pos;
				pos = this._skipWhitespaceAndComments(pos,false);
				let result = true;
				if(pos >= _gthis.length) {
					result = false;
				} else {
					let c = HxOverrides.cca(_gthis.input,pos);
					if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
						result = false;
					} else {
						++pos;
						while(pos < _gthis.length) {
							c = HxOverrides.cca(_gthis.input,pos);
							if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
								break;
							}
							++pos;
						}
					}
				}
				if(!result) {
					pos = startPos;
					return false;
				}
				continue;
			}
			if(c == 91) {
				++pos;
				while(pos < this.length) {
					if(HxOverrides.cca(this.input,pos) == 93) {
						++pos;
						break;
					}
					++pos;
				}
				continue;
			}
			pos = startPos;
			return false;
		}
		pos = startPos;
		return false;
	}
	isAssignStart(pos,strict) {
		let _gthis = this;
		let tmp;
		if(strict) {
			let result = true;
			let startPos = pos;
			if(pos >= _gthis.length) {
				result = false;
			} else {
				let c = HxOverrides.cca(_gthis.input,pos);
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
					result = false;
				} else {
					++pos;
					while(pos < _gthis.length) {
						c = HxOverrides.cca(_gthis.input,pos);
						if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
							break;
						}
						++pos;
					}
				}
			}
			tmp = !(pos == startPos + 2 && HxOverrides.cca(_gthis.input,startPos) == 105 && HxOverrides.cca(_gthis.input,startPos + 1) == 102 ? false : result);
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		let isEscape = false;
		while(pos < this.length) {
			pos = this._skipWhitespaceAndComments(pos,false);
			if(pos >= this.length) {
				return false;
			}
			let c = HxOverrides.cca(this.input,pos);
			if(!isEscape && (c == 61 || HxOverrides.cca(this.input,pos + 1) == 61 && (c == 43 || c == 45 || c == 42 || c == 47))) {
				return true;
			}
			if(strict) {
				if(c == 46) {
					++pos;
					pos = this._skipWhitespaceAndComments(pos,false);
					let result = true;
					let startPos = pos;
					if(pos >= _gthis.length) {
						result = false;
					} else {
						let c = HxOverrides.cca(_gthis.input,pos);
						if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
							result = false;
						} else {
							++pos;
							while(pos < _gthis.length) {
								c = HxOverrides.cca(_gthis.input,pos);
								if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
									break;
								}
								++pos;
							}
						}
					}
					if(!(pos == startPos + 2 && HxOverrides.cca(_gthis.input,startPos) == 105 && HxOverrides.cca(_gthis.input,startPos + 1) == 102 ? false : result)) {
						return false;
					}
					continue;
				}
				if(c == 91) {
					++pos;
					while(pos < this.length) {
						if(HxOverrides.cca(this.input,pos) == 93) {
							++pos;
							break;
						}
						++pos;
					}
					continue;
				}
				return false;
			} else if(c == 92) {
				isEscape = true;
				++pos;
			} else if(c == 13 || c == 10) {
				return false;
			} else if(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95) {
				let result = true;
				let startPos = pos;
				if(pos >= _gthis.length) {
					result = false;
				} else {
					let c = HxOverrides.cca(_gthis.input,pos);
					if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
						result = false;
					} else {
						++pos;
						while(pos < _gthis.length) {
							c = HxOverrides.cca(_gthis.input,pos);
							if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
								break;
							}
							++pos;
						}
					}
				}
				if(!(pos == startPos + 2 && HxOverrides.cca(_gthis.input,startPos) == 105 && HxOverrides.cca(_gthis.input,startPos + 1) == 102 ? false : result)) {
					return false;
				}
			} else {
				++pos;
			}
		}
		return false;
	}
	isColon(pos,skipWhitespaces) {
		if(skipWhitespaces == null) {
			skipWhitespaces = true;
		}
		if(skipWhitespaces) {
			while(pos < this.length && (HxOverrides.cca(this.input,pos) == 32 || HxOverrides.cca(this.input,pos) == 9)) ++pos;
		}
		if(pos < this.length) {
			return HxOverrides.cca(this.input,pos) == 58;
		} else {
			return false;
		}
	}
	afterLabelIdentifierToken(inSameLine) {
		if(inSameLine == null) {
			inSameLine = true;
		}
		let i = this.tokenized.length - 1;
		while(i >= 0) {
			let token = this.tokenized[i];
			if(!loreline_TokenTypeHelpers.isComment(token.type) && (inSameLine || token.type != loreline_TokenType.LineBreak && token.type != loreline_TokenType.Indent && token.type != loreline_TokenType.Unindent)) {
				if(token.type == loreline_TokenType.Colon && i > 0 && loreline_TokenTypeHelpers.isIdentifier(this.tokenized[i - 1].type)) {
					return i - 1;
				}
				return -1;
			}
			--i;
		}
		return -1;
	}
	isStartingMultilineDialogue(labelIdentifierTokenIndex) {
		let labelIdentifierToken = this.tokenized[labelIdentifierTokenIndex];
		let i = labelIdentifierTokenIndex + 1;
		while(this.tokenized[i].type != loreline_TokenType.Colon) ++i;
		let pos = this.tokenized[i].pos.offset + 1;
		let labelColumn = labelIdentifierToken.pos.column;
		let onlyTagsOnFirstLine = true;
		let insideTag = false;
		while(pos < this.length) {
			let c = HxOverrides.cca(this.input,pos);
			if(c == 32 || c == 9) {
				++pos;
			} else {
				break;
			}
		}
		while(pos < this.length) {
			let c = HxOverrides.cca(this.input,pos);
			if(c == 10 || c == 13) {
				break;
			}
			if(c == 47 && pos + 1 < this.length) {
				let next = HxOverrides.cca(this.input,pos + 1);
				if(next == 47) {
					break;
				} else if(next == 42) {
					pos += 2;
					while(pos < this.length) {
						if(HxOverrides.cca(this.input,pos) == 42 && pos + 1 < this.length && HxOverrides.cca(this.input,pos + 1) == 47) {
							pos += 2;
							break;
						}
						++pos;
					}
					continue;
				}
			}
			if(c == 60) {
				insideTag = true;
			} else if(c == 62) {
				insideTag = false;
			} else if(!insideTag && !(c == 32 || c == 9)) {
				onlyTagsOnFirstLine = false;
				break;
			}
			++pos;
		}
		if(!onlyTagsOnFirstLine) {
			return -1;
		}
		let prevPos = pos;
		let stopNextLine = true;
		if(stopNextLine == null) {
			stopNextLine = false;
		}
		pos = this._skipWhitespaceAndComments(pos,stopNextLine);
		if(pos <= prevPos) {
			return -1;
		}
		let indent = 0;
		let tmpPos = pos;
		while(tmpPos > 0 && (HxOverrides.cca(this.input,tmpPos - 1) == 32 || HxOverrides.cca(this.input,tmpPos - 1) == 9)) {
			++indent;
			--tmpPos;
		}
		if(indent <= labelColumn - 1) {
			return -1;
		}
		let stopNextLine1 = false;
		if(stopNextLine1 == null) {
			stopNextLine1 = false;
		}
		pos = this._skipWhitespaceAndComments(pos,stopNextLine1);
		let c = HxOverrides.cca(this.input,pos);
		if(c == 32 || c == 9 || HxOverrides.cca(this.input,pos) == 47 && HxOverrides.cca(this.input,pos + 1) == 47) {
			return -1;
		}
		return indent;
	}
	isContinuingMultilineText(pos,indent) {
		if(HxOverrides.cca(this.input,pos) == 47 && HxOverrides.cca(this.input,pos + 1) == 47) {
			while(pos < this.length && HxOverrides.cca(this.input,pos) != 13 && HxOverrides.cca(this.input,pos) != 10) ++pos;
		}
		if(HxOverrides.cca(this.input,pos) == 13) {
			++pos;
		}
		if(HxOverrides.cca(this.input,pos) == 10) {
			++pos;
		} else {
			return false;
		}
		let computedIndent = 0;
		while(HxOverrides.cca(this.input,pos) == 32 || HxOverrides.cca(this.input,pos) == 9) {
			++computedIndent;
			++pos;
		}
		if(computedIndent != indent) {
			return false;
		}
		let stopNextLine = false;
		if(stopNextLine == null) {
			stopNextLine = false;
		}
		pos = this._skipWhitespaceAndComments(pos,stopNextLine);
		let c = HxOverrides.cca(this.input,pos);
		if(c == 32 || c == 9 || HxOverrides.cca(this.input,pos) == 13 || HxOverrides.cca(this.input,pos) == 10 || HxOverrides.cca(this.input,pos) == 47 && HxOverrides.cca(this.input,pos + 1) == 47) {
			return false;
		}
		return true;
	}
	isAfterComma() {
		let i = this.tokenized.length - 1;
		while(i >= 0) {
			let token = this.tokenized[i];
			if(!loreline_TokenTypeHelpers.isComment(token.type) && token.type != loreline_TokenType.LineBreak && token.type != loreline_TokenType.Indent && token.type != loreline_TokenType.Unindent) {
				return token.type == loreline_TokenType.Comma;
			}
			--i;
		}
		return false;
	}
	isAfterLBracket() {
		let i = this.tokenized.length - 1;
		while(i >= 0) {
			let token = this.tokenized[i];
			if(!loreline_TokenTypeHelpers.isComment(token.type) && token.type != loreline_TokenType.LineBreak && token.type != loreline_TokenType.Indent && token.type != loreline_TokenType.Unindent) {
				return token.type == loreline_TokenType.LBracket;
			}
			--i;
		}
		return false;
	}
	isInsideBrackets() {
		let i = this.stack.length - 1;
		while(i >= 0 && this.stack[i] == 9) --i;
		if(i >= 0) {
			return this.stack[i] == 10;
		} else {
			return false;
		}
	}
	followsAssignStart() {
		let i = this.tokenized.length - 1;
		while(i >= 0) {
			let token = this.tokenized[i];
			if(loreline_TokenTypeHelpers.isComment(token.type) || token.type == loreline_TokenType.Indent || token.type == loreline_TokenType.Unindent) {
				--i;
			} else if(loreline_TokenTypeHelpers.isAssignOp(token.type)) {
				return true;
			} else {
				return false;
			}
		}
		return false;
	}
	followsOnlyLabelOrCommentsInLine() {
		let foundLabel = false;
		let i = this.tokenized.length - 1;
		while(i >= 0) {
			let token = this.tokenized[i];
			if(loreline_TokenTypeHelpers.isComment(token.type) || token.type == loreline_TokenType.Indent || token.type == loreline_TokenType.Unindent) {
				--i;
			} else if(!foundLabel && token.type == loreline_TokenType.Colon) {
				--i;
				if(i >= 0) {
					if(loreline_TokenTypeHelpers.isIdentifier(this.tokenized[i].type)) {
						foundLabel = true;
						--i;
					}
				} else {
					return false;
				}
			} else if(token.type == loreline_TokenType.LineBreak) {
				return true;
			} else {
				return false;
			}
		}
		return true;
	}
	followsOnlyWhitespacesOrCommentsInLine() {
		let i = this.tokenized.length - 1;
		while(i >= 0) {
			let token = this.tokenized[i];
			if(loreline_TokenTypeHelpers.isComment(token.type) || token.type == loreline_TokenType.Indent || token.type == loreline_TokenType.Unindent) {
				--i;
			} else if(token.type == loreline_TokenType.LineBreak) {
				return true;
			} else {
				return false;
			}
		}
		return true;
	}
	hasNonSpecialChar(str) {
		let _g = 0;
		let _g1 = str.length;
		while(_g < _g1) {
			let i = _g++;
			let found = false;
			let code = HxOverrides.cca(str,i);
			let _g1 = 0;
			let _g2 = loreline_Lexer.hasNonSpecialChar_specialChars.length;
			while(_g1 < _g2) {
				let j = _g1++;
				if(code == HxOverrides.cca(loreline_Lexer.hasNonSpecialChar_specialChars,j)) {
					found = true;
					break;
				}
			}
			if(!found) {
				return true;
			}
		}
		return false;
	}
	isNumber(value) {
		let pos = 0;
		let length = value.length;
		while(true) {
			let tmp;
			if(pos < length) {
				let c = HxOverrides.cca(value,pos);
				tmp = c >= 48 && c <= 57;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			++pos;
		}
		let tmp;
		if(pos < length && HxOverrides.cca(value,pos) == 46 && pos + 1 < length) {
			let c = HxOverrides.cca(value,pos + 1);
			tmp = c >= 48 && c <= 57;
		} else {
			tmp = false;
		}
		if(tmp) {
			++pos;
			while(true) {
				let tmp;
				if(pos < length) {
					let c = HxOverrides.cca(value,pos);
					tmp = c >= 48 && c <= 57;
				} else {
					tmp = false;
				}
				if(!tmp) {
					break;
				}
				++pos;
			}
		}
		return pos == length;
	}
	makeLooseOrStrictAfterBracket() {
		let i = this.tokenized.length - 1;
		while(i >= 0) {
			let token = this.tokenized[i];
			let _g = token.type;
			switch(_g._hx_index) {
			case 13:
				let _g1 = _g.name;
				this.strictExprs.push(1);
				return;
			case 40:case 42:
				this.strictExprs.push(1);
				return;
			case 43:
				let _g2 = _g.content;
				break;
			case 44:
				let _g3 = _g.content;
				break;
			case 45:
				let _g4 = _g.content;
				break;
			case 46:case 47:case 48:
				break;
			default:
				this.strictExprs.push(0);
				return;
			}
			--i;
		}
		this.strictExprs.push(2);
	}
	makeStrictIfFollowingCallable() {
		if(this.followsCallableOrIndexable()) {
			this.strictExprs.push(1);
		} else {
			this.strictExprs.push(2);
		}
	}
	followsCallableOrIndexable() {
		let i = this.tokenized.length - 1;
		while(i >= 0) {
			let token = this.tokenized[i];
			let _g = token.type;
			switch(_g._hx_index) {
			case 13:
				let _g1 = _g.name;
				return true;
			case 40:case 42:
				return true;
			case 43:
				let _g2 = _g.content;
				break;
			case 44:
				let _g3 = _g.content;
				break;
			case 45:
				let _g4 = _g.content;
				break;
			case 46:case 47:case 48:
				break;
			default:
				return false;
			}
			--i;
		}
		return false;
	}
	isStrict() {
		let i = this.strictExprs.length - 1;
		while(i >= 0 && this.strictExprs[i] == 2) --i;
		if(i >= 0) {
			return this.strictExprs[i] == 1;
		} else {
			return false;
		}
	}
	readImportValue(c,startPos) {
		if(c == 34) {
			return this.readString(startPos);
		} else {
			let buf_b = "";
			while(this.pos < this.length) {
				let cc = HxOverrides.cca(this.input,this.pos);
				if(cc == 10) {
					break;
				}
				buf_b += String.fromCodePoint(cc);
				this.pos++;
			}
			let value = StringTools.rtrim(buf_b);
			let position = new loreline_Position(startPos.line,startPos.column,startPos.offset,value.length);
			if(position == null) {
				position = new loreline_Position(this.startLine,this.startColumn,this.pos);
			}
			position.length = this.pos - position.offset;
			let token = new loreline_Token(loreline_TokenType.LString(0,value,[]),position);
			this.previous = token;
			return token;
		}
	}
	tryReadUnquotedString() {
		if(this.isStrict()) {
			return null;
		}
		let c = HxOverrides.cca(this.input,this.pos);
		let cc = this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0;
		if(c == 47 && this.pos < this.length - 1) {
			let next = HxOverrides.cca(this.input,this.pos + 1);
			if(next == 47 || next == 42) {
				return null;
			}
		}
		if(c == 123 || c == 125 || c == 91 || c == 93 || c == 34 || c == 58 || c == 35 || (c == 32 || c == 9)) {
			return null;
		}
		let parent = this.parentBlockType();
		if(parent != loreline_TokenType.KwBeat && parent != loreline_TokenType.KwState && parent != loreline_TokenType.KwCharacter) {
			return null;
		}
		let inBrackets = this.isInsideBrackets();
		let isAssignValue = false;
		let labelIdentifierIndex = this.afterLabelIdentifierToken(false);
		if(labelIdentifierIndex != -1 && this.tokenized[labelIdentifierIndex].pos.line < this.line) {
			if(this.tokenized[labelIdentifierIndex].pos.column >= this.column) {
				return null;
			}
			if(this.line - this.tokenized[labelIdentifierIndex].pos.line > 1) {
				return null;
			}
		}
		let multilineIndent = labelIdentifierIndex != -1 ? this.isStartingMultilineDialogue(labelIdentifierIndex) : -1;
		let isAfterLabel = labelIdentifierIndex != -1;
		let isValue = parent == loreline_TokenType.KwState || parent == loreline_TokenType.KwCharacter || inBrackets || isAssignValue;
		if(isValue) {
			if(this.isCallStart(this.pos) || this.isLabelStart(this.pos)) {
				return null;
			}
		} else if(!isAfterLabel && (this.isIdentifierExpressionStart(this.pos,true) || this.isIfStart(this.pos) || this.isCallStart(this.pos) || this.isAssignStart(this.pos,false))) {
			return null;
		}
		if(!isValue) {
			if(c == 61 || cc == 61 && (c == 43 || c == 45 || c == 42 || c == 47)) {
				return null;
			}
		}
		if(!isValue && !isAfterLabel) {
			if(this.isInsertionStart(this.pos)) {
				return null;
			}
		}
		let identifier = this.matchIdentifier(this.pos);
		if(identifier != null) {
			if(identifier == "function") {
				return null;
			}
			if(!isValue) {
				if(identifier != "if" && identifier != "null" && identifier != "true" && identifier != "false" && identifier != "and" && identifier != "or" && Object.prototype.hasOwnProperty.call(loreline_Lexer.KEYWORDS.h,identifier)) {
					return null;
				}
				if(this.isColon(this.pos + identifier.length)) {
					return null;
				}
			}
		}
		let allowTags = !isValue;
		let isDialogue = false;
		if(isValue) {
			if(inBrackets) {
				if(!isAfterLabel && !this.followsOnlyWhitespacesOrCommentsInLine() && !this.isAfterComma() && !this.isAfterLBracket()) {
					return null;
				}
			} else if(!isAssignValue && !isAfterLabel) {
				return null;
			}
		} else {
			isDialogue = this.followsOnlyLabelOrCommentsInLine();
			if(!isDialogue && !this.followsOnlyWhitespacesOrCommentsInLine()) {
				return null;
			}
			if(!isDialogue) {
				if(cc == 62 && c == 45) {
					return null;
				}
			}
		}
		let start = new loreline_Position(this.startLine,this.startColumn,this.pos);
		let buf_b = "";
		let attachments = [];
		let startLine = this.line;
		let startColumn = this.column;
		let startPos = this.pos;
		let escaped = false;
		let tagStart = -1;
		let tagIsClosing = false;
		let currentColumn = this.column;
		let currentLine = this.line;
		let valid = true;
		let hasContent = false;
		while(this.pos < this.length) {
			let c = HxOverrides.cca(this.input,this.pos);
			let isSpace = c == 32 || c == 9;
			if(!hasContent) {
				if(!isSpace && tagStart == -1 && (c != 60 || !allowTags)) {
					hasContent = true;
				}
			}
			if(escaped) {
				buf_b += String.fromCodePoint(92);
				buf_b += String.fromCodePoint(c);
				escaped = false;
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				currentColumn += 2;
			} else if(c == 92) {
				escaped = true;
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			} else if(tagStart == -1 && isSpace && !hasContent && attachments.length == 0) {
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			} else if(tagStart == -1 && c == 123) {
				break;
			} else if(tagStart == -1 && (c == 10 || c == 13 || c == 47 && this.pos < this.length - 1 && HxOverrides.cca(this.input,this.pos + 1) == 47)) {
				if(multilineIndent != -1) {
					if(this.isContinuingMultilineText(this.pos,multilineIndent)) {
						buf_b += String.fromCodePoint(c);
						let count = 1;
						while(count-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
						if(c == 13 && HxOverrides.cca(this.input,this.pos) == 10) {
							buf_b += String.fromCodePoint(10);
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
						}
						currentColumn = this.column;
						currentLine = this.line;
					} else {
						break;
					}
				} else {
					break;
				}
			} else if(tagStart == -1 && (c == 47 && this.pos < this.length - 1 && HxOverrides.cca(this.input,this.pos + 1) == 42)) {
				buf_b += String.fromCodePoint(47);
				buf_b += String.fromCodePoint(42);
				let count = 2;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				let commentClosed = false;
				while(this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 42 && this.pos + 1 < this.length && HxOverrides.cca(this.input,this.pos + 1) == 47) {
						buf_b += String.fromCodePoint(42);
						buf_b += String.fromCodePoint(47);
						let count = 2;
						while(count-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
						commentClosed = true;
						break;
					}
					let c = HxOverrides.cca(this.input,this.pos);
					buf_b += String.fromCodePoint(c);
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
				}
				currentColumn = this.column;
				currentLine = this.line;
				if(!commentClosed) {
					this.error("Unterminated multiline comment",false);
				}
			} else if(tagStart == -1 && !isValue && this.isIfStart(this.pos)) {
				break;
			} else if(tagStart == -1 && c == 45 && this.pos < this.length - 1 && HxOverrides.cca(this.input,this.pos + 1) == 62 && this.isTransitionStart(this.pos)) {
				break;
			} else if(tagStart == -1 && isValue && (c == 44 || c == 93 || c == 125)) {
				break;
			} else if(allowTags && c == 60) {
				if(tagStart != -1) {
					this.error("Unexpected < inside tag",true);
				}
				let nextChar = this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0;
				tagIsClosing = nextChar == 47;
				let checkPos = this.pos + (tagIsClosing ? 2 : 1);
				if(checkPos < this.length) {
					let nameStart = HxOverrides.cca(this.input,checkPos);
					if(nameStart >= 97 && nameStart <= 122 || nameStart >= 65 && nameStart <= 90 || nameStart == 95 || nameStart == 95 || nameStart == 36 || tagIsClosing && nameStart == 62) {
						tagStart = buf_b.length;
					}
				}
				buf_b += String.fromCodePoint(c);
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				++currentColumn;
			} else if(allowTags && c == 62) {
				buf_b += String.fromCodePoint(c);
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				++currentColumn;
				if(tagStart != -1) {
					attachments.push(loreline_LStringAttachment.Tag(tagIsClosing,tagStart,buf_b.length - tagStart));
					tagStart = -1;
				}
			} else if(tagStart == -1 && c == 35 && !escaped) {
				let nextChar = this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0;
				if(nextChar == 35) {
					buf_b += String.fromCodePoint(35);
					buf_b += String.fromCodePoint(35);
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					let count1 = 1;
					while(count1-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					currentColumn += 2;
				} else if(nextChar >= 97 && nextChar <= 122 || nextChar >= 65 && nextChar <= 90 || nextChar == 95 || nextChar >= 48 && nextChar <= 57 || nextChar == 45) {
					break;
				} else {
					buf_b += String.fromCodePoint(c);
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					++currentColumn;
				}
			} else if(c == 36 && !escaped) {
				let interpStart = buf_b.length;
				let interpLine = currentLine;
				let interpColumn = currentColumn;
				let tokenStartPos = this.pos;
				try {
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					++currentColumn;
					if(HxOverrides.cca(this.input,this.pos) == 123) {
						let count = 1;
						while(count-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
						++currentColumn;
						let interpPos = new loreline_Position(interpLine,interpColumn + 2,this.pos);
						let tokens = this.readComplexInterpolation(interpPos);
						let interpLength = this.pos - tokenStartPos;
						attachments.push(loreline_LStringAttachment.Interpolation(true,tagStart != -1,tokens,interpStart,interpLength));
						buf_b += Std.string(HxOverrides.substr(this.input,tokenStartPos,interpLength));
					} else {
						let c = HxOverrides.cca(this.input,this.pos);
						if(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95) {
							let interpPos = new loreline_Position(interpLine,interpColumn + 1,this.pos);
							let tokens = this.readFieldAccessInterpolation(interpPos);
							let interpLength = this.pos - tokenStartPos;
							attachments.push(loreline_LStringAttachment.Interpolation(false,tagStart != -1,tokens,interpStart,interpLength));
							buf_b += Std.string(HxOverrides.substr(this.input,tokenStartPos,interpLength));
						} else if(HxOverrides.cca(this.input,this.pos) == 36) {
							buf_b += String.fromCodePoint(36);
							buf_b += String.fromCodePoint(36);
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							++currentColumn;
						} else {
							this.error("Expected identifier or { after $",false);
							let interpLength = this.pos - tokenStartPos;
							attachments.push(loreline_LStringAttachment.Interpolation(false,tagStart != -1,[],interpStart,interpLength));
							buf_b += Std.string(HxOverrides.substr(this.input,tokenStartPos,interpLength));
						}
					}
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g).unwrap();
					if(((_g1) instanceof loreline_LexerError)) {
						let e = _g1;
						if(e.pos == null) {
							e.pos = new loreline_Position(interpLine,interpColumn,this.pos);
						}
						throw haxe_Exception.thrown(e);
					} else {
						throw _g;
					}
				}
				currentColumn = interpColumn + (this.pos - tokenStartPos);
			} else {
				if(c == 10) {
					++currentLine;
					currentColumn = 1;
				} else {
					++currentColumn;
				}
				buf_b += String.fromCodePoint(c);
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			}
		}
		if(valid) {
			let content = buf_b;
			let rawContentLength = content.length;
			content = StringTools.rtrim(content);
			let contentLength = content.length;
			let rtrimmedOffset = rawContentLength - contentLength;
			if(contentLength > 0 && this.hasNonSpecialChar(content) && !this.isNumber(content) && content != "null" && content != "true" && content != "false") {
				if(multilineIndent == -1 && !isAfterLabel && !this.inChoiceRoot()) {
					let savedLine = this.line;
					let savedColumn = this.column;
					let savedPos = this.pos;
					let stopNextLine = true;
					if(stopNextLine == null) {
						stopNextLine = false;
					}
					let stopNextLine1 = stopNextLine;
					if(stopNextLine1 == null) {
						stopNextLine1 = false;
					}
					let newPos = this._skipWhitespaceAndComments(this.pos,stopNextLine1);
					while(this.pos < newPos) {
						let count = 1;
						while(count-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
					}
					let afterWhitespaceAndCommentsPos = this.pos;
					if(this.column == startColumn) {
						let followingText = this.tryReadUnquotedString();
						if(followingText != null) {
							let between = this.input.substring(savedPos - rtrimmedOffset,afterWhitespaceAndCommentsPos);
							let _g = followingText.type;
							if(_g._hx_index == 9) {
								let _g1 = _g.quotes;
								let s_ = _g.s;
								let attachments_ = _g.attachments;
								if(attachments_ != null) {
									let _g = 0;
									while(_g < attachments_.length) {
										let attachment = attachments_[_g];
										++_g;
										switch(attachment._hx_index) {
										case 0:
											let braces = attachment.braces;
											let inTag = attachment.inTag;
											let expr = attachment.expr;
											let start = attachment.start;
											let length = attachment.length;
											attachments.push(loreline_LStringAttachment.Interpolation(braces,inTag,expr,start + afterWhitespaceAndCommentsPos - startPos,length));
											break;
										case 1:
											let closing = attachment.closing;
											let start1 = attachment.start;
											let length1 = attachment.length;
											attachments.push(loreline_LStringAttachment.Tag(closing,start1 + afterWhitespaceAndCommentsPos - startPos,length1));
											break;
										}
									}
								}
								content += between;
								content += s_;
							}
							rtrimmedOffset = 0;
							let n = this.pos - 1;
							while(n >= 0 && HxOverrides.cca(this.input,n) == 32 || HxOverrides.cca(this.input,n) == 9) {
								++rtrimmedOffset;
								--n;
							}
						} else {
							this.line = savedLine;
							this.column = savedColumn;
							this.pos = savedPos;
						}
					} else {
						this.line = savedLine;
						this.column = savedColumn;
						this.pos = savedPos;
					}
				}
				attachments.sort(loreline_Lexer.compareAttachments);
				let type = attachments.length > 0 ? attachments : null;
				let position = start;
				if(position == null) {
					position = new loreline_Position(this.startLine,this.startColumn,this.pos);
				}
				position.length = this.pos - position.offset;
				let token = new loreline_Token(loreline_TokenType.LString(0,content,type),position);
				this.previous = token;
				let token1 = token;
				token1.pos.length -= rtrimmedOffset;
				return token1;
			}
		}
		this.line = startLine;
		this.column = startColumn;
		this.pos = startPos;
		return null;
	}
	readString(stringStart) {
		let count = 1;
		while(count-- > 0 && this.pos < this.length) {
			if(HxOverrides.cca(this.input,this.pos) == 10) {
				this.line++;
				this.column = 1;
			} else {
				this.column++;
			}
			this.pos++;
		}
		let buf_b = "";
		let attachments = [];
		let escaped = false;
		let tagStart = -1;
		let tagIsClosing = false;
		let currentColumn = stringStart.column + 1;
		let currentLine = stringStart.line;
		let allowTags = this.parentBlockType() == loreline_TokenType.KwBeat;
		while(this.pos < this.length) {
			let c = HxOverrides.cca(this.input,this.pos);
			if(escaped) {
				buf_b += String.fromCodePoint(92);
				buf_b += String.fromCodePoint(c);
				escaped = false;
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				currentColumn += 2;
			} else if(c == 92) {
				escaped = true;
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			} else if(c == 34 && tagStart == -1) {
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				attachments.sort(loreline_Lexer.compareAttachments);
				let type = attachments.length > 0 ? attachments : null;
				let position = stringStart;
				if(position == null) {
					position = new loreline_Position(this.startLine,this.startColumn,this.pos);
				}
				position.length = this.pos - position.offset;
				let token = new loreline_Token(loreline_TokenType.LString(1,buf_b,type),position);
				this.previous = token;
				return token;
			} else if(allowTags && c == 60) {
				if(tagStart != -1) {
					this.error("Unexpected < inside tag",true);
				}
				let nextChar = this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0;
				tagIsClosing = nextChar == 47;
				let checkPos = this.pos + (tagIsClosing ? 2 : 1);
				if(checkPos < this.length) {
					let nameStart = HxOverrides.cca(this.input,checkPos);
					if(nameStart >= 97 && nameStart <= 122 || nameStart >= 65 && nameStart <= 90 || nameStart == 95 || nameStart == 95 || nameStart == 36 || tagIsClosing && nameStart == 62) {
						tagStart = buf_b.length;
					}
				}
				buf_b += String.fromCodePoint(c);
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				++currentColumn;
			} else if(c == 62) {
				buf_b += String.fromCodePoint(c);
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				++currentColumn;
				if(tagStart != -1) {
					attachments.push(loreline_LStringAttachment.Tag(tagIsClosing,tagStart,buf_b.length - tagStart));
					tagStart = -1;
				}
			} else if(c == 36 && !escaped) {
				let interpStart = buf_b.length;
				let interpLine = currentLine;
				let interpColumn = currentColumn;
				let tokenStartPos = this.pos;
				try {
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					++currentColumn;
					if(HxOverrides.cca(this.input,this.pos) == 123) {
						let count = 1;
						while(count-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
						++currentColumn;
						let interpPos = new loreline_Position(interpLine,interpColumn + 2,this.pos);
						let tokens = this.readComplexInterpolation(interpPos);
						let interpLength = this.pos - tokenStartPos;
						attachments.push(loreline_LStringAttachment.Interpolation(true,tagStart != -1,tokens,interpStart,interpLength));
						buf_b += Std.string(HxOverrides.substr(this.input,tokenStartPos,interpLength));
					} else {
						let c = HxOverrides.cca(this.input,this.pos);
						if(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95) {
							let interpPos = new loreline_Position(interpLine,interpColumn + 1,this.pos);
							let tokens = this.readFieldAccessInterpolation(interpPos);
							let interpLength = this.pos - tokenStartPos;
							attachments.push(loreline_LStringAttachment.Interpolation(false,tagStart != -1,tokens,interpStart,interpLength));
							buf_b += Std.string(HxOverrides.substr(this.input,tokenStartPos,interpLength));
						} else if(HxOverrides.cca(this.input,this.pos) == 36) {
							buf_b += String.fromCodePoint(36);
							buf_b += String.fromCodePoint(36);
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							++currentColumn;
						} else {
							this.error("Expected identifier or { after $",false);
							let interpLength = this.pos - tokenStartPos;
							attachments.push(loreline_LStringAttachment.Interpolation(false,tagStart != -1,[],interpStart,interpLength));
							buf_b += Std.string(HxOverrides.substr(this.input,tokenStartPos,interpLength));
						}
					}
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g).unwrap();
					if(((_g1) instanceof loreline_LexerError)) {
						let e = _g1;
						if(e.pos == null) {
							e.pos = new loreline_Position(interpLine,interpColumn,this.pos);
						}
						throw haxe_Exception.thrown(e);
					} else {
						throw _g;
					}
				}
				currentColumn = interpColumn + (this.pos - tokenStartPos);
			} else {
				if(c == 10) {
					++currentLine;
					currentColumn = 1;
				} else {
					++currentColumn;
				}
				buf_b += String.fromCodePoint(c);
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			}
		}
		this.error("Unterminated string",true);
		return null;
	}
	readComplexInterpolation(interpStart) {
		this.strictExprs.push(1);
		let tokens = [];
		let braceLevel = 1;
		let currentColumn = interpStart.column;
		let currentLine = interpStart.line;
		while(this.pos < this.length && braceLevel > 0) {
			if(HxOverrides.cca(this.input,this.pos) == 34) {
				let stringPos = new loreline_Position(currentLine,currentColumn,this.pos);
				tokens.push(this.readString(stringPos));
				currentColumn += this.pos - stringPos.offset;
				continue;
			}
			let token = this.nextToken();
			tokens.push(token);
			if(token.type == loreline_TokenType.LineBreak) {
				++currentLine;
				currentColumn = 1;
			} else if(!(token.type == loreline_TokenType.Indent || token.type == loreline_TokenType.Unindent)) {
				let tokenLength;
				let _g = token.type;
				switch(_g._hx_index) {
				case 9:
					let _g1 = _g.attachments;
					let q = _g.quotes;
					let s = _g.s;
					tokenLength = s.length + (q != 0 ? 2 : 0);
					break;
				case 10:
					let n = _g.n;
					tokenLength = (n == null ? "null" : "" + n).length;
					break;
				case 13:
					let name = _g.name;
					tokenLength = name.length;
					break;
				default:
					tokenLength = 1;
				}
				currentColumn += tokenLength;
			}
			switch(token.type._hx_index) {
			case 37:
				++braceLevel;
				break;
			case 38:
				--braceLevel;
				break;
			default:
			}
			if(token.type == loreline_TokenType.Eof) {
				this.error("Unterminated interpolation expression",true);
			}
		}
		tokens.pop();
		this.strictExprs.pop();
		return tokens;
	}
	nextTokenWithPosition(startPos) {
		let savedLine = this.line;
		let savedColumn = this.column;
		let savedPos = this.pos;
		let token = this.nextToken();
		let len = token.pos.length;
		let tokenOffset = this.pos - savedPos;
		token.pos = new loreline_Position(startPos.line,startPos.column + tokenOffset,startPos.offset + tokenOffset,len);
		this.line = savedLine;
		this.column = savedColumn;
		return token;
	}
	readFieldAccessInterpolation(interpStart) {
		this.strictExprs.push(1);
		let tokens = [];
		let c = HxOverrides.cca(this.input,this.pos);
		if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
			this.error("Expected identifier in field access",true);
		}
		let idStartPos = this.pos;
		while(this.pos < this.length) {
			let c = HxOverrides.cca(this.input,this.pos);
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
				break;
			}
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		}
		let name = HxOverrides.substr(this.input,idStartPos,this.pos - idStartPos);
		let tokenType = Object.prototype.hasOwnProperty.call(loreline_Lexer.KEYWORDS.h,name) ? loreline_Lexer.KEYWORDS.h[name] : loreline_TokenType.Identifier(name);
		tokens.push(new loreline_Token(tokenType,new loreline_Position(interpStart.line,interpStart.column,idStartPos,this.pos - idStartPos)));
		_hx_loop3: while(this.pos < this.length) {
			let _g = HxOverrides.cca(this.input,this.pos);
			if(_g == null) {
				break;
			} else {
				switch(_g) {
				case 40:
					tokens.push(new loreline_Token(loreline_TokenType.LParen,new loreline_Position(this.line,this.column,this.pos,1)));
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					this.stack.push(8);
					this.strictExprs.push(1);
					let parenLevel = 1;
					while(this.pos < this.length && parenLevel > 0) {
						if(HxOverrides.cca(this.input,this.pos) == 41) {
							--parenLevel;
							if(parenLevel == 0) {
								tokens.push(new loreline_Token(loreline_TokenType.RParen,new loreline_Position(this.line,this.column,this.pos,1)));
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								this.stack.pop();
								this.strictExprs.pop();
								break;
							}
						} else if(HxOverrides.cca(this.input,this.pos) == 40) {
							++parenLevel;
						}
						if(HxOverrides.cca(this.input,this.pos) == 44) {
							tokens.push(new loreline_Token(loreline_TokenType.Comma,new loreline_Position(this.line,this.column,this.pos,1)));
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
						} else {
							tokens.push(this.nextToken());
						}
					}
					if(parenLevel > 0) {
						this.error("Unterminated function call in interpolation",true);
					}
					break;
				case 46:
					let tmp;
					if(this.pos + 1 < this.length) {
						let c = HxOverrides.cca(this.input,this.pos + 1);
						tmp = c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95;
					} else {
						tmp = false;
					}
					if(tmp) {
						tokens.push(new loreline_Token(loreline_TokenType.Dot,new loreline_Position(this.line,this.column,this.pos,1)));
						let count = 1;
						while(count-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
						let idStartPos = this.pos;
						while(this.pos < this.length) {
							let c = HxOverrides.cca(this.input,this.pos);
							if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
								break;
							}
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
						}
						let name = HxOverrides.substr(this.input,idStartPos,this.pos - idStartPos);
						let tokenType = Object.prototype.hasOwnProperty.call(loreline_Lexer.KEYWORDS.h,name) ? loreline_Lexer.KEYWORDS.h[name] : loreline_TokenType.Identifier(name);
						tokens.push(new loreline_Token(tokenType,new loreline_Position(this.line,this.column - (this.pos - idStartPos),idStartPos)));
					} else {
						break _hx_loop3;
					}
					break;
				case 91:
					tokens.push(new loreline_Token(loreline_TokenType.LBracket,new loreline_Position(this.line,this.column,this.pos,1)));
					let count1 = 1;
					while(count1-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					this.stack.push(10);
					this.strictExprs.push(1);
					let bracketLevel = 1;
					while(this.pos < this.length && bracketLevel > 0) {
						if(HxOverrides.cca(this.input,this.pos) == 93) {
							--bracketLevel;
							if(bracketLevel == 0) {
								tokens.push(new loreline_Token(loreline_TokenType.RBracket,new loreline_Position(this.line,this.column,this.pos,1)));
								let count = 1;
								while(count-- > 0 && this.pos < this.length) {
									if(HxOverrides.cca(this.input,this.pos) == 10) {
										this.line++;
										this.column = 1;
									} else {
										this.column++;
									}
									this.pos++;
								}
								this.stack.pop();
								this.strictExprs.pop();
								break;
							}
						} else if(HxOverrides.cca(this.input,this.pos) == 91) {
							++bracketLevel;
						}
						tokens.push(this.nextToken());
					}
					if(bracketLevel > 0) {
						this.error("Unterminated array access in interpolation",true);
					}
					break;
				default:
					break _hx_loop3;
				}
			}
		}
		this.strictExprs.pop();
		return tokens;
	}
	readIdentifierTokenInInterpolation(stringStart) {
		let startPos = this.makePositionRelativeTo(stringStart);
		let startOffset = this.pos;
		while(this.pos < this.length) {
			let c = HxOverrides.cca(this.input,this.pos);
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
				break;
			}
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		}
		let name = HxOverrides.substr(this.input,startOffset,this.pos - startOffset);
		let tokenType = Object.prototype.hasOwnProperty.call(loreline_Lexer.KEYWORDS.h,name) ? loreline_Lexer.KEYWORDS.h[name] : loreline_TokenType.Identifier(name);
		return new loreline_Token(tokenType,startPos);
	}
	makePositionRelativeTo(stringStart) {
		let line = stringStart.line;
		let column = stringStart.column;
		let i = stringStart.offset;
		while(i < this.pos) {
			if(HxOverrides.cca(this.input,i) == 10) {
				++line;
				column = 1;
			} else {
				++column;
			}
			++i;
		}
		return new loreline_Position(line,column,this.pos,stringStart.length);
	}
	readLineComment() {
		let start = new loreline_Position(this.startLine,this.startColumn,this.pos);
		let count = 2;
		while(count-- > 0 && this.pos < this.length) {
			if(HxOverrides.cca(this.input,this.pos) == 10) {
				this.line++;
				this.column = 1;
			} else {
				this.column++;
			}
			this.pos++;
		}
		let contentStart = this.pos;
		while(this.pos < this.length) {
			let c = HxOverrides.cca(this.input,this.pos);
			if(c == 10 || c == 13) {
				break;
			}
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		}
		let type = loreline_TokenType.CommentLine(HxOverrides.substr(this.input,contentStart,this.pos - contentStart));
		let position = start;
		if(position == null) {
			position = new loreline_Position(this.startLine,this.startColumn,this.pos);
		}
		position.length = this.pos - position.offset;
		let token = new loreline_Token(type,position);
		this.previous = token;
		return token;
	}
	readMultiLineComment() {
		let start = new loreline_Position(this.startLine,this.startColumn,this.pos);
		let count = 2;
		while(count-- > 0 && this.pos < this.length) {
			if(HxOverrides.cca(this.input,this.pos) == 10) {
				this.line++;
				this.column = 1;
			} else {
				this.column++;
			}
			this.pos++;
		}
		let contentStart = this.pos;
		let nestLevel = 1;
		while(this.pos < this.length && nestLevel > 0) if(HxOverrides.cca(this.input,this.pos) == 42 && (this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 47) {
			--nestLevel;
			if(nestLevel == 0) {
				let content = HxOverrides.substr(this.input,contentStart,this.pos - contentStart);
				let count = 2;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				let position = start;
				if(position == null) {
					position = new loreline_Position(this.startLine,this.startColumn,this.pos);
				}
				position.length = this.pos - position.offset;
				let token = new loreline_Token(loreline_TokenType.CommentMultiLine(content),position);
				this.previous = token;
				return token;
			}
			let count = 2;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		} else if(HxOverrides.cca(this.input,this.pos) == 47 && (this.pos + 1 < this.length ? HxOverrides.cca(this.input,this.pos + 1) : 0) == 42) {
			++nestLevel;
			let count = 2;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		} else {
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		}
		this.error("Unterminated multi-line comment",true);
		return null;
	}
	readHashComment() {
		let start = new loreline_Position(this.startLine,this.startColumn,this.pos);
		let count = 1;
		while(count-- > 0 && this.pos < this.length) {
			if(HxOverrides.cca(this.input,this.pos) == 10) {
				this.line++;
				this.column = 1;
			} else {
				this.column++;
			}
			this.pos++;
		}
		let contentStart = this.pos;
		while(this.pos < this.length) {
			let c = HxOverrides.cca(this.input,this.pos);
			if(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57 || c == 45) {
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			} else {
				break;
			}
		}
		let type = loreline_TokenType.CommentHash(HxOverrides.substr(this.input,contentStart,this.pos - contentStart));
		let position = start;
		if(position == null) {
			position = new loreline_Position(this.startLine,this.startColumn,this.pos);
		}
		position.length = this.pos - position.offset;
		let token = new loreline_Token(type,position);
		this.previous = token;
		return token;
	}
	readNumber() {
		let start = new loreline_Position(this.startLine,this.startColumn,this.pos);
		let startPos = this.pos;
		while(true) {
			let tmp;
			if(this.pos < this.length) {
				let c = HxOverrides.cca(this.input,this.pos);
				tmp = c >= 48 && c <= 57;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		}
		let tmp;
		if(this.pos < this.length && HxOverrides.cca(this.input,this.pos) == 46 && this.pos + 1 < this.length) {
			let c = HxOverrides.cca(this.input,this.pos + 1);
			tmp = c >= 48 && c <= 57;
		} else {
			tmp = false;
		}
		if(tmp) {
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
			while(true) {
				let tmp;
				if(this.pos < this.length) {
					let c = HxOverrides.cca(this.input,this.pos);
					tmp = c >= 48 && c <= 57;
				} else {
					tmp = false;
				}
				if(!tmp) {
					break;
				}
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			}
		}
		let type = loreline_TokenType.LNumber(parseFloat(HxOverrides.substr(this.input,startPos,this.pos - startPos)));
		let position = start;
		if(position == null) {
			position = new loreline_Position(this.startLine,this.startColumn,this.pos);
		}
		position.length = this.pos - position.offset;
		let token = new loreline_Token(type,position);
		this.previous = token;
		let token1 = token;
		return token1;
	}
	readIdentifier() {
		let start = new loreline_Position(this.startLine,this.startColumn,this.pos);
		let startPos = this.pos;
		while(this.pos < this.length) {
			let c = HxOverrides.cca(this.input,this.pos);
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57)) {
				break;
			}
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		}
		let word = HxOverrides.substr(this.input,startPos,this.pos - startPos);
		if(word == "function") {
			return this.readFunction(start);
		}
		let tokenType = Object.prototype.hasOwnProperty.call(loreline_Lexer.KEYWORDS.h,word) ? loreline_Lexer.KEYWORDS.h[word] : loreline_TokenType.Identifier(word);
		let position = start;
		if(position == null) {
			position = new loreline_Position(this.startLine,this.startColumn,this.pos);
		}
		position.length = this.pos - position.offset;
		let token = new loreline_Token(tokenType,position);
		this.previous = token;
		return token;
	}
	readFunction(start) {
		let stopNextLine = false;
		if(stopNextLine == null) {
			stopNextLine = false;
		}
		let newPos = this._skipWhitespaceAndComments(this.pos,stopNextLine);
		while(this.pos < newPos) {
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		}
		let minIndent = start.column;
		let name = null;
		let c = HxOverrides.cca(this.input,this.pos);
		if(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95) {
			let nameStart = this.pos;
			while(true) {
				let tmp;
				if(this.pos < this.length) {
					let c = HxOverrides.cca(this.input,this.pos);
					tmp = c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57;
				} else {
					tmp = false;
				}
				if(!tmp) {
					break;
				}
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			}
			name = HxOverrides.substr(this.input,nameStart,this.pos - nameStart);
		}
		let stopNextLine1 = false;
		if(stopNextLine1 == null) {
			stopNextLine1 = false;
		}
		let newPos1 = this._skipWhitespaceAndComments(this.pos,stopNextLine1);
		while(this.pos < newPos1) {
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		}
		if(this.pos >= this.length || HxOverrides.cca(this.input,this.pos) != 40) {
			this.error("Expected opening parenthesis after function name",true);
		}
		let parenLevel = 0;
		let args = [];
		let count = 1;
		while(count-- > 0 && this.pos < this.length) {
			if(HxOverrides.cca(this.input,this.pos) == 10) {
				this.line++;
				this.column = 1;
			} else {
				this.column++;
			}
			this.pos++;
		}
		parenLevel = 1;
		let currentArg = new StringBuf();
		while(this.pos < this.length && parenLevel > 0) {
			let c = HxOverrides.cca(this.input,this.pos);
			if(c == 47) {
				let prevPos = this.pos;
				let stopNextLine = false;
				if(stopNextLine == null) {
					stopNextLine = false;
				}
				let newPos = this._skipWhitespaceAndComments(this.pos,stopNextLine);
				while(this.pos < newPos) {
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
				}
				if(this.pos == prevPos) {
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					this.error("Invalid character \"/\"",false);
				}
			} else if(c == 40) {
				++parenLevel;
				currentArg.b += String.fromCodePoint(c);
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				let stopNextLine = false;
				if(stopNextLine == null) {
					stopNextLine = false;
				}
				let newPos = this._skipWhitespaceAndComments(this.pos,stopNextLine);
				while(this.pos < newPos) {
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
				}
			} else if(c == 41) {
				--parenLevel;
				if(parenLevel > 0) {
					currentArg.b += String.fromCodePoint(c);
				} else {
					let argStr = StringTools.trim(currentArg.b);
					if(argStr.length > 0) {
						args.push(argStr);
					}
				}
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				let stopNextLine = false;
				if(stopNextLine == null) {
					stopNextLine = false;
				}
				let newPos = this._skipWhitespaceAndComments(this.pos,stopNextLine);
				while(this.pos < newPos) {
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
				}
			} else if(c == 44 && parenLevel == 1) {
				let argStr = StringTools.trim(currentArg.b);
				if(argStr.length > 0) {
					args.push(argStr);
				}
				currentArg = new StringBuf();
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				let stopNextLine = false;
				if(stopNextLine == null) {
					stopNextLine = false;
				}
				let newPos = this._skipWhitespaceAndComments(this.pos,stopNextLine);
				while(this.pos < newPos) {
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
				}
			} else {
				currentArg.b += String.fromCodePoint(c);
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			}
		}
		if(parenLevel > 0) {
			this.error("Unclosed parentheses in function declaration",false);
		}
		let stopNextLine2 = false;
		if(stopNextLine2 == null) {
			stopNextLine2 = false;
		}
		let newPos2 = this._skipWhitespaceAndComments(this.pos,stopNextLine2);
		while(this.pos < newPos2) {
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
		}
		let usesBraces = this.pos < this.length && HxOverrides.cca(this.input,this.pos) == 123;
		let lastLineBreakPos = this.pos;
		let lastLineBreakLine = this.line;
		let lastLineBreakColumn = this.column;
		if(usesBraces) {
			let count = 1;
			while(count-- > 0 && this.pos < this.length) {
				if(HxOverrides.cca(this.input,this.pos) == 10) {
					this.line++;
					this.column = 1;
				} else {
					this.column++;
				}
				this.pos++;
			}
			let braceLevel = 1;
			while(this.pos < this.length && braceLevel > 0) {
				let c = HxOverrides.cca(this.input,this.pos);
				if(c == 34) {
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					this.skipQuotedString();
					continue;
				}
				if(c == 123) {
					++braceLevel;
				} else if(c == 125) {
					--braceLevel;
				}
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			}
			if(braceLevel > 0) {
				this.error("Unclosed braces in function body",false);
			}
		} else {
			let functionIndentLevel = -1;
			let currentLine = true;
			while(this.pos < this.length) {
				let c = HxOverrides.cca(this.input,this.pos);
				if(c == 10 || c == 13) {
					lastLineBreakPos = this.pos;
					lastLineBreakLine = this.line;
					lastLineBreakColumn = this.column;
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					currentLine = true;
					break;
				}
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			}
			while(this.pos < this.length) {
				if(currentLine) {
					let indent = 0;
					let indentStart = this.pos;
					while(this.pos < this.length) {
						let c = HxOverrides.cca(this.input,this.pos);
						if(c == 32) {
							++indent;
						} else if(c == 9) {
							++indent;
						} else {
							break;
						}
						let count = 1;
						while(count-- > 0 && this.pos < this.length) {
							if(HxOverrides.cca(this.input,this.pos) == 10) {
								this.line++;
								this.column = 1;
							} else {
								this.column++;
							}
							this.pos++;
						}
					}
					if(functionIndentLevel == -1 && this.pos < this.length && HxOverrides.cca(this.input,this.pos) != 10 && HxOverrides.cca(this.input,this.pos) != 13) {
						functionIndentLevel = indent;
						if(functionIndentLevel < minIndent) {
							this.pos = indentStart;
							break;
						}
					} else if(functionIndentLevel != -1 && indent < functionIndentLevel && (this.pos >= this.length || HxOverrides.cca(this.input,this.pos) != 10 && HxOverrides.cca(this.input,this.pos) != 13)) {
						this.pos = indentStart;
						break;
					}
					currentLine = false;
				}
				let c = HxOverrides.cca(this.input,this.pos);
				if(c == 34) {
					this.skipQuotedString();
					continue;
				}
				if(c == 10 || c == 13) {
					lastLineBreakPos = this.pos;
					lastLineBreakLine = this.line;
					lastLineBreakColumn = this.column;
					currentLine = true;
				}
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			}
		}
		this.pos = lastLineBreakPos;
		this.line = lastLineBreakLine;
		this.column = lastLineBreakColumn;
		let bodyEnd = this.pos;
		let code = StringTools.rtrim(HxOverrides.substr(this.input,start.offset,bodyEnd - start.offset));
		let external = code.indexOf("\n",null) == -1;
		if(!external) {
			code += "\n";
		}
		let position = start;
		if(position == null) {
			position = new loreline_Position(this.startLine,this.startColumn,this.pos);
		}
		position.length = this.pos - position.offset;
		let token = new loreline_Token(loreline_TokenType.Function(name,args,code,external),position);
		this.previous = token;
		let token1 = token;
		token1.pos.length = code.length;
		return token1;
	}
	skipQuotedString() {
		let escaped = false;
		let count = 1;
		while(count-- > 0 && this.pos < this.length) {
			if(HxOverrides.cca(this.input,this.pos) == 10) {
				this.line++;
				this.column = 1;
			} else {
				this.column++;
			}
			this.pos++;
		}
		while(this.pos < this.length) {
			let c = HxOverrides.cca(this.input,this.pos);
			if(escaped) {
				escaped = false;
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			} else if(c == 92) {
				escaped = true;
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			} else if(c == 34) {
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				break;
			} else if(c == 36 && this.pos + 1 < this.length) {
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
				if(this.pos < this.length && HxOverrides.cca(this.input,this.pos) == 123) {
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					let interpBraceLevel = 1;
					while(this.pos < this.length && interpBraceLevel > 0) {
						let ic = HxOverrides.cca(this.input,this.pos);
						if(ic == 34) {
							this.skipQuotedString();
							continue;
						} else if(ic == 123) {
							++interpBraceLevel;
						} else if(ic == 125) {
							--interpBraceLevel;
						}
						if(interpBraceLevel > 0 || ic != 125) {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
						} else {
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
							break;
						}
					}
				} else {
					let c = HxOverrides.cca(this.input,this.pos);
					if(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95) {
						while(true) {
							let tmp;
							if(this.pos < this.length) {
								let c = HxOverrides.cca(this.input,this.pos);
								tmp = c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95 || c >= 48 && c <= 57;
							} else {
								tmp = false;
							}
							if(!tmp) {
								break;
							}
							let count = 1;
							while(count-- > 0 && this.pos < this.length) {
								if(HxOverrides.cca(this.input,this.pos) == 10) {
									this.line++;
									this.column = 1;
								} else {
									this.column++;
								}
								this.pos++;
							}
						}
					}
				}
			} else {
				let count = 1;
				while(count-- > 0 && this.pos < this.length) {
					if(HxOverrides.cca(this.input,this.pos) == 10) {
						this.line++;
						this.column = 1;
					} else {
						this.column++;
					}
					this.pos++;
				}
			}
		}
	}
	makePosition() {
		return new loreline_Position(this.startLine,this.startColumn,this.pos);
	}
	makeToken(type,position) {
		if(position == null) {
			position = new loreline_Position(this.startLine,this.startColumn,this.pos);
		}
		position.length = this.pos - position.offset;
		let token = new loreline_Token(type,position);
		this.previous = token;
		return token;
	}
	advance(count) {
		if(count == null) {
			count = 1;
		}
		while(count-- > 0 && this.pos < this.length) {
			if(HxOverrides.cca(this.input,this.pos) == 10) {
				this.line++;
				this.column = 1;
			} else {
				this.column++;
			}
			this.pos++;
		}
	}
	peek(offset) {
		if(offset == null) {
			offset = 1;
		}
		if(this.pos + offset < this.length) {
			return HxOverrides.cca(this.input,this.pos + offset);
		} else {
			return 0;
		}
	}
	error(message,fatal) {
		let err = new loreline_LexerError(message,new loreline_Position(this.startLine,this.startColumn,this.pos));
		if(this.errors == null) {
			this.errors = [];
		}
		this.errors.push(err);
		if(fatal) {
			throw haxe_Exception.thrown(err);
		}
		return err;
	}
	getErrors() {
		if(this.errors == null) {
			this.errors = [];
		}
		return this.errors;
	}
	skipWhitespace() {
		while(this.pos < this.length) {
			let _g = HxOverrides.cca(this.input,this.pos);
			if(_g == null) {
				return;
			} else {
				switch(_g) {
				case 9:case 32:
					let count = 1;
					while(count-- > 0 && this.pos < this.length) {
						if(HxOverrides.cca(this.input,this.pos) == 10) {
							this.line++;
							this.column = 1;
						} else {
							this.column++;
						}
						this.pos++;
					}
					break;
				default:
					return;
				}
			}
		}
	}
	isDigit(c) {
		if(c >= 48) {
			return c <= 57;
		} else {
			return false;
		}
	}
	isIdentifierStart(c) {
		if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90)) {
			return c == 95;
		} else {
			return true;
		}
	}
	isLowerCase(c) {
		if(c >= 97) {
			return c <= 122;
		} else {
			return false;
		}
	}
	isIdentifierPart(c) {
		if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 95)) {
			if(c >= 48) {
				return c <= 57;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static compareAttachments(l,r) {
		let lStart;
		switch(l._hx_index) {
		case 0:
			let _g = l.braces;
			let _g1 = l.inTag;
			let _g2 = l.expr;
			let _g3 = l.length;
			let start = l.start;
			lStart = start;
			break;
		case 1:
			let _g4 = l.closing;
			let _g5 = l.length;
			let start1 = l.start;
			lStart = start1;
			break;
		}
		let rStart;
		switch(r._hx_index) {
		case 0:
			let _g6 = r.braces;
			let _g7 = r.inTag;
			let _g8 = r.expr;
			let _g9 = r.length;
			let start2 = r.start;
			rStart = start2;
			break;
		case 1:
			let _g10 = r.closing;
			let _g11 = r.length;
			let start3 = r.start;
			rStart = start3;
			break;
		}
		return lStart - rStart;
	}
}
$hxClasses["loreline.Lexer"] = loreline_Lexer;
loreline_Lexer.__name__ = "loreline.Lexer";
Object.assign(loreline_Lexer.prototype, {
	__class__: loreline_Lexer
});
class loreline_Loreline {
	static parse(input,filePath,handleFile,callback) {
		let lexer = new loreline_Lexer(input);
		let tokens = lexer.tokenize();
		let lexerErrors = lexer.getErrors();
		if(lexerErrors != null && lexerErrors.length > 0) {
			throw haxe_Exception.thrown(lexerErrors[0]);
		}
		let result = null;
		if(filePath != null && handleFile != null) {
			let imports = new loreline_Imports();
			imports.resolve(filePath,tokens,handleFile,function(error) {
				throw haxe_Exception.thrown(error);
			},function(hasErrors,resolvedImports) {
				let parser = new loreline_Parser(tokens,new loreline_ParserContext(filePath,filePath,resolvedImports,null));
				result = parser.parse();
				result.indentSize = lexer.detectedIndentSize;
				let parseErrors = parser.getErrors();
				if(parseErrors != null && parseErrors.length > 0) {
					throw haxe_Exception.thrown(parseErrors[0]);
				}
				if(callback != null) {
					callback(result);
				}
			});
			return result;
		}
		let parser = new loreline_Parser(tokens);
		result = parser.parse();
		result.indentSize = lexer.detectedIndentSize;
		let parseErrors = parser.getErrors();
		if(parseErrors != null && parseErrors.length > 0) {
			throw haxe_Exception.thrown(parseErrors[0]);
		}
		if(callback != null) {
			callback(result);
		}
		return result;
	}
	static play(script,handleDialogue,handleChoice,handleFinish,beatName,options) {
		let interpreter = new loreline_Interpreter(script,handleDialogue,handleChoice,handleFinish,options);
		interpreter.start(beatName);
		return interpreter;
	}
	static resume(script,handleDialogue,handleChoice,handleFinish,saveData,beatName,options) {
		let interpreter = new loreline_Interpreter(script,handleDialogue,handleChoice,handleFinish,options);
		interpreter.restore(saveData);
		if(beatName != null) {
			interpreter.start(beatName);
		} else {
			interpreter.resume();
		}
		return interpreter;
	}
	static extractTranslations(script) {
		return loreline_AstUtils.extractTranslations(script);
	}
}
$hxClasses["loreline.Loreline"] = $hx_exports["loreline"]["Loreline"] = loreline_Loreline;
loreline_Loreline.__name__ = "loreline.Loreline";
class loreline_NodeId {
	constructor(section,branch,block,node) {
		if(section < 0 || section > 65535) {
			throw haxe_Exception.thrown("Section value (" + section + ") should be between 0 and " + 65535);
		}
		if(branch < 0 || branch > 65535) {
			throw haxe_Exception.thrown("Branch value (" + branch + ") should be between 0 and " + 65535);
		}
		if(block < 0 || block > 65535) {
			throw haxe_Exception.thrown("Block value (" + block + ") should be between 0 and " + 65535);
		}
		if(node < 0 || node > 65535) {
			throw haxe_Exception.thrown("Node value (" + node + ") should be between 0 and " + 65535);
		}
		let high = section - 32768;
		let low = branch - 32768;
		if(high < 0) {
			high = high + 65536 & 65535;
		}
		if(low < 0) {
			low = low + 65536 & 65535;
		}
		let high1 = block - 32768;
		let low1 = node - 32768;
		if(high1 < 0) {
			high1 = high1 + 65536 & 65535;
		}
		if(low1 < 0) {
			low1 = low1 + 65536 & 65535;
		}
		this.thisVal = new haxe__$Int64__$_$_$Int64(high << 16 | low & 65535,high1 << 16 | low1 & 65535);
	}
	get_section() {
		let high = this.thisVal.high >> 16 & 65535;
		return (high >= 32768 ? high - 65536 : high) + 32768;
	}
	set_section(section) {
		let value = section - 32768;
		if(value < 0) {
			value = value + 65536 & 65535;
		}
		this.thisVal = new haxe__$Int64__$_$_$Int64(this.thisVal.high & 65535 | value << 16,this.thisVal.low);
		return section;
	}
	get_branch() {
		let low = this.thisVal.high & 65535;
		return (low >= 32768 ? low - 65536 : low) + 32768;
	}
	set_branch(branch) {
		let value = branch - 32768;
		if(value < 0) {
			value = value + 65536 & 65535;
		}
		this.thisVal = new haxe__$Int64__$_$_$Int64(this.thisVal.high & -65536 | value,this.thisVal.low);
		return branch;
	}
	get_block() {
		let high = this.thisVal.low >> 16 & 65535;
		return (high >= 32768 ? high - 65536 : high) + 32768;
	}
	set_block(block) {
		let value = block - 32768;
		if(value < 0) {
			value = value + 65536 & 65535;
		}
		this.thisVal = new haxe__$Int64__$_$_$Int64(this.thisVal.high,this.thisVal.low & 65535 | value << 16);
		return block;
	}
	get_node() {
		let low = this.thisVal.low & 65535;
		return (low >= 32768 ? low - 65536 : low) + 32768;
	}
	set_node(node) {
		let value = node - 32768;
		if(value < 0) {
			value = value + 65536 & 65535;
		}
		this.thisVal = new haxe__$Int64__$_$_$Int64(this.thisVal.high,this.thisVal.low & -65536 | value);
		return node;
	}
	nextSection() {
		let high = this.thisVal.high >> 16 & 65535;
		let section = (high >= 32768 ? high - 65536 : high) + 32768;
		if(section == 65535) {
			throw haxe_Exception.thrown("Node id section overflow");
		}
		return new loreline_NodeId(section + 1,0,0,0);
	}
	nextBranch() {
		let low = this.thisVal.high & 65535;
		let branch = (low >= 32768 ? low - 65536 : low) + 32768;
		if(branch == 65535) {
			return this.nextSection();
		}
		let high = this.thisVal.high >> 16 & 65535;
		return new loreline_NodeId((high >= 32768 ? high - 65536 : high) + 32768,branch + 1,0,0);
	}
	nextBlock() {
		let high = this.thisVal.low >> 16 & 65535;
		let block = (high >= 32768 ? high - 65536 : high) + 32768;
		if(block == 65535) {
			return this.nextBranch();
		}
		let high1 = this.thisVal.high >> 16 & 65535;
		let low = this.thisVal.high & 65535;
		return new loreline_NodeId((high1 >= 32768 ? high1 - 65536 : high1) + 32768,(low >= 32768 ? low - 65536 : low) + 32768,block + 1,0);
	}
	nextNode() {
		let low = this.thisVal.low & 65535;
		let node = (low >= 32768 ? low - 65536 : low) + 32768;
		if(node == 65535) {
			return this.nextBlock();
		}
		let high = this.thisVal.high >> 16 & 65535;
		let low1 = this.thisVal.high & 65535;
		let high1 = this.thisVal.low >> 16 & 65535;
		return new loreline_NodeId((high >= 32768 ? high - 65536 : high) + 32768,(low1 >= 32768 ? low1 - 65536 : low1) + 32768,(high1 >= 32768 ? high1 - 65536 : high1) + 32768,node + 1);
	}
	toInt64() {
		return this.thisVal;
	}
	toString() {
		let high = this.thisVal.high >> 16 & 65535;
		let low = this.thisVal.high & 65535;
		let high1 = this.thisVal.low >> 16 & 65535;
		let low1 = this.thisVal.low & 65535;
		return "" + ((high >= 32768 ? high - 65536 : high) + 32768) + "." + ((low >= 32768 ? low - 65536 : low) + 32768) + "." + ((high1 >= 32768 ? high1 - 65536 : high1) + 32768) + "." + ((low1 >= 32768 ? low1 - 65536 : low1) + 32768);
	}
	static fromInt64(value) {
		return value;
	}
	static fromString(str) {
		let parts = str.split(".");
		return new loreline_NodeId(Std.parseInt(parts[0]),Std.parseInt(parts[1]),Std.parseInt(parts[2]),Std.parseInt(parts[3]));
	}
	static fromTwoInt32(high,low) {
		return loreline_NodeId.fromInt64(new haxe__$Int64__$_$_$Int64(high,low));
	}
	static packInt32(high,low) {
		if(high < 0) {
			high = high + 65536 & 65535;
		}
		if(low < 0) {
			low = low + 65536 & 65535;
		}
		return high << 16 | low & 65535;
	}
	static int32GetLow(value) {
		let low = value & 65535;
		if(low >= 32768) {
			return low - 65536;
		} else {
			return low;
		}
	}
	static int32SetLow(target,value) {
		if(value < 0) {
			value = value + 65536 & 65535;
		}
		return target & -65536 | value;
	}
	static int32GetHigh(value) {
		let high = value >> 16 & 65535;
		if(high >= 32768) {
			return high - 65536;
		} else {
			return high;
		}
	}
	static int32SetHigh(target,value) {
		if(value < 0) {
			value = value + 65536 & 65535;
		}
		return target & 65535 | value << 16;
	}
	static equals(a,b) {
		let a1 = a.thisVal;
		let b1 = b.thisVal;
		if(a1.high == b1.high) {
			return a1.low == b1.low;
		} else {
			return false;
		}
	}
}
$hxClasses["loreline.NodeId"] = loreline_NodeId;
loreline_NodeId.__name__ = "loreline.NodeId";
Object.assign(loreline_NodeId.prototype, {
	__class__: loreline_NodeId
	,__properties__: {set_node: "set_node",get_node: "get_node",set_block: "set_block",get_block: "get_block",set_branch: "set_branch",get_branch: "get_branch",set_section: "set_section",get_section: "get_section"}
});
class loreline_NodeIdMap {
	constructor() {
		this.map = new loreline_Int64Map();
	}
	get(key) {
		let key1 = key.thisVal;
		return this.map._get(key1.high,key1.low);
	}
	set(key,value) {
		let key1 = key.thisVal;
		this.map._set(key1.high,key1.low,value);
	}
	remove(key) {
		let key1 = key.thisVal;
		this.map._remove(key1.high,key1.low);
	}
	exists(key) {
		let key1 = key.thisVal;
		return this.map._exists(key1.high,key1.low);
	}
	clear() {
		this.map.clear();
	}
	iterator() {
		return new loreline__$Node_NodeIdMapIterator(this.map);
	}
	keys() {
		return new loreline__$Node_NodeIdMapKeyIterator(this.map);
	}
	keyValueIterator() {
		return new loreline__$Node_NodeIdMapKeyValueIterator(this.map);
	}
}
$hxClasses["loreline.NodeIdMap"] = loreline_NodeIdMap;
loreline_NodeIdMap.__name__ = "loreline.NodeIdMap";
Object.assign(loreline_NodeIdMap.prototype, {
	__class__: loreline_NodeIdMap
});
class loreline__$Node_NodeIdMapIterator {
	constructor(map) {
		this.map = map;
		this.index = 0;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	skipNulls() {
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	hasNext() {
		return this.index < this.map._values.length;
	}
	next() {
		let v = this.map._values[this.index];
		this.index++;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
		return v;
	}
}
$hxClasses["loreline._Node.NodeIdMapIterator"] = loreline__$Node_NodeIdMapIterator;
loreline__$Node_NodeIdMapIterator.__name__ = "loreline._Node.NodeIdMapIterator";
Object.assign(loreline__$Node_NodeIdMapIterator.prototype, {
	__class__: loreline__$Node_NodeIdMapIterator
});
class loreline__$Node_NodeIdMapKeyIterator {
	constructor(map) {
		this.map = map;
		this.index = 0;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	skipNulls() {
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	hasNext() {
		return this.index < this.map._values.length;
	}
	next() {
		let k1 = this.map._keys1[this.index];
		let k2 = this.map._keys2[this.index];
		this.index++;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
		return loreline_NodeId.fromTwoInt32(k1,k2);
	}
}
$hxClasses["loreline._Node.NodeIdMapKeyIterator"] = loreline__$Node_NodeIdMapKeyIterator;
loreline__$Node_NodeIdMapKeyIterator.__name__ = "loreline._Node.NodeIdMapKeyIterator";
Object.assign(loreline__$Node_NodeIdMapKeyIterator.prototype, {
	__class__: loreline__$Node_NodeIdMapKeyIterator
});
class loreline__$Node_NodeIdMapKeyValueIterator {
	constructor(map) {
		this.map = map;
		this.index = 0;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	skipNulls() {
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
	}
	hasNext() {
		return this.index < this.map._values.length;
	}
	next() {
		let k1 = this.map._keys1[this.index];
		let k2 = this.map._keys2[this.index];
		let v = this.map._values[this.index];
		this.index++;
		while(this.index < this.map._values.length && this.map._values[this.index] == null) this.index++;
		return { key : loreline_NodeId.fromTwoInt32(k1,k2), value : v};
	}
}
$hxClasses["loreline._Node.NodeIdMapKeyValueIterator"] = loreline__$Node_NodeIdMapKeyValueIterator;
loreline__$Node_NodeIdMapKeyValueIterator.__name__ = "loreline._Node.NodeIdMapKeyValueIterator";
Object.assign(loreline__$Node_NodeIdMapKeyValueIterator.prototype, {
	__class__: loreline__$Node_NodeIdMapKeyValueIterator
});
class loreline_Node {
	constructor(id,pos) {
		if(loreline_Node._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(id,pos);
	}
	_hx_constructor(id,pos) {
		this.id = loreline_NodeId.UNDEFINED;
		this.id = id;
		this.pos = pos;
	}
	type() {
		return "Node";
	}
	toJson() {
		return { id : this.id.toString(), type : this.type(), pos : this.pos.toJson()};
	}
	each(handleNode) {
	}
}
$hxClasses["loreline.Node"] = $hx_exports["loreline"]["Node"] = loreline_Node;
loreline_Node.__name__ = "loreline.Node";
Object.assign(loreline_Node.prototype, {
	__class__: loreline_Node
});
class loreline_Comment extends loreline_Node {
	constructor(id,pos,content,multiline,isHash) {
		if(isHash == null) {
			isHash = false;
		}
		super(id,pos);
		this.content = content;
		this.multiline = multiline;
		this.isHash = isHash;
	}
	type() {
		return "Comment";
	}
	toJson() {
		let json = super.toJson();
		json.content = this.content;
		json.multiline = this.multiline;
		if(this.isHash) {
			json.isHash = true;
		}
		return json;
	}
}
$hxClasses["loreline.Comment"] = loreline_Comment;
loreline_Comment.__name__ = "loreline.Comment";
loreline_Comment.__super__ = loreline_Node;
Object.assign(loreline_Comment.prototype, {
	__class__: loreline_Comment
});
class loreline_AstNode extends loreline_Node {
	constructor(id,pos,leadingComments,trailingComments) {
		if(loreline_Node._hx_skip_constructor) {
			super();
			return;
		}
		loreline_Node._hx_skip_constructor = true;
		super();
		loreline_Node._hx_skip_constructor = false;
		this._hx_constructor(id,pos,leadingComments,trailingComments);
	}
	_hx_constructor(id,pos,leadingComments,trailingComments) {
		super._hx_constructor(id,pos);
		this.leadingComments = leadingComments;
		this.trailingComments = trailingComments;
	}
	type() {
		return "AstNode";
	}
	eachComment(handleComment) {
		if(this.leadingComments != null) {
			let _g = 0;
			let _g1 = this.leadingComments;
			while(_g < _g1.length) {
				let comment = _g1[_g];
				++_g;
				handleComment(this,comment);
			}
		}
		if(this.trailingComments != null) {
			let _g = 0;
			let _g1 = this.trailingComments;
			while(_g < _g1.length) {
				let comment = _g1[_g];
				++_g;
				handleComment(this,comment);
			}
		}
		let _gthis = this;
		this.each(function(node,_) {
			if(((node) instanceof loreline_AstNode)) {
				let astNode = node;
				if(astNode.leadingComments != null) {
					let _g = 0;
					let _g1 = astNode.leadingComments;
					while(_g < _g1.length) {
						let comment = _g1[_g];
						++_g;
						handleComment(_gthis,comment);
					}
				}
				if(astNode.trailingComments != null) {
					let _g = 0;
					let _g1 = astNode.trailingComments;
					while(_g < _g1.length) {
						let comment = _g1[_g];
						++_g;
						handleComment(_gthis,comment);
					}
				}
			}
		});
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.leadingComments != null) {
			let _g = 0;
			let _g1 = this.leadingComments;
			while(_g < _g1.length) {
				let comment = _g1[_g];
				++_g;
				handleNode(comment,this);
				comment.each(handleNode);
			}
		}
		if(this.trailingComments != null) {
			let _g = 0;
			let _g1 = this.trailingComments;
			while(_g < _g1.length) {
				let comment = _g1[_g];
				++_g;
				handleNode(comment,this);
				comment.each(handleNode);
			}
		}
	}
	toJson() {
		let json = super.toJson();
		if(this.leadingComments != null && this.leadingComments.length > 0 || this.trailingComments != null && this.trailingComments.length > 0) {
			let comments = { };
			if(this.leadingComments != null && this.leadingComments.length > 0) {
				let _g = [];
				let _g1 = 0;
				let _g2 = this.leadingComments;
				while(_g1 < _g2.length) {
					let c = _g2[_g1];
					++_g1;
					_g.push(c.toJson());
				}
				comments.leading = _g;
			}
			if(this.trailingComments != null && this.trailingComments.length > 0) {
				let _g = [];
				let _g1 = 0;
				let _g2 = this.trailingComments;
				while(_g1 < _g2.length) {
					let c = _g2[_g1];
					++_g1;
					_g.push(c.toJson());
				}
				comments.trailing = _g;
			}
			json.comments = comments;
		}
		return json;
	}
}
$hxClasses["loreline.AstNode"] = loreline_AstNode;
loreline_AstNode.__name__ = "loreline.AstNode";
loreline_AstNode.__super__ = loreline_Node;
Object.assign(loreline_AstNode.prototype, {
	__class__: loreline_AstNode
});
class loreline_NExpr extends loreline_AstNode {
	constructor(id,pos,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
	}
	toJson() {
		return super.toJson();
	}
	type() {
		return "Expr";
	}
}
$hxClasses["loreline.NExpr"] = loreline_NExpr;
loreline_NExpr.__name__ = "loreline.NExpr";
loreline_NExpr.__super__ = loreline_AstNode;
Object.assign(loreline_NExpr.prototype, {
	__class__: loreline_NExpr
});
class loreline_NStateDecl extends loreline_AstNode {
	constructor(id,pos,temporary,fields,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.temporary = temporary;
		this.fields = fields;
		this.style = 0;
	}
	type() {
		return "State";
	}
	get(name) {
		let _g = 0;
		let _g1 = this.fields;
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			if(field.name == name) {
				return field.value;
			}
		}
		return null;
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.fields != null) {
			let _g = 0;
			let _g1 = this.fields.length;
			while(_g < _g1) {
				let i = _g++;
				let child = this.fields[i];
				handleNode(child,this);
				child.each(handleNode);
			}
		}
	}
	toJson() {
		let json = super.toJson();
		json.temporary = this.temporary;
		let _g = [];
		let _g1 = 0;
		let _g2 = this.fields;
		while(_g1 < _g2.length) {
			let prop = _g2[_g1];
			++_g1;
			_g.push(prop.toJson());
		}
		json.fields = _g;
		json.style = loreline_BlockStyle.toString(this.style);
		return json;
	}
}
$hxClasses["loreline.NStateDecl"] = loreline_NStateDecl;
loreline_NStateDecl.__name__ = "loreline.NStateDecl";
loreline_NStateDecl.__super__ = loreline_AstNode;
Object.assign(loreline_NStateDecl.prototype, {
	__class__: loreline_NStateDecl
});
class loreline_NObjectField extends loreline_AstNode {
	constructor(id,pos,name,value,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.name = name;
		this.value = value;
	}
	type() {
		return "Field";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.value != null) {
			handleNode(this.value,this);
			this.value.each(handleNode);
		}
	}
	toJson() {
		let json = super.toJson();
		json.name = this.name;
		json.value = this.value.toJson();
		return json;
	}
}
$hxClasses["loreline.NObjectField"] = loreline_NObjectField;
loreline_NObjectField.__name__ = "loreline.NObjectField";
loreline_NObjectField.__super__ = loreline_AstNode;
Object.assign(loreline_NObjectField.prototype, {
	__class__: loreline_NObjectField
});
class loreline_NCharacterDecl extends loreline_AstNode {
	constructor(id,pos,name,namePos,fields,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.name = name;
		this.namePos = namePos;
		this.fields = fields;
		this.style = 0;
	}
	type() {
		return "Character";
	}
	get(name) {
		let _g = 0;
		let _g1 = this.fields;
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			if(field.name == name) {
				return field.value;
			}
		}
		return null;
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.fields != null) {
			let _g = 0;
			let _g1 = this.fields.length;
			while(_g < _g1) {
				let i = _g++;
				let child = this.fields[i];
				handleNode(child,this);
				child.each(handleNode);
			}
		}
	}
	toJson() {
		let json = super.toJson();
		json.name = this.name;
		json.namePos = this.namePos.toJson();
		let _g = [];
		let _g1 = 0;
		let _g2 = this.fields;
		while(_g1 < _g2.length) {
			let prop = _g2[_g1];
			++_g1;
			_g.push(prop.toJson());
		}
		json.fields = _g;
		json.style = loreline_BlockStyle.toString(this.style);
		return json;
	}
}
$hxClasses["loreline.NCharacterDecl"] = loreline_NCharacterDecl;
loreline_NCharacterDecl.__name__ = "loreline.NCharacterDecl";
loreline_NCharacterDecl.__super__ = loreline_AstNode;
Object.assign(loreline_NCharacterDecl.prototype, {
	__class__: loreline_NCharacterDecl
});
class loreline_NBeatDecl extends loreline_AstNode {
	constructor(id,pos,name,body,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.name = name;
		this.body = body;
		this.style = 0;
	}
	type() {
		return "Beat";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.body != null) {
			let _g = 0;
			let _g1 = this.body.length;
			while(_g < _g1) {
				let i = _g++;
				let child = this.body[i];
				handleNode(child,this);
				child.each(handleNode);
			}
		}
	}
	toJson() {
		let json = super.toJson();
		json.name = this.name;
		let _g = [];
		let _g1 = 0;
		let _g2 = this.body;
		while(_g1 < _g2.length) {
			let node = _g2[_g1];
			++_g1;
			_g.push(node.toJson());
		}
		json.body = _g;
		json.style = loreline_BlockStyle.toString(this.style);
		return json;
	}
}
$hxClasses["loreline.NBeatDecl"] = loreline_NBeatDecl;
loreline_NBeatDecl.__name__ = "loreline.NBeatDecl";
loreline_NBeatDecl.__super__ = loreline_AstNode;
Object.assign(loreline_NBeatDecl.prototype, {
	__class__: loreline_NBeatDecl
});
var loreline_StringPartType = $hxEnums["loreline.StringPartType"] = { __ename__:"loreline.StringPartType",__constructs__:null
	,Raw: ($_=function(text) { return {_hx_index:0,text:text,__enum__:"loreline.StringPartType",toString:$estr}; },$_._hx_name="Raw",$_.__params__ = ["text"],$_)
	,Expr: ($_=function(expr) { return {_hx_index:1,expr:expr,__enum__:"loreline.StringPartType",toString:$estr}; },$_._hx_name="Expr",$_.__params__ = ["expr"],$_)
	,Tag: ($_=function(closing,expr) { return {_hx_index:2,closing:closing,expr:expr,__enum__:"loreline.StringPartType",toString:$estr}; },$_._hx_name="Tag",$_.__params__ = ["closing","expr"],$_)
};
loreline_StringPartType.__constructs__ = [loreline_StringPartType.Raw,loreline_StringPartType.Expr,loreline_StringPartType.Tag];
class loreline_BlockStyle {
	static toString(this1) {
		switch(this1) {
		case 0:
			return "Plain";
		case 1:
			return "Braces";
		}
	}
}
class loreline_ConditionStyle {
	static toString(this1) {
		switch(this1) {
		case 0:
			return "Plain";
		case 2:
			return "Parens";
		}
	}
}
class loreline_NStringPart extends loreline_NExpr {
	constructor(id,pos,partType,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.partType = partType;
	}
	type() {
		return "Part";
	}
	each(handleNode) {
		super.each(handleNode);
		let _g = this.partType;
		switch(_g._hx_index) {
		case 0:
			let _g1 = _g.text;
			break;
		case 1:
			let expr = _g.expr;
			handleNode(expr,this);
			expr.each(handleNode);
			break;
		case 2:
			let _g2 = _g.closing;
			let expr1 = _g.expr;
			handleNode(expr1,this);
			expr1.each(handleNode);
			break;
		}
	}
	toJson() {
		let json = super.toJson();
		let _g = this.partType;
		switch(_g._hx_index) {
		case 0:
			let text = _g.text;
			json.part = "Raw";
			json.text = text;
			break;
		case 1:
			let expr = _g.expr;
			json.part = "Expr";
			json.expression = expr.toJson();
			break;
		case 2:
			let closing = _g.closing;
			let expr1 = _g.expr;
			json.part = "Tag";
			json.closing = closing;
			json.content = expr1.toJson();
			break;
		}
		return json;
	}
}
$hxClasses["loreline.NStringPart"] = loreline_NStringPart;
loreline_NStringPart.__name__ = "loreline.NStringPart";
loreline_NStringPart.__super__ = loreline_NExpr;
Object.assign(loreline_NStringPart.prototype, {
	__class__: loreline_NStringPart
});
class loreline_NStringLiteral extends loreline_NExpr {
	constructor(id,pos,quotes,parts,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.parts = parts;
		this.quotes = quotes;
	}
	type() {
		return "String";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.parts != null) {
			let _g = 0;
			let _g1 = this.parts.length;
			while(_g < _g1) {
				let i = _g++;
				let part = this.parts[i];
				handleNode(part,this);
				part.each(handleNode);
			}
		}
	}
	toJson() {
		let json = super.toJson();
		let _g = [];
		let _g1 = 0;
		let _g2 = this.parts;
		while(_g1 < _g2.length) {
			let part = _g2[_g1];
			++_g1;
			_g.push(part.toJson());
		}
		let parts = _g;
		json.parts = parts;
		json.quotes = loreline_Quotes.toString(this.quotes);
		return json;
	}
}
$hxClasses["loreline.NStringLiteral"] = loreline_NStringLiteral;
loreline_NStringLiteral.__name__ = "loreline.NStringLiteral";
loreline_NStringLiteral.__super__ = loreline_NExpr;
Object.assign(loreline_NStringLiteral.prototype, {
	__class__: loreline_NStringLiteral
});
class loreline_NTextStatement extends loreline_AstNode {
	constructor(id,pos,content,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.content = content;
	}
	type() {
		return "Text";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.content != null) {
			handleNode(this.content,this);
			this.content.each(handleNode);
		}
	}
	toJson() {
		let json = super.toJson();
		json.content = this.content.toJson();
		return json;
	}
}
$hxClasses["loreline.NTextStatement"] = loreline_NTextStatement;
loreline_NTextStatement.__name__ = "loreline.NTextStatement";
loreline_NTextStatement.__super__ = loreline_AstNode;
Object.assign(loreline_NTextStatement.prototype, {
	__class__: loreline_NTextStatement
});
class loreline_NDialogueStatement extends loreline_AstNode {
	constructor(id,pos,character,characterPos,content,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.character = character;
		this.characterPos = characterPos;
		this.content = content;
	}
	type() {
		return "Dialogue";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.content != null) {
			handleNode(this.content,this);
			this.content.each(handleNode);
		}
	}
	toJson() {
		let json = super.toJson();
		json.character = this.character;
		json.characterPos = this.characterPos.toJson();
		json.content = this.content.toJson();
		return json;
	}
}
$hxClasses["loreline.NDialogueStatement"] = loreline_NDialogueStatement;
loreline_NDialogueStatement.__name__ = "loreline.NDialogueStatement";
loreline_NDialogueStatement.__super__ = loreline_AstNode;
Object.assign(loreline_NDialogueStatement.prototype, {
	__class__: loreline_NDialogueStatement
});
class loreline_NChoiceStatement extends loreline_AstNode {
	constructor(id,pos,options,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.options = options;
		this.style = 0;
	}
	type() {
		return "Choice";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.options != null) {
			let _g = 0;
			let _g1 = this.options.length;
			while(_g < _g1) {
				let i = _g++;
				let child = this.options[i];
				handleNode(child,this);
				child.each(handleNode);
			}
		}
	}
	toJson() {
		let json = super.toJson();
		let _g = [];
		let _g1 = 0;
		let _g2 = this.options;
		while(_g1 < _g2.length) {
			let option = _g2[_g1];
			++_g1;
			_g.push(option.toJson());
		}
		json.options = _g;
		json.style = loreline_BlockStyle.toString(this.style);
		return json;
	}
}
$hxClasses["loreline.NChoiceStatement"] = loreline_NChoiceStatement;
loreline_NChoiceStatement.__name__ = "loreline.NChoiceStatement";
loreline_NChoiceStatement.__super__ = loreline_AstNode;
Object.assign(loreline_NChoiceStatement.prototype, {
	__class__: loreline_NChoiceStatement
});
class loreline_NChoiceOption extends loreline_AstNode {
	constructor(id,pos,text,insertion,condition,conditionStyle,body,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.text = text;
		this.insertion = insertion;
		this.condition = condition;
		this.conditionStyle = conditionStyle;
		this.body = body;
		this.style = 0;
	}
	type() {
		return "Option";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.body != null) {
			let _g = 0;
			let _g1 = this.body.length;
			while(_g < _g1) {
				let i = _g++;
				let child = this.body[i];
				handleNode(child,this);
				child.each(handleNode);
			}
		}
		if(this.text != null) {
			handleNode(this.text,this);
			this.text.each(handleNode);
		}
		if(this.insertion != null) {
			handleNode(this.insertion,this);
			this.insertion.each(handleNode);
		}
		if(this.condition != null) {
			handleNode(this.condition,this);
			this.condition.each(handleNode);
		}
	}
	toJson() {
		let json = super.toJson();
		if(this.text != null) {
			json.text = this.text.toJson();
		}
		if(this.insertion != null) {
			json.insertion = this.insertion.toJson();
		}
		if(this.condition != null) {
			json.condition = this.condition.toJson();
			json.conditionStyle = loreline_ConditionStyle.toString(this.conditionStyle);
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = this.body;
		while(_g1 < _g2.length) {
			let node = _g2[_g1];
			++_g1;
			_g.push(node.toJson());
		}
		json.body = _g;
		json.style = loreline_BlockStyle.toString(this.style);
		return json;
	}
}
$hxClasses["loreline.NChoiceOption"] = loreline_NChoiceOption;
loreline_NChoiceOption.__name__ = "loreline.NChoiceOption";
loreline_NChoiceOption.__super__ = loreline_AstNode;
Object.assign(loreline_NChoiceOption.prototype, {
	__class__: loreline_NChoiceOption
});
class loreline_NBlock extends loreline_AstNode {
	constructor(id,pos,body,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.body = body;
		this.style = 0;
	}
	type() {
		return "Block";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.body != null) {
			let _g = 0;
			let _g1 = this.body.length;
			while(_g < _g1) {
				let i = _g++;
				let child = this.body[i];
				handleNode(child,this);
				child.each(handleNode);
			}
		}
	}
	toJson() {
		let json = super.toJson();
		let _g = [];
		let _g1 = 0;
		let _g2 = this.body;
		while(_g1 < _g2.length) {
			let node = _g2[_g1];
			++_g1;
			_g.push(node.toJson());
		}
		json.body = _g;
		json.style = loreline_BlockStyle.toString(this.style);
		return json;
	}
}
$hxClasses["loreline.NBlock"] = loreline_NBlock;
loreline_NBlock.__name__ = "loreline.NBlock";
loreline_NBlock.__super__ = loreline_AstNode;
Object.assign(loreline_NBlock.prototype, {
	__class__: loreline_NBlock
});
class loreline_NIfStatement extends loreline_AstNode {
	constructor(id,pos,condition,conditionStyle,thenBranch,elseBranch,leadingComments,trailingComments,elseLeadingComments,elseTrailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.condition = condition;
		this.conditionStyle = conditionStyle;
		this.thenBranch = thenBranch;
		this.elseBranch = elseBranch;
		this.elseLeadingComments = elseLeadingComments;
		this.elseTrailingComments = elseTrailingComments;
	}
	type() {
		return "If";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.condition != null) {
			handleNode(this.condition,this);
			this.condition.each(handleNode);
		}
		if(this.thenBranch != null) {
			handleNode(this.thenBranch,this);
			this.thenBranch.each(handleNode);
		}
		if(this.elseBranch != null) {
			handleNode(this.elseBranch,this);
			this.elseBranch.each(handleNode);
		}
		if(this.elseLeadingComments != null) {
			let _g = 0;
			let _g1 = this.elseLeadingComments;
			while(_g < _g1.length) {
				let comment = _g1[_g];
				++_g;
				handleNode(comment,this);
				comment.each(handleNode);
			}
		}
		if(this.elseTrailingComments != null) {
			let _g = 0;
			let _g1 = this.elseTrailingComments;
			while(_g < _g1.length) {
				let comment = _g1[_g];
				++_g;
				handleNode(comment,this);
				comment.each(handleNode);
			}
		}
	}
	toJson() {
		let json = super.toJson();
		json.condition = this.condition.toJson();
		json.conditionStyle = loreline_ConditionStyle.toString(this.conditionStyle);
		let _g = [];
		let _g1 = 0;
		let _g2 = this.thenBranch.body;
		while(_g1 < _g2.length) {
			let node = _g2[_g1];
			++_g1;
			_g.push(node.toJson());
		}
		json.thenBranch = _g;
		json.thenStyle = loreline_BlockStyle.toString(this.thenBranch.style);
		if(this.elseBranch != null) {
			let _g = [];
			let _g1 = 0;
			let _g2 = this.elseBranch.body;
			while(_g1 < _g2.length) {
				let node = _g2[_g1];
				++_g1;
				_g.push(node.toJson());
			}
			json.elseBranch = _g;
			json.elseStyle = loreline_BlockStyle.toString(this.elseBranch.style);
			if(this.elseLeadingComments != null && this.elseLeadingComments.length > 0 || this.elseTrailingComments != null && this.elseTrailingComments.length > 0) {
				let tmp = json.comments;
				let comments = tmp != null ? tmp : { };
				if(this.elseLeadingComments != null && this.elseLeadingComments.length > 0) {
					let _g = [];
					let _g1 = 0;
					let _g2 = this.elseLeadingComments;
					while(_g1 < _g2.length) {
						let c = _g2[_g1];
						++_g1;
						_g.push(c.toJson());
					}
					comments.elseLeading = _g;
				}
				if(this.elseTrailingComments != null && this.elseTrailingComments.length > 0) {
					let _g = [];
					let _g1 = 0;
					let _g2 = this.elseTrailingComments;
					while(_g1 < _g2.length) {
						let c = _g2[_g1];
						++_g1;
						_g.push(c.toJson());
					}
					comments.elseTrailing = _g;
				}
				json.comments = comments;
			}
		}
		return json;
	}
}
$hxClasses["loreline.NIfStatement"] = loreline_NIfStatement;
loreline_NIfStatement.__name__ = "loreline.NIfStatement";
loreline_NIfStatement.__super__ = loreline_AstNode;
Object.assign(loreline_NIfStatement.prototype, {
	__class__: loreline_NIfStatement
});
class loreline_NCall extends loreline_NExpr {
	constructor(id,pos,target,args,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.target = target;
		this.args = args;
	}
	type() {
		return "Call";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.target != null) {
			handleNode(this.target,this);
			this.target.each(handleNode);
		}
		if(this.args != null) {
			let _g = 0;
			let _g1 = this.args;
			while(_g < _g1.length) {
				let arg = _g1[_g];
				++_g;
				handleNode(arg,this);
				arg.each(handleNode);
			}
		}
	}
	toJson() {
		let json = super.toJson();
		json.target = this.target.toJson();
		let _g = [];
		let _g1 = 0;
		let _g2 = this.args;
		while(_g1 < _g2.length) {
			let arg = _g2[_g1];
			++_g1;
			_g.push(arg.toJson());
		}
		json.args = _g;
		return json;
	}
}
$hxClasses["loreline.NCall"] = loreline_NCall;
loreline_NCall.__name__ = "loreline.NCall";
loreline_NCall.__super__ = loreline_NExpr;
Object.assign(loreline_NCall.prototype, {
	__class__: loreline_NCall
});
class loreline_NTransition extends loreline_AstNode {
	constructor(id,pos,target,targetPos,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.target = target;
		this.targetPos = targetPos;
	}
	type() {
		return "Transition";
	}
	toJson() {
		let json = super.toJson();
		json.target = this.target;
		json.targetPos = this.targetPos.toJson();
		return json;
	}
}
$hxClasses["loreline.NTransition"] = loreline_NTransition;
loreline_NTransition.__name__ = "loreline.NTransition";
loreline_NTransition.__super__ = loreline_AstNode;
Object.assign(loreline_NTransition.prototype, {
	__class__: loreline_NTransition
});
class loreline_NInsertion extends loreline_AstNode {
	constructor(id,pos,target,targetPos,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.target = target;
		this.targetPos = targetPos;
	}
	type() {
		return "Insertion";
	}
	toJson() {
		let json = super.toJson();
		json.target = this.target;
		json.targetPos = this.targetPos.toJson();
		return json;
	}
}
$hxClasses["loreline.NInsertion"] = loreline_NInsertion;
loreline_NInsertion.__name__ = "loreline.NInsertion";
loreline_NInsertion.__super__ = loreline_AstNode;
Object.assign(loreline_NInsertion.prototype, {
	__class__: loreline_NInsertion
});
class loreline_NFunctionDecl extends loreline_NExpr {
	constructor(id,pos,name,args,code,external,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.name = name;
		this.args = args;
		this.code = code;
		this.external = external;
	}
	type() {
		return "Function";
	}
	toJson() {
		let json = super.toJson();
		if(this.name != null) {
			json.name = this.name;
		}
		json.args = [].concat(this.args);
		json.code = this.code;
		json.external = this.external;
		return json;
	}
}
$hxClasses["loreline.NFunctionDecl"] = loreline_NFunctionDecl;
loreline_NFunctionDecl.__name__ = "loreline.NFunctionDecl";
loreline_NFunctionDecl.__super__ = loreline_NExpr;
Object.assign(loreline_NFunctionDecl.prototype, {
	__class__: loreline_NFunctionDecl
});
class loreline_NLiteral extends loreline_NExpr {
	constructor(id,pos,value,literalType,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.value = value;
		this.literalType = literalType;
	}
	type() {
		return "Literal";
	}
	each(handleNode) {
		super.each(handleNode);
		let _g = this.literalType;
		switch(_g._hx_index) {
		case 0:case 1:case 2:
			break;
		case 3:
			if(this.value != null) {
				let _g = 0;
				let _g1 = this.value;
				while(_g < _g1.length) {
					let elem = _g1[_g];
					++_g;
					if(((elem) instanceof loreline_Node)) {
						let node = elem;
						handleNode(node,this);
						node.each(handleNode);
					}
				}
			}
			break;
		case 4:
			let style = _g.style;
			if(this.value != null) {
				let _g = 0;
				let _g1 = this.value;
				while(_g < _g1.length) {
					let field = _g1[_g];
					++_g;
					if(((field.value) instanceof loreline_Node)) {
						let node = field.value;
						handleNode(node,this);
						node.each(handleNode);
					}
				}
			}
			break;
		}
	}
	toJson() {
		let json = super.toJson();
		let e = this.literalType;
		json.literal = $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name;
		let _g = this.literalType;
		switch(_g._hx_index) {
		case 0:case 1:case 2:
			json.value = this.value;
			break;
		case 3:
			if(this.value != null) {
				let _g = [];
				let _g1 = 0;
				let _g2 = this.value;
				while(_g1 < _g2.length) {
					let elem = _g2[_g1];
					++_g1;
					if(((elem) instanceof loreline_Node)) {
						_g.push(elem.toJson());
					} else {
						_g.push(elem);
					}
				}
				json.value = _g;
			}
			break;
		case 4:
			let style = _g.style;
			if(this.value != null) {
				let _g = [];
				let _g1 = 0;
				let _g2 = this.value;
				while(_g1 < _g2.length) {
					let field = _g2[_g1];
					++_g1;
					_g.push(field.toJson());
				}
				json.value = _g;
			} else {
				json.value = [];
			}
			json.style = loreline_BlockStyle.toString(style);
			break;
		}
		return json;
	}
}
$hxClasses["loreline.NLiteral"] = loreline_NLiteral;
loreline_NLiteral.__name__ = "loreline.NLiteral";
loreline_NLiteral.__super__ = loreline_NExpr;
Object.assign(loreline_NLiteral.prototype, {
	__class__: loreline_NLiteral
});
var loreline_LiteralType = $hxEnums["loreline.LiteralType"] = { __ename__:"loreline.LiteralType",__constructs__:null
	,Number: {_hx_name:"Number",_hx_index:0,__enum__:"loreline.LiteralType",toString:$estr}
	,Boolean: {_hx_name:"Boolean",_hx_index:1,__enum__:"loreline.LiteralType",toString:$estr}
	,Null: {_hx_name:"Null",_hx_index:2,__enum__:"loreline.LiteralType",toString:$estr}
	,Array: {_hx_name:"Array",_hx_index:3,__enum__:"loreline.LiteralType",toString:$estr}
	,Object: ($_=function(style) { return {_hx_index:4,style:style,__enum__:"loreline.LiteralType",toString:$estr}; },$_._hx_name="Object",$_.__params__ = ["style"],$_)
};
loreline_LiteralType.__constructs__ = [loreline_LiteralType.Number,loreline_LiteralType.Boolean,loreline_LiteralType.Null,loreline_LiteralType.Array,loreline_LiteralType.Object];
class loreline_NAccess extends loreline_NExpr {
	constructor(id,pos,target,name,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.target = target;
		this.name = name;
	}
	type() {
		return "Access";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.target != null) {
			handleNode(this.target,this);
			this.target.each(handleNode);
		}
	}
	toJson() {
		let json = super.toJson();
		if(this.target != null) {
			json.target = this.target.toJson();
		}
		json.name = this.name;
		return json;
	}
}
$hxClasses["loreline.NAccess"] = loreline_NAccess;
loreline_NAccess.__name__ = "loreline.NAccess";
loreline_NAccess.__super__ = loreline_NExpr;
Object.assign(loreline_NAccess.prototype, {
	__class__: loreline_NAccess
});
class loreline_NAssign extends loreline_NExpr {
	constructor(id,pos,target,op,value,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.target = target;
		this.op = op;
		this.value = value;
	}
	type() {
		return "Assign";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.target != null) {
			handleNode(this.target,this);
			this.target.each(handleNode);
		}
		if(this.value != null) {
			handleNode(this.value,this);
			this.value.each(handleNode);
		}
	}
	toJson() {
		let json = super.toJson();
		json.target = this.target.toJson();
		json.op = Std.string(this.op);
		json.value = this.value.toJson();
		return json;
	}
}
$hxClasses["loreline.NAssign"] = loreline_NAssign;
loreline_NAssign.__name__ = "loreline.NAssign";
loreline_NAssign.__super__ = loreline_NExpr;
Object.assign(loreline_NAssign.prototype, {
	__class__: loreline_NAssign
});
class loreline_NArrayAccess extends loreline_NExpr {
	constructor(id,pos,target,index,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.target = target;
		this.index = index;
	}
	type() {
		return "ArrayAccess";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.target != null) {
			handleNode(this.target,this);
			this.target.each(handleNode);
		}
		if(this.index != null) {
			handleNode(this.index,this);
			this.index.each(handleNode);
		}
	}
	toJson() {
		let json = super.toJson();
		json.target = this.target.toJson();
		json.index = this.index.toJson();
		return json;
	}
}
$hxClasses["loreline.NArrayAccess"] = loreline_NArrayAccess;
loreline_NArrayAccess.__name__ = "loreline.NArrayAccess";
loreline_NArrayAccess.__super__ = loreline_NExpr;
Object.assign(loreline_NArrayAccess.prototype, {
	__class__: loreline_NArrayAccess
});
class loreline_NBinary extends loreline_NExpr {
	constructor(id,pos,left,op,right,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.left = left;
		this.op = op;
		this.right = right;
	}
	type() {
		return "Binary";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.left != null) {
			handleNode(this.left,this);
			this.left.each(handleNode);
		}
		if(this.right != null) {
			handleNode(this.right,this);
			this.right.each(handleNode);
		}
	}
	toJson() {
		let json = super.toJson();
		json.left = this.left.toJson();
		json.op = Std.string(this.op);
		json.right = this.right.toJson();
		return json;
	}
}
$hxClasses["loreline.NBinary"] = loreline_NBinary;
loreline_NBinary.__name__ = "loreline.NBinary";
loreline_NBinary.__super__ = loreline_NExpr;
Object.assign(loreline_NBinary.prototype, {
	__class__: loreline_NBinary
});
class loreline_NUnary extends loreline_NExpr {
	constructor(id,pos,op,operand,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.op = op;
		this.operand = operand;
	}
	type() {
		return "Unary";
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.operand != null) {
			handleNode(this.operand,this);
			this.operand.each(handleNode);
		}
	}
	toJson() {
		let json = super.toJson();
		json.op = Std.string(this.op);
		json.operand = this.operand.toJson();
		return json;
	}
}
$hxClasses["loreline.NUnary"] = loreline_NUnary;
loreline_NUnary.__name__ = "loreline.NUnary";
loreline_NUnary.__super__ = loreline_NExpr;
Object.assign(loreline_NUnary.prototype, {
	__class__: loreline_NUnary
});
class loreline_NImportStatement extends loreline_AstNode {
	constructor(id,pos,path,script,leadingComments,trailingComments) {
		super(id,pos,leadingComments,trailingComments);
		this.path = path;
		this.script = script;
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.script != null) {
			handleNode(this.script,this);
			this.script.each(handleNode);
		}
	}
	type() {
		return "Import";
	}
	toJson() {
		let json = super.toJson();
		json.path = this.path.toJson();
		return json;
	}
}
$hxClasses["loreline.NImportStatement"] = loreline_NImportStatement;
loreline_NImportStatement.__name__ = "loreline.NImportStatement";
loreline_NImportStatement.__super__ = loreline_AstNode;
Object.assign(loreline_NImportStatement.prototype, {
	__class__: loreline_NImportStatement
});
class loreline_Objects {
	static isFields(value) {
		if(js_Boot.__implements(value,loreline_Fields)) {
			return true;
		} else if(((value) instanceof haxe_ds_StringMap)) {
			return true;
		} else if(((value) instanceof haxe_ds_IntMap)) {
			return false;
		} else if(typeof(value) == "number" && ((value | 0) === value) || typeof(value) == "number" || typeof(value) == "boolean" || typeof(value) == "string") {
			return false;
		} else if(loreline_Arrays.isArray(value)) {
			return false;
		}
		return true;
	}
	static getField(interpreter,fields,name) {
		if(js_Boot.__implements(fields,loreline_Fields)) {
			return fields.lorelineGet(interpreter,name);
		} else if(((fields) instanceof haxe_ds_StringMap)) {
			return fields.h[name];
		} else {
			return Reflect.getProperty(fields,name);
		}
	}
	static getFields(interpreter,fields) {
		if(js_Boot.__implements(fields,loreline_Fields)) {
			return fields.lorelineFields(interpreter);
		} else if(((fields) instanceof haxe_ds_StringMap)) {
			let _g = [];
			let h = fields.h;
			let _g_h = h;
			let _g_keys = Object.keys(h);
			let _g_length = _g_keys.length;
			let _g_current = 0;
			while(_g_current < _g_length) {
				let key = _g_keys[_g_current++];
				_g.push(key);
			}
			return _g;
		} else {
			return Reflect.fields(fields);
		}
	}
	static setField(interpreter,fields,name,value) {
		if(js_Boot.__implements(fields,loreline_Fields)) {
			fields.lorelineSet(interpreter,name,value);
		} else if(((fields) instanceof haxe_ds_StringMap)) {
			fields.h[name] = value;
		} else {
			Reflect.setProperty(fields,name,value);
		}
	}
	static fieldExists(interpreter,fields,name) {
		if(js_Boot.__implements(fields,loreline_Fields)) {
			return fields.lorelineExists(interpreter,name);
		} else if(((fields) instanceof haxe_ds_StringMap)) {
			return Object.prototype.hasOwnProperty.call(fields.h,name);
		} else {
			return Object.prototype.hasOwnProperty.call(fields,name);
		}
	}
	static getStringHelper(interpreter,name) {
		return interpreter.stringHelpers.h[name];
	}
	static getArrayHelper(interpreter,name) {
		return interpreter.arrayHelpers.h[name];
	}
	static getMapHelper(interpreter,name) {
		return interpreter.mapHelpers.h[name];
	}
	static createFields(interpreter,type,node) {
		if(interpreter != null && interpreter.customCreateFields != null) {
			let customInstance = interpreter.customCreateFields(interpreter,type,node);
			if(customInstance != null) {
				return customInstance;
			}
		}
		if(type != null) {
			let instance = Object.create($hxClasses[type].prototype);
			if(js_Boot.__implements(instance,loreline_Fields)) {
				let fields = instance;
				fields.lorelineCreate(interpreter);
			}
			return instance;
		}
		return new haxe_ds_StringMap();
	}
}
$hxClasses["loreline.Objects"] = loreline_Objects;
loreline_Objects.__name__ = "loreline.Objects";
class loreline_ParseError extends loreline_Error {
	constructor(message,pos) {
		super(message,pos);
	}
}
$hxClasses["loreline.ParseError"] = loreline_ParseError;
loreline_ParseError.__name__ = "loreline.ParseError";
loreline_ParseError.__super__ = loreline_Error;
Object.assign(loreline_ParseError.prototype, {
	__class__: loreline_ParseError
});
class loreline_ParserContext {
	constructor(rootPath,path,imports,imported) {
		this.imported = new haxe_ds_StringMap();
		this.rootPath = rootPath;
		this.path = path;
		this.imports = imports;
		if(imported != null) {
			this.imported = imported;
		}
	}
}
$hxClasses["loreline.ParserContext"] = loreline_ParserContext;
loreline_ParserContext.__name__ = "loreline.ParserContext";
Object.assign(loreline_ParserContext.prototype, {
	__class__: loreline_ParserContext
});
class loreline_Parser {
	constructor(tokens,context) {
		this.tokens = tokens;
		this.current = 0;
		this.errors = null;
		this.pendingComments = null;
		this.lastTokenEnd = new loreline_Position(1,1,0);
		this.lastLineBreak = null;
		this.lineBreakAfterToken = false;
		this.currentNodeId = loreline_NodeId.UNDEFINED;
		this.rootBeat = null;
		this.context = context;
	}
	parse() {
		let startPos = this.currentPos();
		let nodes = [];
		let script = new loreline_Script(this.nextNodeId(4),startPos,nodes);
		while(!this.isAtEnd()) try {
			let node = this.parseNode(true);
			if(node != null) {
				nodes.push(node);
			}
			while(this.match(loreline_TokenType.LineBreak)) {
			}
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof loreline_ParseError)) {
				let e = _g1;
				this.addError(e);
				this.synchronize();
			} else {
				throw _g;
			}
		}
		this.attachComments(script);
		return script;
	}
	getErrors() {
		if(this.errors == null) {
			this.errors = [];
		}
		return this.errors;
	}
	nextNodeId(step) {
		let tmp;
		switch(step) {
		case 1:
			tmp = this.currentNodeId.nextSection();
			break;
		case 2:
			tmp = this.currentNodeId.nextBranch();
			break;
		case 3:
			tmp = this.currentNodeId.nextBlock();
			break;
		case 4:
			tmp = this.currentNodeId.nextNode();
			break;
		}
		this.currentNodeId = tmp;
		return this.currentNodeId;
	}
	peek() {
		let i = this.current + 1;
		while(i < this.tokens.length) {
			let _g = this.tokens[i].type;
			switch(_g._hx_index) {
			case 43:
				let _g1 = _g.content;
				++i;
				break;
			case 44:
				let _g2 = _g.content;
				++i;
				break;
			case 45:
				let _g3 = _g.content;
				++i;
				break;
			case 48:
				++i;
				break;
			default:
				return this.tokens[i];
			}
		}
		return this.tokens[this.tokens.length - 1];
	}
	advance(advanceLineBreaks) {
		if(advanceLineBreaks == null) {
			advanceLineBreaks = true;
		}
		let prev = this.tokens[this.current];
		if(!this.isAtEnd()) {
			this.lastTokenEnd = prev.pos;
			this.lineBreakAfterToken = false;
			while(!this.isAtEnd() && this.tokens[this.current + 1] != null && (this.isComment(this.tokens[this.current + 1].type) || advanceLineBreaks && this.tokens[this.current + 1].type == loreline_TokenType.LineBreak)) {
				this.current++;
				let _g = this.tokens[this.current].type;
				switch(_g._hx_index) {
				case 43:
					let content = _g.content;
					if(this.pendingComments == null) {
						this.pendingComments = [];
					}
					this.pendingComments.push(new loreline_Comment(this.nextNodeId(4),this.currentPos(),content,false));
					break;
				case 44:
					let content1 = _g.content;
					if(this.pendingComments == null) {
						this.pendingComments = [];
					}
					this.pendingComments.push(new loreline_Comment(this.nextNodeId(4),this.currentPos(),content1,true));
					break;
				case 45:
					let content2 = _g.content;
					if(this.pendingComments == null) {
						this.pendingComments = [];
					}
					this.pendingComments.push(new loreline_Comment(this.nextNodeId(4),this.currentPos(),content2,false,true));
					break;
				case 48:
					this.lastLineBreak = this.currentPos();
					this.lineBreakAfterToken = true;
					break;
				default:
				}
			}
			this.current++;
		}
		return prev;
	}
	previous() {
		return this.tokens[this.current - 1];
	}
	prevWithType(type) {
		let n = this.current - 1;
		while(n >= 0) {
			if(loreline_TokenTypeHelpers.equals(this.tokens[n].type,type)) {
				return this.tokens[n];
			}
			--n;
		}
		return null;
	}
	prevIdentifier() {
		let n = this.current - 1;
		while(n >= 0) {
			let _g = this.tokens[n].type;
			if(_g._hx_index == 13) {
				let _g1 = _g.name;
				return this.tokens[n];
			}
			--n;
		}
		return null;
	}
	prevNonWhitespaceOrComment() {
		let n = this.current - 1;
		while(n >= 0) {
			let _g = this.tokens[n].type;
			switch(_g._hx_index) {
			case 43:
				let _g1 = _g.content;
				break;
			case 44:
				let _g2 = _g.content;
				break;
			case 45:
				let _g3 = _g.content;
				break;
			case 46:case 47:case 48:
				break;
			default:
				return this.tokens[n];
			}
			--n;
		}
		return null;
	}
	nextNonWhitespaceOrComment() {
		let n = this.current;
		while(n < this.tokens.length) {
			let _g = this.tokens[n].type;
			switch(_g._hx_index) {
			case 43:
				let _g1 = _g.content;
				break;
			case 44:
				let _g2 = _g.content;
				break;
			case 45:
				let _g3 = _g.content;
				break;
			case 46:case 47:case 48:
				break;
			default:
				return this.tokens[n];
			}
			++n;
		}
		return null;
	}
	nextNonLineBreakOrComment() {
		let n = this.current;
		while(n < this.tokens.length) {
			let _g = this.tokens[n].type;
			switch(_g._hx_index) {
			case 43:
				let _g1 = _g.content;
				break;
			case 44:
				let _g2 = _g.content;
				break;
			case 45:
				let _g3 = _g.content;
				break;
			case 48:
				break;
			default:
				return this.tokens[n];
			}
			++n;
		}
		return null;
	}
	currentPos() {
		let tmp = this.tokens[this.current];
		let tmp1 = tmp != null ? tmp.pos : null;
		if(tmp1 != null) {
			return tmp1;
		} else {
			return new loreline_Position(1,1,0,0);
		}
	}
	currentTokenTypeToString() {
		if(this.tokens != null && this.current >= 0) {
			let token = this.tokens[this.current];
			let tmp = token != null ? token.type : null;
			if(tmp != null) {
				return loreline_TokenTypeHelpers.toCodeString(tmp);
			} else {
				return null;
			}
		}
		return null;
	}
	check(type) {
		if(this.isAtEnd()) {
			return false;
		}
		if(type._hx_index == 34) {
			return this.tokens[this.current].type == loreline_TokenType.Colon;
		} else {
			return loreline_TokenTypeHelpers.equals(this.tokens[this.current].type,type);
		}
	}
	checkString() {
		let _g = this.tokens[this.current].type;
		if(_g._hx_index == 9) {
			let _g1 = _g.attachments;
			let s = _g.quotes;
			let attachments = _g.s;
			return true;
		} else {
			return false;
		}
	}
	isAtEnd() {
		if(this.current < this.tokens.length) {
			return this.tokens[this.current].type == loreline_TokenType.Eof;
		} else {
			return true;
		}
	}
	isComment(type) {
		switch(type._hx_index) {
		case 43:
			let _g = type.content;
			return true;
		case 44:
			let _g1 = type.content;
			return true;
		case 45:
			let _g2 = type.content;
			return true;
		default:
			return false;
		}
	}
	parseNode(topLevel) {
		if(topLevel == null) {
			topLevel = false;
		}
		while(this.isComment(this.tokens[this.current].type) || this.tokens[this.current].type == loreline_TokenType.LineBreak) {
			if(this.isComment(this.tokens[this.current].type)) {
				if(this.pendingComments == null) {
					this.pendingComments = [];
				}
				let tmp = this.pendingComments;
				let tmp1 = this.nextNodeId(4);
				let tmp2 = this.currentPos();
				let _g = this.tokens[this.current].type;
				let tmp3;
				switch(_g._hx_index) {
				case 43:
					let content = _g.content;
					tmp3 = content;
					break;
				case 44:
					let content1 = _g.content;
					tmp3 = content1;
					break;
				case 45:
					let content2 = _g.content;
					tmp3 = content2;
					break;
				default:
					tmp3 = "";
				}
				let _g1 = this.tokens[this.current].type;
				let tmp4;
				if(_g1._hx_index == 44) {
					let _g = _g1.content;
					tmp4 = true;
				} else {
					tmp4 = false;
				}
				let _g2 = this.tokens[this.current].type;
				let tmp5;
				if(_g2._hx_index == 45) {
					let _g = _g2.content;
					tmp5 = true;
				} else {
					tmp5 = false;
				}
				tmp.push(new loreline_Comment(tmp1,tmp2,tmp3,tmp4,tmp5));
			}
			this.advance();
			if(this.isAtEnd()) {
				throw haxe_Exception.thrown(new loreline_ParseError("Unexpected end of file",this.currentPos()));
			}
		}
		if(this.isAtEnd()) {
			throw haxe_Exception.thrown(new loreline_ParseError("Unexpected end of file",this.currentPos()));
		}
		let _gthis = this;
		let _g = this.tokens[this.current].type;
		switch(_g._hx_index) {
		case 0:
			return this.parseImport();
		case 1:
			return this.parseStateDecl(false);
		case 2:
			return this.parseBeatDecl();
		case 3:
			if(topLevel) {
				return this.parseCharacterDecl();
			} else {
				this.addError(new loreline_ParseError("Unexpected: " + this.currentTokenTypeToString(),this.currentPos()));
				this.advance();
				return new loreline_NLiteral(this.nextNodeId(4),this.currentPos(),null,loreline_LiteralType.Null);
			}
			break;
		case 4:
			let node = this.parseChoiceStatement();
			if(topLevel) {
				return _gthis.wrapInRootBeat(node);
			} else {
				return node;
			}
			break;
		case 5:
			let node1 = this.parseIfStatement();
			if(topLevel) {
				return _gthis.wrapInRootBeat(node1);
			} else {
				return node1;
			}
			break;
		case 7:
			this.advance();
			if(!this.check(loreline_TokenType.KwState)) {
				throw haxe_Exception.thrown(new loreline_ParseError("Expected 'state' after 'new'",this.currentPos()));
			}
			let node2 = this.parseStateDecl(true);
			if(topLevel) {
				return _gthis.wrapInRootBeat(node2);
			} else {
				return node2;
			}
			break;
		case 8:
			let _g1 = _g.name;
			let _g2 = _g.args;
			let _g3 = _g.code;
			let _g4 = _g.external;
			if(topLevel) {
				return this.parseFunction();
			} else {
				this.addError(new loreline_ParseError("Unexpected: " + this.currentTokenTypeToString(),this.currentPos()));
				this.advance();
				return new loreline_NLiteral(this.nextNodeId(4),this.currentPos(),null,loreline_LiteralType.Null);
			}
			break;
		case 9:
			let _g5 = _g.quotes;
			let _g6 = _g.s;
			let _g7 = _g.attachments;
			let node3 = this.parseTextStatement();
			if(topLevel) {
				return _gthis.wrapInRootBeat(node3);
			} else {
				return node3;
			}
			break;
		case 10:
			let _g8 = _g.n;
			let node4 = this.parseExpressionStatement();
			if(topLevel) {
				return _gthis.wrapInRootBeat(node4);
			} else {
				return node4;
			}
			break;
		case 11:
			let _g9 = _g.b;
			let node5 = this.parseExpressionStatement();
			if(topLevel) {
				return _gthis.wrapInRootBeat(node5);
			} else {
				return node5;
			}
			break;
		case 13:
			let _g10 = _g.name;
			if(this.peek().type == loreline_TokenType.Colon) {
				let node = this.parseDialogueStatement();
				if(topLevel) {
					return _gthis.wrapInRootBeat(node);
				} else {
					return node;
				}
			} else {
				let node = this.parseExpressionStatement();
				if(topLevel) {
					return _gthis.wrapInRootBeat(node);
				} else {
					return node;
				}
			}
			break;
		case 19:
			let node6 = this.parseInsertion();
			if(topLevel) {
				return _gthis.wrapInRootBeat(node6);
			} else {
				return node6;
			}
			break;
		case 12:case 20:case 32:case 37:case 39:case 41:
			let node7 = this.parseExpressionStatement();
			if(topLevel) {
				return _gthis.wrapInRootBeat(node7);
			} else {
				return node7;
			}
			break;
		case 33:
			let node8 = this.parseTransition();
			if(topLevel) {
				return _gthis.wrapInRootBeat(node8);
			} else {
				return node8;
			}
			break;
		default:
			this.addError(new loreline_ParseError("Unexpected: " + this.currentTokenTypeToString(),this.currentPos()));
			this.advance();
			return new loreline_NLiteral(this.nextNodeId(4),this.currentPos(),null,loreline_LiteralType.Null);
		}
	}
	wrapInRootBeat(node) {
		let body;
		let result = null;
		if(this.rootBeat == null) {
			let startPos = this.currentPos();
			body = [];
			this.rootBeat = new loreline_NBeatDecl(this.nextNodeId(1),startPos,"_",body);
			result = this.rootBeat;
		} else {
			body = this.rootBeat.body;
		}
		body.push(node);
		return result;
	}
	parseImport() {
		let startPos = this.currentPos();
		this.expect(loreline_TokenType.KwImport);
		if(this.context == null) {
			throw haxe_Exception.thrown(new loreline_ParseError("Cannot import without a context",this.currentPos()));
		}
		let quotes = 0;
		let pathToken = this.tokens[this.current];
		let rawImportPath;
		let _g = pathToken.type;
		if(_g._hx_index == 9) {
			let _g1 = _g.attachments;
			let q = _g.quotes;
			let s = _g.s;
			quotes = q;
			rawImportPath = s;
		} else {
			throw haxe_Exception.thrown(new loreline_ParseError("Expected string literal for import path",this.currentPos()));
		}
		let importPath = rawImportPath;
		if(!haxe_io_Path.isAbsolute(importPath)) {
			importPath = haxe_io_Path.join([haxe_io_Path.directory(this.context.rootPath),importPath]);
		}
		importPath = haxe_io_Path.normalize(importPath);
		let ext = ".lor";
		if(this.context.rootPath.endsWith(".lor.txt")) {
			ext = ".lor.txt";
		}
		if(!importPath.toLowerCase().endsWith(ext)) {
			importPath += ext;
		}
		if(Object.prototype.hasOwnProperty.call(this.context.imported.h,importPath)) {
			this.advance();
			let node = new loreline_NImportStatement(this.nextNodeId(1),startPos.extendedTo(this.prevNonWhitespaceOrComment().pos),null,null);
			node.path = new loreline_NStringLiteral(this.nextNodeId(4),pathToken.pos,quotes,[new loreline_NStringPart(this.nextNodeId(4),pathToken.pos,loreline_StringPartType.Raw(rawImportPath))]);
			return this.attachComments(node);
		}
		let importedTokens = this.context.imports.h[importPath];
		if(importedTokens == null) {
			throw haxe_Exception.thrown(new loreline_ParseError("Failed to import file at path " + importPath + " (" + rawImportPath + ")",this.currentPos()));
		}
		let tempParser = new loreline_Parser(importedTokens,new loreline_ParserContext(this.context.rootPath,importPath,this.context.imports,this.context.imported));
		tempParser.currentNodeId = this.currentNodeId;
		let importedScript = tempParser.parse();
		this.currentNodeId = tempParser.currentNodeId;
		this.advance();
		let node = new loreline_NImportStatement(this.nextNodeId(1),startPos.extendedTo(this.prevNonWhitespaceOrComment().pos),null,importedScript);
		node.path = new loreline_NStringLiteral(this.nextNodeId(4),pathToken.pos,quotes,[new loreline_NStringPart(this.nextNodeId(4),pathToken.pos,loreline_StringPartType.Raw(rawImportPath))]);
		return this.attachComments(node);
	}
	parseDialogueStatement() {
		let startPos = this.currentPos();
		let dialogue = new loreline_NDialogueStatement(this.nextNodeId(4),startPos,null,null,null);
		let _g = this.tokens[this.current].type;
		let tmp;
		if(_g._hx_index == 13) {
			let name = _g.name;
			tmp = name;
		} else {
			throw haxe_Exception.thrown(new loreline_ParseError("Expected character name",this.currentPos()));
		}
		dialogue.character = tmp;
		dialogue.characterPos = this.tokens[this.current].pos;
		this.advance();
		this.expect(loreline_TokenType.Colon);
		this.attachComments(dialogue);
		let indented = false;
		if(this.checkBlockStart()) {
			let blockToken = this.parseBlockStart();
			if(blockToken.type != loreline_TokenType.Indent) {
				throw haxe_Exception.thrown(new loreline_ParseError("Expected indent, got " + loreline_TokenTypeHelpers.toCodeString(blockToken.type),blockToken.pos));
			}
			indented = true;
		}
		try {
			dialogue.content = this.parseStringLiteral();
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof loreline_ParseError)) {
				let e = _g1;
				this.addError(e);
				dialogue.content = new loreline_NStringLiteral(this.nextNodeId(4),this.currentPos(),0,[new loreline_NStringPart(this.nextNodeId(4),this.currentPos(),loreline_StringPartType.Raw("?"))]);
			} else {
				throw _g;
			}
		}
		if(indented) {
			while(this.match(loreline_TokenType.LineBreak)) {
			}
			this.expect(loreline_TokenType.Unindent);
		}
		dialogue.pos = dialogue.pos.extendedTo(dialogue.content.pos);
		return dialogue;
	}
	parseStatementBlock(statements) {
		let blockEnd = this.parseBlockStart().type == loreline_TokenType.Indent ? loreline_TokenType.Unindent : loreline_TokenType.RBrace;
		while(!this.check(blockEnd) && !this.isAtEnd()) {
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
			}
			if(this.check(blockEnd)) {
				break;
			}
			try {
				statements.push(this.parseNode());
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g).unwrap();
				if(((_g1) instanceof loreline_ParseError)) {
					let e = _g1;
					if(this.errors == null) {
						this.errors = [];
					}
					this.errors.push(e);
					this.synchronize();
					if(this.check(blockEnd)) {
						break;
					}
				} else {
					throw _g;
				}
			}
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
			}
		}
		this.expect(blockEnd);
		if(blockEnd == loreline_TokenType.RBrace) {
			return 1;
		} else {
			return 0;
		}
	}
	parseStateDecl(temporary) {
		let startPos = this.currentPos();
		let stateNode = new loreline_NStateDecl(this.nextNodeId(3),startPos,temporary,[]);
		this.expect(loreline_TokenType.KwState);
		let blockEnd = this.parseBlockStart().type == loreline_TokenType.Indent ? loreline_TokenType.Unindent : loreline_TokenType.RBrace;
		stateNode.style = blockEnd == loreline_TokenType.RBrace ? 1 : 0;
		this.attachComments(stateNode);
		while(!this.check(blockEnd) && !this.isAtEnd()) {
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
			}
			stateNode.fields.push(this.parseObjectField());
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
			}
		}
		while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
		}
		this.expect(blockEnd);
		stateNode.pos = stateNode.pos.extendedTo(this.prevNonWhitespaceOrComment().pos);
		return stateNode;
	}
	parseObjectField() {
		let startPos = this.currentPos();
		let name = this.expectIdentifier();
		let objectField = new loreline_NObjectField(this.nextNodeId(3),startPos,name,null);
		this.expect(loreline_TokenType.Colon);
		this.attachComments(objectField);
		if(this.checkBlockStart()) {
			objectField.value = this.parseObjectLiteral();
		} else {
			objectField.value = this.parseExpression();
		}
		objectField.pos = objectField.pos.extendedTo(this.prevNonWhitespaceOrComment().pos);
		return objectField;
	}
	parseBeatDecl() {
		let startPos = this.currentPos();
		let beatNode = new loreline_NBeatDecl(this.nextNodeId(1),startPos,null,[],[]);
		this.expect(loreline_TokenType.KwBeat);
		beatNode.pos = startPos.extendedTo(this.currentPos());
		beatNode.name = this.expectIdentifier();
		let blockStart = this.parseBlockStart();
		let blockEnd = blockStart.type == loreline_TokenType.Indent ? loreline_TokenType.Unindent : loreline_TokenType.RBrace;
		beatNode.style = blockEnd == loreline_TokenType.RBrace ? 1 : 0;
		this.attachComments(beatNode);
		while(!this.check(blockEnd) && !this.isAtEnd()) {
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
			}
			beatNode.body.push(this.parseNode());
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
			}
		}
		while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
		}
		this.expect(blockEnd);
		beatNode.pos = beatNode.pos.extendedTo(this.prevNonWhitespaceOrComment().pos);
		return beatNode;
	}
	checkBlockStart() {
		let indentToken = null;
		let braceToken = null;
		let numIndents = 0;
		let i = 0;
		while(this.current + i < this.tokens.length) {
			let token = this.tokens[this.current + i];
			++i;
			if(token.type == loreline_TokenType.LineBreak) {
				continue;
			}
			if(token.type == loreline_TokenType.Indent) {
				++numIndents;
				indentToken = token;
				continue;
			}
			if(token.type == loreline_TokenType.LBrace) {
				if(braceToken == null) {
					braceToken = token;
				}
				continue;
			}
			break;
		}
		if(braceToken != null) {
			return true;
		} else if(indentToken != null) {
			if(numIndents > 1) {
				throw haxe_Exception.thrown(new loreline_ParseError("Invalid indentation level",indentToken.pos));
			}
			return true;
		} else {
			return false;
		}
	}
	parseBlockStart() {
		let indentToken = null;
		let braceToken = null;
		let numIndents = 0;
		while(!this.isAtEnd()) {
			if(this.match(loreline_TokenType.LineBreak)) {
				continue;
			}
			if(this.match(loreline_TokenType.Indent)) {
				++numIndents;
				indentToken = this.prevWithType(loreline_TokenType.Indent);
				continue;
			}
			if(this.match(loreline_TokenType.LBrace)) {
				if(braceToken == null) {
					braceToken = this.prevWithType(loreline_TokenType.LBrace);
				}
				continue;
			}
			break;
		}
		if(braceToken != null) {
			return braceToken;
		} else if(indentToken != null) {
			if(numIndents > 1) {
				throw haxe_Exception.thrown(new loreline_ParseError("Invalid indentation level",indentToken.pos));
			}
			return indentToken;
		} else {
			this.addError(new loreline_ParseError("Expected " + loreline_TokenTypeHelpers.toCodeString(loreline_TokenType.LBrace) + " or " + loreline_TokenTypeHelpers.toCodeString(loreline_TokenType.Indent) + ", got " + this.currentTokenTypeToString(),this.currentPos()));
			return new loreline_Token(loreline_TokenType.Indent,this.currentPos());
		}
	}
	parseCharacterDecl() {
		let startPos = this.currentPos();
		let characterNode = new loreline_NCharacterDecl(this.nextNodeId(3),startPos,null,null,[]);
		this.expect(loreline_TokenType.KwCharacter);
		characterNode.name = this.expectIdentifier();
		characterNode.namePos = this.prevNonWhitespaceOrComment().pos;
		let blockEnd = this.parseBlockStart().type == loreline_TokenType.Indent ? loreline_TokenType.Unindent : loreline_TokenType.RBrace;
		characterNode.style = blockEnd == loreline_TokenType.RBrace ? 1 : 0;
		this.attachComments(characterNode);
		while(!this.check(blockEnd) && !this.isAtEnd()) {
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
			}
			characterNode.fields.push(this.parseObjectField());
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
			}
		}
		while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
		}
		this.expect(blockEnd);
		characterNode.pos = characterNode.pos.extendedTo(this.prevNonWhitespaceOrComment().pos);
		return characterNode;
	}
	parseTextStatement() {
		let startPos = this.currentPos();
		let statement = this.attachComments(new loreline_NTextStatement(this.nextNodeId(4),startPos,null));
		statement.content = this.parseStringLiteral();
		return statement;
	}
	parseChoiceStatement() {
		let startPos = this.currentPos();
		let choiceNode = new loreline_NChoiceStatement(this.nextNodeId(2),startPos,[]);
		this.expect(loreline_TokenType.KwChoice);
		let blockEnd = this.parseBlockStart().type == loreline_TokenType.Indent ? loreline_TokenType.Unindent : loreline_TokenType.RBrace;
		choiceNode.style = blockEnd == loreline_TokenType.RBrace ? 1 : 0;
		this.attachComments(choiceNode);
		while(!this.check(blockEnd) && !this.isAtEnd()) {
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
			}
			choiceNode.options.push(this.parseChoiceOption(blockEnd));
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
			}
		}
		this.expect(blockEnd);
		choiceNode.pos = choiceNode.pos.extendedTo(this.prevNonWhitespaceOrComment().pos);
		return choiceNode;
	}
	parseChoiceOption(blockEnd) {
		let startPos = this.currentPos();
		let choiceOption = this.attachComments(new loreline_NChoiceOption(this.nextNodeId(3),startPos,null,null,null,0,[]));
		let errorPos = null;
		let isInsertion = false;
		try {
			if(this.check(loreline_TokenType.OpPlus)) {
				isInsertion = true;
				choiceOption.insertion = this.parseInsertion();
			} else {
				choiceOption.text = this.parseStringLiteral();
			}
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof loreline_ParseError)) {
				let e = _g1;
				this.addError(e);
				errorPos = this.currentPos();
				if(this.currentPos().offset == startPos.offset) {
					this.advance();
				}
				choiceOption.text = new loreline_NStringLiteral(this.nextNodeId(4),this.currentPos(),0,[new loreline_NStringPart(this.nextNodeId(4),this.currentPos(),loreline_StringPartType.Raw("?"))]);
			} else {
				throw _g;
			}
		}
		if(!isInsertion) {
			if(this.match(loreline_TokenType.KwIf)) {
				let offset = this.currentPos().offset;
				try {
					if(this.check(loreline_TokenType.LParen)) {
						choiceOption.conditionStyle = 2;
					}
					choiceOption.condition = this.parseConditionExpression();
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g).unwrap();
					if(((_g1) instanceof loreline_ParseError)) {
						let e = _g1;
						this.addError(e);
						errorPos = this.currentPos();
						if(this.currentPos().offset == offset) {
							this.advance();
						}
					} else {
						throw _g;
					}
				}
			}
			if(this.checkBlockStart()) {
				choiceOption.body = [];
				let offset = this.currentPos().offset;
				try {
					choiceOption.style = this.parseStatementBlock(choiceOption.body);
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g).unwrap();
					if(((_g1) instanceof loreline_ParseError)) {
						let e = _g1;
						this.addError(e);
						errorPos = this.currentPos();
						if(this.currentPos().offset == offset) {
							this.advance();
						}
						if(choiceOption.body.length == 0) {
							choiceOption.body = [new loreline_NLiteral(this.nextNodeId(4),this.currentPos(),null,loreline_LiteralType.Null)];
						}
					} else {
						throw _g;
					}
				}
			} else if(this.check(loreline_TokenType.Arrow)) {
				let offset = this.currentPos().offset;
				try {
					choiceOption.body = [];
					choiceOption.body.push(this.parseNode());
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g).unwrap();
					if(((_g1) instanceof loreline_ParseError)) {
						let e = _g1;
						this.addError(e);
						errorPos = this.currentPos();
						if(this.currentPos().offset == offset) {
							this.advance();
						}
						if(choiceOption.body.length == 0) {
							choiceOption.body = [new loreline_NLiteral(this.nextNodeId(4),this.currentPos(),null,loreline_LiteralType.Null)];
						}
					} else {
						throw _g;
					}
				}
				choiceOption.style = 0;
			}
		}
		choiceOption.pos = choiceOption.pos.extendedTo(this.prevNonWhitespaceOrComment().pos);
		if(errorPos != null) {
			while(!this.isAtEnd() && this.currentPos().line <= errorPos.line + 1) this.advance();
		}
		return choiceOption;
	}
	isExpressionStart() {
		let _g = this.tokens[this.current].type;
		switch(_g._hx_index) {
		case 9:
			let _g1 = _g.quotes;
			let _g2 = _g.s;
			let _g3 = _g.attachments;
			return true;
		case 10:
			let _g4 = _g.n;
			return true;
		case 11:
			let _g5 = _g.b;
			return true;
		case 13:
			let _g6 = _g.name;
			if(this.peek().type == loreline_TokenType.Colon) {
				return false;
			} else {
				return true;
			}
			break;
		case 12:case 20:case 32:case 37:case 39:case 41:
			return true;
		default:
			return false;
		}
	}
	parseExpressionStatement() {
		let expr = this.parseExpression();
		if(this.match(loreline_TokenType.OpAssign) || this.match(loreline_TokenType.OpPlusAssign) || this.match(loreline_TokenType.OpMinusAssign) || this.match(loreline_TokenType.OpMultiplyAssign) || this.match(loreline_TokenType.OpDivideAssign)) {
			let op = this.previous().type;
			let assignment = this.attachComments(new loreline_NAssign(this.nextNodeId(4),expr.pos,expr,op,null));
			assignment.value = this.parseExpression();
			assignment.pos = assignment.pos.extendedTo(assignment.value.pos);
			return assignment;
		}
		return this.attachComments(expr);
	}
	isKnownNodeStart() {
		let _g = this.tokens[this.current].type;
		switch(_g._hx_index) {
		case 9:
			let _g1 = _g.quotes;
			let _g2 = _g.s;
			let _g3 = _g.attachments;
			return true;
		case 13:
			let _g4 = _g.name;
			if(this.peek().type == loreline_TokenType.Colon) {
				return true;
			} else if(this.peek().type == loreline_TokenType.Arrow) {
				return true;
			} else {
				return false;
			}
			break;
		case 1:case 2:case 3:case 4:case 5:case 33:
			return true;
		default:
			return false;
		}
	}
	parseIfStatement() {
		let startPos = this.currentPos();
		let ifNode = new loreline_NIfStatement(this.nextNodeId(4),startPos,null,0,null,null);
		this.expect(loreline_TokenType.KwIf);
		if(this.check(loreline_TokenType.LParen)) {
			ifNode.conditionStyle = 2;
		}
		ifNode.condition = this.parseConditionExpression();
		while(this.match(loreline_TokenType.LineBreak)) {
		}
		this.attachComments(ifNode);
		ifNode.thenBranch = new loreline_NBlock(this.nextNodeId(3),this.currentPos(),null);
		ifNode.thenBranch.body = [];
		ifNode.thenBranch.style = this.parseStatementBlock(ifNode.thenBranch.body);
		let elseToken = this.tokens[this.current];
		if(elseToken != null && elseToken.type == loreline_TokenType.KwElse) {
			this.advance();
			while(this.match(loreline_TokenType.LineBreak)) {
			}
			this.attachElseComments(ifNode,elseToken);
			if(this.check(loreline_TokenType.KwIf)) {
				ifNode.elseBranch = new loreline_NBlock(this.nextNodeId(3),this.currentPos(),null);
				let tmp = this.parseIfStatement();
				ifNode.elseBranch.body = [tmp];
				ifNode.elseBranch.style = 0;
			} else {
				ifNode.elseBranch = new loreline_NBlock(this.nextNodeId(3),this.currentPos(),null);
				ifNode.elseBranch.body = [];
				ifNode.elseBranch.style = this.parseStatementBlock(ifNode.elseBranch.body);
			}
		}
		ifNode.pos = ifNode.pos.extendedTo(this.prevNonWhitespaceOrComment().pos);
		return ifNode;
	}
	parseTransition() {
		let startPos = this.currentPos();
		this.expect(loreline_TokenType.Arrow);
		if(this.match(loreline_TokenType.Dot)) {
			return this.attachComments(new loreline_NTransition(this.nextNodeId(4),startPos.extendedTo(this.prevNonWhitespaceOrComment().pos),".",this.prevNonWhitespaceOrComment().pos));
		}
		let target = this.expectIdentifier();
		return this.attachComments(new loreline_NTransition(this.nextNodeId(4),startPos.extendedTo(this.prevNonWhitespaceOrComment().pos),target,this.prevNonWhitespaceOrComment().pos));
	}
	parseInsertion() {
		let startPos = this.currentPos();
		this.expect(loreline_TokenType.OpPlus);
		let target = this.expectIdentifier();
		return this.attachComments(new loreline_NInsertion(this.nextNodeId(4),startPos.extendedTo(this.prevNonWhitespaceOrComment().pos),target,this.prevNonWhitespaceOrComment().pos));
	}
	parseFunction() {
		let startPos = this.currentPos();
		let _g = this.tokens[this.current].type;
		if(_g._hx_index == 8) {
			let name = _g.name;
			let args = _g.args;
			let code = _g.code;
			let external = _g.external;
			this.advance();
			return this.attachComments(new loreline_NFunctionDecl(this.nextNodeId(3),startPos,name,[].concat(args),code,external));
		} else {
			throw haxe_Exception.thrown(new loreline_ParseError("Unexpected token in expression",this.currentPos()));
		}
	}
	parseExpression() {
		try {
			let expr = this.parseLogicalOr();
			if(this.check(loreline_TokenType.OpAssign) || this.check(loreline_TokenType.OpPlusAssign) || this.check(loreline_TokenType.OpMinusAssign) || this.check(loreline_TokenType.OpMultiplyAssign) || this.check(loreline_TokenType.OpDivideAssign)) {
				let op = this.tokens[this.current].type;
				this.advance();
				let assignment = this.attachComments(new loreline_NAssign(this.nextNodeId(4),expr.pos,expr,op,null));
				assignment.value = this.parseExpression();
				assignment.pos = assignment.pos.extendedTo(assignment.value.pos);
				return assignment;
			}
			return expr;
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			if(((e) instanceof loreline_ParseError)) {
				this.addError(e);
			}
			return new loreline_NLiteral(this.nextNodeId(4),this.currentPos(),null,loreline_LiteralType.Null);
		}
	}
	parseLogicalOr() {
		let expr = this.parseLogicalAnd();
		while(this.match(loreline_TokenType.OpOr(false))) {
			let op = this.previous().type;
			let binary = this.attachComments(new loreline_NBinary(this.nextNodeId(4),expr.pos,expr,op,null));
			binary.right = this.parseLogicalAnd();
			binary.pos = binary.pos.extendedTo(binary.right.pos);
			expr = binary;
		}
		return expr;
	}
	parseLogicalAnd() {
		let expr = this.parseEquality();
		while(this.match(loreline_TokenType.OpAnd(false))) {
			let op = this.previous().type;
			let binary = this.attachComments(new loreline_NBinary(this.nextNodeId(4),expr.pos,expr,op,null));
			binary.right = this.parseEquality();
			binary.pos = binary.pos.extendedTo(binary.right.pos);
			expr = binary;
		}
		return expr;
	}
	parseEquality() {
		let expr = this.parseComparison();
		while(this.match(loreline_TokenType.OpEquals) || this.match(loreline_TokenType.OpNotEquals)) {
			let op = this.previous().type;
			let binary = this.attachComments(new loreline_NBinary(this.nextNodeId(4),expr.pos,expr,op,null));
			binary.right = this.parseComparison();
			binary.pos = binary.pos.extendedTo(binary.right.pos);
			expr = binary;
		}
		return expr;
	}
	parseComparison() {
		let expr = this.parseAdditive();
		while(this.match(loreline_TokenType.OpGreater) || this.match(loreline_TokenType.OpGreaterEq) || this.match(loreline_TokenType.OpLess) || this.match(loreline_TokenType.OpLessEq)) {
			let op = this.previous().type;
			let binary = this.attachComments(new loreline_NBinary(this.nextNodeId(4),expr.pos,expr,op,null));
			binary.right = this.parseAdditive();
			binary.pos = binary.pos.extendedTo(binary.right.pos);
			expr = binary;
		}
		return expr;
	}
	parseAdditive() {
		let expr = this.parseMultiplicative();
		while(this.match(loreline_TokenType.OpPlus) || this.match(loreline_TokenType.OpMinus)) {
			let op = this.previous().type;
			let binary = this.attachComments(new loreline_NBinary(this.nextNodeId(4),expr.pos,expr,op,null));
			binary.right = this.parseMultiplicative();
			binary.pos = binary.pos.extendedTo(binary.right.pos);
			expr = binary;
		}
		return expr;
	}
	parseMultiplicative() {
		let expr = this.parseUnary();
		while(this.match(loreline_TokenType.OpMultiply) || this.match(loreline_TokenType.OpDivide) || this.match(loreline_TokenType.OpModulo)) {
			let op = this.previous().type;
			let binary = this.attachComments(new loreline_NBinary(this.nextNodeId(4),expr.pos,expr,op,null));
			binary.right = this.parseUnary();
			binary.pos = binary.pos.extendedTo(binary.right.pos);
			expr = binary;
		}
		return expr;
	}
	parseUnary() {
		if(this.match(loreline_TokenType.OpNot) || this.match(loreline_TokenType.OpMinus)) {
			let op = this.previous().type;
			let unary = this.attachComments(new loreline_NUnary(this.nextNodeId(4),this.previous().pos,op,null));
			unary.operand = this.parseUnary();
			unary.pos = unary.pos.extendedTo(unary.operand.pos);
			return unary;
		}
		return this.parsePrimary();
	}
	parsePrimary() {
		let startPos = this.currentPos();
		let _g = this.tokens[this.current].type;
		switch(_g._hx_index) {
		case 9:
			let _g1 = _g.quotes;
			let _g2 = _g.s;
			let _g3 = _g.attachments;
			return this.parsePostfix(startPos,this.parseStringLiteral());
		case 10:
			let n = _g.n;
			this.advance();
			return this.attachComments(new loreline_NLiteral(this.nextNodeId(4),startPos,n,loreline_LiteralType.Number));
		case 11:
			let b = _g.b;
			this.advance();
			return this.attachComments(new loreline_NLiteral(this.nextNodeId(4),startPos,b,loreline_LiteralType.Boolean));
		case 12:
			this.advance();
			return this.attachComments(new loreline_NLiteral(this.nextNodeId(4),startPos,null,loreline_LiteralType.Null));
		case 13:
			let name = _g.name;
			if(this.peek().type == loreline_TokenType.Colon) {
				let fields = [this.parseObjectField()];
				return new loreline_NLiteral(this.nextNodeId(4),startPos.extendedTo(this.prevNonWhitespaceOrComment().pos),fields,loreline_LiteralType.Object(0));
			} else {
				this.advance();
				return this.parseIdentifierExpression(startPos,name);
			}
			break;
		case 37:
			return this.parsePostfix(startPos,this.parseObjectLiteral());
		case 39:
			this.advance();
			let expr = this.parseExpression();
			this.expect(loreline_TokenType.RParen);
			return this.parsePostfix(startPos,expr);
		case 41:
			return this.parsePostfix(startPos,this.parseArrayLiteral());
		default:
			throw haxe_Exception.thrown(new loreline_ParseError("Unexpected token in expression",this.currentPos()));
		}
	}
	parseStringLiteral() {
		let stringLiteralPos = this.currentPos();
		let parts = [];
		let _g = this.tokens[this.current].type;
		if(_g._hx_index == 9) {
			let quotes = _g.quotes;
			let content = _g.s;
			let attachments = _g.attachments;
			let startPos = quotes != 0 ? stringLiteralPos.withOffset(content,1,stringLiteralPos.length - 2) : stringLiteralPos;
			let currentPos = 0;
			if(attachments == null || attachments.length == 0) {
				let partPos = this.makeStringPartPosition(startPos,content,0);
				partPos.length = startPos.length;
				let literalId = this.nextNodeId(4);
				let partId = this.nextNodeId(4);
				parts.push(new loreline_NStringPart(partId,partPos,loreline_StringPartType.Raw(content)));
				this.advance();
				return this.attachComments(new loreline_NStringLiteral(literalId,stringLiteralPos,quotes,parts));
			}
			let stringLiteral = this.attachComments(new loreline_NStringLiteral(this.nextNodeId(4),stringLiteralPos,quotes,parts));
			let _g1 = 0;
			let _g2 = attachments.length;
			while(_g1 < _g2) {
				let i = _g1++;
				let _g = attachments[i];
				switch(_g._hx_index) {
				case 0:
					let braces = _g.braces;
					let inTag = _g.inTag;
					let tokens = _g.expr;
					let start = _g.start;
					let length = _g.length;
					if(currentPos >= start + length) {
						continue;
					}
					if(start > currentPos) {
						let partPos = this.makeStringPartPosition(startPos,content,currentPos);
						partPos.length = start - currentPos;
						parts.push(new loreline_NStringPart(this.nextNodeId(4),partPos,loreline_StringPartType.Raw(HxOverrides.substr(content,currentPos,start - currentPos))));
					}
					parts.push(this.parseStringInterpolation(braces,inTag,tokens,start,length,content));
					currentPos = start + length;
					break;
				case 1:
					let closing = _g.closing;
					let start1 = _g.start;
					let length1 = _g.length;
					if(currentPos >= start1 + length1) {
						continue;
					}
					if(start1 > currentPos) {
						let partPos = this.makeStringPartPosition(startPos,content,currentPos);
						partPos.length = start1 - currentPos;
						parts.push(new loreline_NStringPart(this.nextNodeId(4),partPos,loreline_StringPartType.Raw(HxOverrides.substr(content,currentPos,start1 - currentPos))));
					}
					parts.push(this.parseStringTag(closing,start1,length1,content,quotes,attachments));
					currentPos = start1 + length1;
					break;
				}
			}
			if(currentPos < content.length) {
				let partPos = this.makeStringPartPosition(startPos,content,currentPos);
				partPos.length = content.length - currentPos;
				parts.push(new loreline_NStringPart(this.nextNodeId(4),partPos,loreline_StringPartType.Raw(HxOverrides.substr(content,currentPos,null))));
			}
			this.advance();
			if(this.pendingComments != null) {
				let remaining = null;
				let _g = 0;
				let _g1 = this.pendingComments;
				while(_g < _g1.length) {
					let c = _g1[_g];
					++_g;
					if(c.pos.line == stringLiteralPos.line) {
						if(stringLiteral.trailingComments == null) {
							stringLiteral.trailingComments = [];
						}
						stringLiteral.trailingComments.push(c);
					} else {
						if(remaining == null) {
							remaining = [];
						}
						remaining.push(c);
					}
				}
				this.pendingComments = remaining;
			}
			return stringLiteral;
		} else {
			throw haxe_Exception.thrown(new loreline_ParseError("Expected text, got " + this.currentTokenTypeToString(),this.currentPos()));
		}
	}
	makeStringPartPosition(stringStart,content,offset) {
		let line = stringStart.line;
		let column = stringStart.column;
		let _g = 0;
		let _g1 = offset;
		while(_g < _g1) {
			let i = _g++;
			if(HxOverrides.cca(content,i) == 10) {
				++line;
				column = 1;
			} else {
				++column;
			}
		}
		return new loreline_Position(line,column,stringStart.offset + offset);
	}
	makeAccess(pos,target,name,namePos) {
		if(name != null) {
			if(name.length == 0) {
				if(this.errors == null || this.errors.length == 0) {
					this.addError(new loreline_ParseError("Invalid access: " + (name != null ? "'" + name + "'" : "null"),pos));
				}
			}
			if(target != null) {
				if(namePos != null) {
					pos = new loreline_Position(target.pos.line,target.pos.column,target.pos.offset,namePos.offset + name.length - target.pos.offset);
				} else {
					throw haxe_Exception.thrown(new loreline_ParseError("Invalid access (missing name position)",pos));
				}
			} else if(pos.length == 0) {
				let tmp = namePos != null ? namePos.length : null;
				pos = new loreline_Position(pos.line,pos.column,pos.offset,tmp != null ? tmp : name.length);
			}
		}
		return new loreline_NAccess(this.nextNodeId(4),pos,target,name);
	}
	parseStringInterpolation(braces,inTag,tokens,start,length,content) {
		let tmp = tokens[0];
		let tmp1 = tmp != null ? tmp.pos : null;
		let pos = this.makeStringPartPosition(tmp1 != null ? tmp1 : this.currentPos(),content,start);
		pos.length = length;
		if(tokens.length == 0) {
			let tmp = tokens[0];
			let tmp1 = tmp != null ? tmp.pos : null;
			this.addError(new loreline_ParseError("Empty interpolation",tmp1 != null ? tmp1 : this.currentPos()));
			let tmp2 = this.nextNodeId(4);
			let tmp3 = this.nextNodeId(4);
			let tmp4 = tokens[0];
			let tmp5 = tmp4 != null ? tmp4.pos : null;
			return new loreline_NStringPart(tmp2,pos,loreline_StringPartType.Expr(new loreline_NLiteral(tmp3,tmp5 != null ? tmp5 : this.currentPos(),null,loreline_LiteralType.Null)));
		}
		let expr = null;
		if(!braces && tokens.length > 0) {
			let target = null;
			let i = 0;
			let prevIsDot = false;
			while(i < tokens.length) {
				let token = tokens[i];
				++i;
				let _g = token.type;
				switch(_g._hx_index) {
				case 13:
					let name = _g.name;
					if(target == null) {
						target = this.attachComments(this.makeAccess(token.pos,null,name,null));
					} else if(prevIsDot) {
						target = this.attachComments(this.makeAccess(token.pos,target,name,token.pos));
					} else {
						this.addError(new loreline_ParseError("Missing dot in field access",token.pos));
						let tmp = this.nextNodeId(4);
						let tmp1 = this.nextNodeId(4);
						let tmp2 = tokens[0];
						let tmp3 = tmp2 != null ? tmp2.pos : null;
						return new loreline_NStringPart(tmp,pos,loreline_StringPartType.Expr(new loreline_NLiteral(tmp1,tmp3 != null ? tmp3 : this.currentPos(),null,loreline_LiteralType.Null)));
					}
					prevIsDot = false;
					break;
				case 36:
					if(target == null) {
						this.addError(new loreline_ParseError("Leading dot in field access",token.pos));
						let tmp = this.nextNodeId(4);
						let tmp1 = this.nextNodeId(4);
						let tmp2 = tokens[0];
						let tmp3 = tmp2 != null ? tmp2.pos : null;
						return new loreline_NStringPart(tmp,pos,loreline_StringPartType.Expr(new loreline_NLiteral(tmp1,tmp3 != null ? tmp3 : this.currentPos(),null,loreline_LiteralType.Null)));
					}
					prevIsDot = true;
					break;
				case 39:
					if(target == null) {
						this.addError(new loreline_ParseError("Function call without target",token.pos));
						let tmp = this.nextNodeId(4);
						let tmp1 = this.nextNodeId(4);
						let tmp2 = tokens[0];
						let tmp3 = tmp2 != null ? tmp2.pos : null;
						return new loreline_NStringPart(tmp,pos,loreline_StringPartType.Expr(new loreline_NLiteral(tmp1,tmp3 != null ? tmp3 : this.currentPos(),null,loreline_LiteralType.Null)));
					}
					let callStart = token.pos;
					let argTokens = [];
					let currentArgTokens = [];
					let parenLevel = 1;
					while(i < tokens.length && parenLevel > 0) {
						let t = tokens[i];
						++i;
						switch(t.type._hx_index) {
						case 35:
							if(parenLevel == 1) {
								if(currentArgTokens.length > 0) {
									argTokens.push(currentArgTokens);
									currentArgTokens = [];
								}
							} else {
								currentArgTokens.push(t);
							}
							break;
						case 39:
							++parenLevel;
							currentArgTokens.push(t);
							break;
						case 40:
							--parenLevel;
							if(parenLevel > 0) {
								currentArgTokens.push(t);
							} else if(currentArgTokens.length > 0) {
								argTokens.push(currentArgTokens);
							}
							break;
						default:
							currentArgTokens.push(t);
						}
					}
					if(parenLevel > 0) {
						this.addError(new loreline_ParseError("Unterminated function call",callStart));
						let tmp = this.nextNodeId(4);
						let tmp1 = this.nextNodeId(4);
						let tmp2 = tokens[0];
						let tmp3 = tmp2 != null ? tmp2.pos : null;
						return new loreline_NStringPart(tmp,pos,loreline_StringPartType.Expr(new loreline_NLiteral(tmp1,tmp3 != null ? tmp3 : this.currentPos(),null,loreline_LiteralType.Null)));
					}
					let args = [];
					let _g1 = 0;
					while(_g1 < argTokens.length) {
						let argTokenGroup = argTokens[_g1];
						++_g1;
						let tempParser = new loreline_Parser(argTokenGroup);
						tempParser.currentNodeId = this.currentNodeId;
						let arg = tempParser.parseExpression();
						args.push(arg);
						this.currentNodeId = tempParser.currentNodeId;
					}
					target = this.attachComments(new loreline_NCall(this.nextNodeId(4),callStart.extendedTo(tokens[i - 1].pos),target,args));
					prevIsDot = false;
					break;
				case 41:
					if(target == null) {
						this.addError(new loreline_ParseError("Array access without target",token.pos));
						let tmp = this.nextNodeId(4);
						let tmp1 = this.nextNodeId(4);
						let tmp2 = tokens[0];
						let tmp3 = tmp2 != null ? tmp2.pos : null;
						return new loreline_NStringPart(tmp,pos,loreline_StringPartType.Expr(new loreline_NLiteral(tmp1,tmp3 != null ? tmp3 : this.currentPos(),null,loreline_LiteralType.Null)));
					}
					let arrayStart = token.pos;
					let arrayTokens = [];
					let bracketLevel = 1;
					let lastRBracket = null;
					while(i < tokens.length && bracketLevel > 0) {
						let t = tokens[i];
						++i;
						switch(t.type._hx_index) {
						case 41:
							++bracketLevel;
							arrayTokens.push(t);
							break;
						case 42:
							--bracketLevel;
							if(bracketLevel > 0) {
								arrayTokens.push(t);
							}
							lastRBracket = t;
							break;
						default:
							arrayTokens.push(t);
						}
					}
					if(bracketLevel > 0) {
						this.addError(new loreline_ParseError("Unterminated array access",arrayStart));
						let tmp = this.nextNodeId(4);
						let tmp1 = this.nextNodeId(4);
						let tmp2 = tokens[0];
						let tmp3 = tmp2 != null ? tmp2.pos : null;
						return new loreline_NStringPart(tmp,pos,loreline_StringPartType.Expr(new loreline_NLiteral(tmp1,tmp3 != null ? tmp3 : this.currentPos(),null,loreline_LiteralType.Null)));
					}
					let tempParser = new loreline_Parser(arrayTokens);
					tempParser.currentNodeId = this.currentNodeId;
					let indexExpr = tempParser.parseExpression();
					this.currentNodeId = tempParser.currentNodeId;
					let accessPos = pos.extendedTo(tokens[i - 1].pos);
					accessPos.length += 1;
					target = this.attachComments(new loreline_NArrayAccess(this.nextNodeId(4),accessPos,target,indexExpr));
					prevIsDot = false;
					break;
				default:
					this.addError(new loreline_ParseError("Unexpected token in field access: " + loreline_TokenTypeHelpers.toCodeString(token.type),token.pos));
					let tmp = this.nextNodeId(4);
					let tmp1 = this.nextNodeId(4);
					let tmp2 = tokens[0];
					let tmp3 = tmp2 != null ? tmp2.pos : null;
					return new loreline_NStringPart(tmp,pos,loreline_StringPartType.Expr(new loreline_NLiteral(tmp1,tmp3 != null ? tmp3 : this.currentPos(),null,loreline_LiteralType.Null)));
				}
			}
			if(prevIsDot) {
				this.addError(new loreline_ParseError("Trailing dot in field access",tokens[tokens.length - 1].pos));
			}
			expr = target;
		} else {
			let tempParser = new loreline_Parser(tokens);
			tempParser.currentNodeId = this.currentNodeId;
			expr = tempParser.parseExpression();
			this.currentNodeId = tempParser.currentNodeId;
			if(!tempParser.isAtEnd()) {
				this.addError(new loreline_ParseError("Unexpected tokens after interpolation expression",tempParser.tokens[tempParser.current].pos));
			}
		}
		let partPos = new loreline_Position(pos.line,pos.column + (braces ? 1 : 0),pos.offset - (braces ? 2 : 0),length);
		return new loreline_NStringPart(this.nextNodeId(4),partPos,loreline_StringPartType.Expr(expr));
	}
	parseStringTag(closing,start,length,content,quotes,attachments) {
		let strPos = this.currentPos();
		if(quotes != 0) {
			strPos = strPos.withOffset(content,1,strPos.length - 2);
		}
		let pos = this.makeStringPartPosition(strPos,content,start);
		pos.length = length;
		let offsetStart = closing ? 2 : 1;
		let innerStart = start + offsetStart;
		let innerLength = length - (closing ? 3 : 2);
		let innerEnd = innerStart + innerLength;
		let tagId = this.nextNodeId(4);
		let hasAttachmentsInRange = false;
		if(attachments != null) {
			let _g = 0;
			let _g1 = attachments.length;
			_hx_loop1: while(_g < _g1) {
				let i = _g++;
				let _g1 = attachments[i];
				switch(_g1._hx_index) {
				case 0:
					let _g2 = _g1.braces;
					let _g3 = _g1.inTag;
					let _g4 = _g1.expr;
					let aStart = _g1.start;
					let aLength = _g1.length;
					let aEnd = aStart + aLength;
					if(aStart >= innerStart && aEnd <= innerEnd) {
						hasAttachmentsInRange = true;
						break _hx_loop1;
					}
					break;
				case 1:
					let _g5 = _g1.closing;
					let _g6 = _g1.start;
					let _g7 = _g1.length;
					continue;
				}
			}
		}
		if(!hasAttachmentsInRange) {
			let partPos = this.makeStringPartPosition(strPos,content,innerStart);
			partPos.length = innerLength;
			let literalId = this.nextNodeId(4);
			let partId = this.nextNodeId(4);
			return new loreline_NStringPart(tagId,pos,loreline_StringPartType.Tag(closing,this.attachComments(new loreline_NStringLiteral(literalId,partPos,0,[new loreline_NStringPart(partId,partPos,loreline_StringPartType.Raw(HxOverrides.substr(content,innerStart,innerLength)))]))));
		}
		let parts = [];
		let stringLiteral = this.attachComments(new loreline_NStringLiteral(this.nextNodeId(4),pos,0,parts));
		let currentPos = innerStart;
		if(attachments != null) {
			let _g = 0;
			let _g1 = attachments.length;
			while(_g < _g1) {
				let i = _g++;
				let _g1 = attachments[i];
				switch(_g1._hx_index) {
				case 0:
					let _g2 = _g1.inTag;
					let braces = _g1.braces;
					let tokens = _g1.expr;
					let aStart = _g1.start;
					let aLength = _g1.length;
					let aEnd = aStart + aLength;
					if(aStart >= innerStart && aEnd <= innerEnd) {
						if(aStart > currentPos) {
							let partPos = this.makeStringPartPosition(strPos,content,innerStart);
							partPos.length = aStart - innerStart;
							parts.push(new loreline_NStringPart(this.nextNodeId(4),partPos,loreline_StringPartType.Raw(HxOverrides.substr(content,currentPos,aStart - currentPos))));
						}
						let interpPart = this.parseStringInterpolation(braces,true,tokens,aStart,aLength,content);
						interpPart.pos = this.makeStringPartPosition(strPos,content,aStart);
						interpPart.pos.length = aLength;
						parts.push(interpPart);
						currentPos = aEnd;
					}
					break;
				case 1:
					let _g3 = _g1.closing;
					let _g4 = _g1.start;
					let _g5 = _g1.length;
					continue;
				}
			}
		}
		if(currentPos < innerEnd) {
			let partPos = this.makeStringPartPosition(pos,HxOverrides.substr(content,start,null),currentPos - start + offsetStart);
			partPos.length = innerStart + innerEnd - currentPos;
			parts.push(new loreline_NStringPart(this.nextNodeId(4),partPos,loreline_StringPartType.Raw(HxOverrides.substr(content,currentPos,innerEnd - currentPos))));
		}
		return new loreline_NStringPart(tagId,pos,loreline_StringPartType.Tag(closing,stringLiteral));
	}
	parseIdentifierExpression(startPos,name) {
		let expr = this.attachComments(this.makeAccess(startPos,null,name,null));
		return this.parsePostfix(startPos,expr);
	}
	parsePostfix(startPos,expr) {
		while(true) if(this.match(loreline_TokenType.Dot,false)) {
			let prop = null;
			let propPos = this.currentPos();
			if(this.checkIdentifier()) {
				prop = this.expectIdentifier();
			} else {
				this.addError(new loreline_ParseError("Expected identifier after '.'",this.currentPos()));
				prop = "";
			}
			expr = this.attachComments(this.makeAccess(startPos,expr,prop,propPos));
		} else if(this.match(loreline_TokenType.LBracket)) {
			let index = this.parseExpression();
			this.expect(loreline_TokenType.RBracket);
			let accessPos = startPos.extendedTo(this.previous().pos);
			expr = this.attachComments(new loreline_NArrayAccess(this.nextNodeId(4),accessPos,expr,index));
		} else if(this.match(loreline_TokenType.LParen)) {
			let args = this.parseCallArguments();
			expr = this.attachComments(new loreline_NCall(this.nextNodeId(4),startPos.extendedTo(this.previous().pos),expr,args));
		} else {
			break;
		}
		return expr;
	}
	parseArrayLiteral() {
		let startPos = this.currentPos();
		let elements = [];
		let literal = new loreline_NLiteral(this.nextNodeId(4),startPos,elements,loreline_LiteralType.Array);
		this.expect(loreline_TokenType.LBracket);
		this.attachComments(literal);
		let needsSeparator = false;
		while(!this.check(loreline_TokenType.RBracket) && !this.isAtEnd()) {
			if(needsSeparator) {
				while(this.match(loreline_TokenType.LineBreak)) needsSeparator = false;
				if(this.match(loreline_TokenType.Comma)) {
					needsSeparator = false;
				}
			}
			while(this.match(loreline_TokenType.LineBreak) || this.match(loreline_TokenType.Indent) || this.match(loreline_TokenType.Unindent)) needsSeparator = false;
			if(!this.check(loreline_TokenType.RBracket) && needsSeparator) {
				throw haxe_Exception.thrown(new loreline_ParseError("Expected comma or line break between elements",this.currentPos()));
			}
			while(this.match(loreline_TokenType.LineBreak) || this.match(loreline_TokenType.Indent) || this.match(loreline_TokenType.Unindent)) {
			}
			if(!this.check(loreline_TokenType.RBracket)) {
				elements.push(this.parseExpression());
			}
			let prev = this.previous();
			needsSeparator = prev.type != loreline_TokenType.Colon && prev.type != loreline_TokenType.LineBreak;
		}
		while(this.match(loreline_TokenType.LineBreak) || this.match(loreline_TokenType.Indent) || this.match(loreline_TokenType.Unindent)) {
		}
		this.expect(loreline_TokenType.RBracket);
		literal.pos = literal.pos.extendedTo(this.prevNonWhitespaceOrComment().pos);
		return literal;
	}
	parseObjectLiteral() {
		let startPos = this.currentPos();
		let fields = [];
		let blockEnd = this.parseBlockStart().type == loreline_TokenType.Indent ? loreline_TokenType.Unindent : loreline_TokenType.RBrace;
		let style = blockEnd == loreline_TokenType.RBrace ? 1 : 0;
		let literal = new loreline_NLiteral(this.nextNodeId(4),blockEnd != loreline_TokenType.RBrace ? this.nextNonWhitespaceOrComment().pos : startPos,fields,loreline_LiteralType.Object(style));
		this.attachComments(literal);
		let needsSeparator = false;
		while(!this.check(blockEnd) && !this.isAtEnd()) {
			if(needsSeparator) {
				while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) needsSeparator = false;
				if(this.match(loreline_TokenType.Comma)) {
					needsSeparator = false;
				}
			}
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) needsSeparator = false;
			if(!this.check(blockEnd) && needsSeparator) {
				throw haxe_Exception.thrown(new loreline_ParseError("Expected comma or line break between fields",this.currentPos()));
			}
			while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
			}
			if(!this.check(blockEnd)) {
				fields.push(this.parseObjectField());
			}
			let prev = this.previous();
			needsSeparator = prev.type != loreline_TokenType.Colon && prev.type != loreline_TokenType.LineBreak;
		}
		while(this.match(loreline_TokenType.LineBreak) || blockEnd != loreline_TokenType.Unindent && this.match(loreline_TokenType.Unindent)) {
		}
		this.expect(blockEnd);
		literal.pos = literal.pos.extendedTo(this.prevNonWhitespaceOrComment().pos);
		return literal;
	}
	parseCallArguments() {
		let args = [];
		if(!this.check(loreline_TokenType.RParen)) {
			do {
				while(this.match(loreline_TokenType.LineBreak)) {
				}
				args.push(this.parseExpression());
				while(this.match(loreline_TokenType.LineBreak)) {
				}
			} while(this.match(loreline_TokenType.Comma));
		}
		this.expect(loreline_TokenType.RParen);
		return args;
	}
	parseConditionExpression() {
		let hasParen = this.match(loreline_TokenType.LParen);
		let expr = null;
		try {
			expr = this.parseExpression();
			if(expr != null) {
				if(js_Boot.getClass(expr) == loreline_NAssign) {
					this.addError(new loreline_ParseError("Invalid condition expression: can't assign a variable here. Did you want to use '==' instead?",expr.pos));
				}
			}
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof loreline_ParseError)) {
				let e = _g1;
				this.addError(e);
				expr = new loreline_NLiteral(this.nextNodeId(4),this.currentPos(),null,loreline_LiteralType.Null);
			} else {
				throw _g;
			}
		}
		if(hasParen) {
			this.expect(loreline_TokenType.RParen);
		}
		return expr;
	}
	match(type,advanceLineBreaks) {
		if(advanceLineBreaks == null) {
			advanceLineBreaks = true;
		}
		if(this.check(type)) {
			this.advance(advanceLineBreaks);
			return true;
		}
		return false;
	}
	isAtLineBreak() {
		if(!this.lineBreakAfterToken) {
			return this.tokens[this.current].type == loreline_TokenType.LineBreak;
		} else {
			return true;
		}
	}
	expect(type) {
		if(this.check(type)) {
			return this.advance();
		} else {
			let error = new loreline_ParseError("Expected " + loreline_TokenTypeHelpers.toCodeString(type) + ", got " + (this.isAtEnd() ? "end of file" : this.currentTokenTypeToString()),this.tokens[Math.min(this.current,this.tokens.length - 1) | 0].pos);
			switch(type._hx_index) {
			case 38:case 40:case 47:
				this.addError(error);
				return new loreline_Token(type,this.currentPos());
			default:
			}
			throw haxe_Exception.thrown(error);
		}
	}
	checkIdentifier() {
		let _g = this.tokens[this.current].type;
		if(_g._hx_index == 13) {
			let name = _g.name;
			return true;
		} else {
			return false;
		}
	}
	expectIdentifier() {
		let _g = this.tokens[this.current].type;
		if(_g._hx_index == 13) {
			let name = _g.name;
			this.advance();
			return name;
		} else {
			throw haxe_Exception.thrown(new loreline_ParseError("Expected identifier, got " + this.currentTokenTypeToString(),this.currentPos()));
		}
	}
	attachComments(node) {
		if(this.pendingComments == null || this.pendingComments.length == 0) {
			return node;
		}
		let nodeStart = node.pos;
		let remainingComments = null;
		let _g = 0;
		let _g1 = this.pendingComments.length;
		while(_g < _g1) {
			let i = _g++;
			let comment = this.pendingComments[i];
			if(comment.pos.line < nodeStart.line) {
				if(node.leadingComments == null) {
					node.leadingComments = [];
				}
				node.leadingComments.push(comment);
			} else if(comment.pos.line == nodeStart.line || this.isAtEnd()) {
				if(node.trailingComments == null) {
					node.trailingComments = [];
				}
				node.trailingComments.push(comment);
			} else {
				if(remainingComments == null) {
					remainingComments = [];
				}
				remainingComments.push(comment);
			}
		}
		this.pendingComments = remainingComments;
		return node;
	}
	attachElseComments(node,elseToken) {
		if(this.pendingComments != null) {
			let nodeStart = elseToken.pos;
			let remainingComments = [];
			let _g = 0;
			let _g1 = this.pendingComments;
			while(_g < _g1.length) {
				let comment = _g1[_g];
				++_g;
				if(comment.pos.line < nodeStart.line) {
					if(node.elseLeadingComments == null) {
						node.elseLeadingComments = [];
					}
					node.elseLeadingComments.push(comment);
				} else if(comment.pos.line == nodeStart.line) {
					if(node.elseTrailingComments == null) {
						node.elseTrailingComments = [];
					}
					node.elseTrailingComments.push(comment);
				} else {
					remainingComments.push(comment);
				}
			}
			this.pendingComments = remainingComments;
		}
		return node;
	}
	synchronize() {
		this.advance();
		while(!this.isAtEnd()) {
			let _g = this.tokens[this.current].type;
			switch(_g._hx_index) {
			case 9:
				let _g1 = _g.quotes;
				let _g2 = _g.s;
				let _g3 = _g.attachments;
				if(this.previous().type == loreline_TokenType.RBrace) {
					return;
				}
				this.advance();
				break;
			case 33:
				this.advance();
				if(this.check(loreline_TokenType.Dot) || loreline_TokenTypeHelpers.isIdentifier(this.tokens[this.current].type)) {
					this.advance();
				}
				return;
			case 1:case 2:case 3:case 4:case 5:case 38:case 46:
				return;
			default:
				this.advance();
			}
		}
	}
	requiresNewLine() {
		switch(this.tokens[this.current].type._hx_index) {
		case 6:case 33:case 38:
			return false;
		default:
			return true;
		}
	}
	addError(error) {
		if(this.errors == null) {
			this.errors = [];
		}
		if(!this.errors.includes(error)) {
			this.errors.push(error);
		}
		return error;
	}
}
$hxClasses["loreline.Parser"] = loreline_Parser;
loreline_Parser.__name__ = "loreline.Parser";
Object.assign(loreline_Parser.prototype, {
	__class__: loreline_Parser
});
class loreline_Position {
	constructor(line,column,offset,length) {
		if(length == null) {
			length = 0;
		}
		this.line = line;
		this.column = column;
		this.offset = offset;
		this.length = length;
	}
	toString() {
		return "(" + this.line + ":" + this.column + ":" + this.offset + ":" + this.length + ")";
	}
	toJson() {
		let json = { line : this.line, column : this.column, offset : this.offset};
		if(this.length != 0) {
			json["length"] = this.length;
		}
		return json;
	}
	withOffset(content,additionalOffset,newLength,contentStart) {
		if(contentStart == null) {
			contentStart = 0;
		}
		if(newLength == null) {
			newLength = 0;
		}
		if(additionalOffset == 0) {
			return new loreline_Position(this.line,this.column,this.offset,newLength);
		}
		let currentLine = this.line;
		let currentColumn = this.column;
		let currentOffset = this.offset;
		if(additionalOffset > 0) {
			let chars = 0;
			while(chars < additionalOffset) {
				if(currentOffset < contentStart + content.length && HxOverrides.cca(content,currentOffset - contentStart) == 10) {
					++currentLine;
					currentColumn = 1;
				} else {
					++currentColumn;
				}
				++chars;
				++currentOffset;
			}
		} else {
			let chars = 0;
			while(chars > additionalOffset) {
				--currentOffset;
				if(currentOffset >= 0 && HxOverrides.cca(content,currentOffset - contentStart) == 10) {
					--currentLine;
					let col = 1;
					let scanPos = currentOffset - 1;
					while(scanPos >= 0) {
						let c = HxOverrides.cca(content,scanPos - contentStart);
						if(c == 10) {
							break;
						}
						++col;
						--scanPos;
					}
					currentColumn = col;
				} else {
					--currentColumn;
				}
				--chars;
			}
		}
		if(currentOffset < 0) {
			currentOffset = 0;
			currentLine = 1;
			currentColumn = 1;
		}
		return new loreline_Position(currentLine,currentColumn,currentOffset,newLength);
	}
	extendedTo(endPos) {
		return new loreline_Position(this.line,this.column,this.offset,endPos.offset + endPos.length - this.offset);
	}
	static fromContentAndIndex(content,offset,length) {
		if(length == null) {
			length = 0;
		}
		let line = 1;
		let column = 1;
		let currentOffset = 0;
		let len = content.length;
		if(offset > len) {
			offset = len;
		}
		if(offset < 0) {
			offset = 0;
		}
		while(currentOffset < offset) {
			if(HxOverrides.cca(content,currentOffset) == 10) {
				++line;
				column = 1;
			} else {
				++column;
			}
			++currentOffset;
		}
		return new loreline_Position(line,column,offset,length);
	}
}
$hxClasses["loreline.Position"] = loreline_Position;
loreline_Position.__name__ = "loreline.Position";
Object.assign(loreline_Position.prototype, {
	__class__: loreline_Position
});
class loreline_Printer {
	constructor(indent,newline) {
		if(newline == null) {
			newline = "\n";
		}
		if(indent == null) {
			indent = "  ";
		}
		this.enableComments = true;
		this._indent = indent;
		this._newline = newline;
		this._beginLine = 0;
		this._lastChar = -1;
		this._noLn = 0;
		this._level = 0;
		this._prevLevel = 0;
		this._numEmptyLines = 0;
		this._buf = new StringBuf();
	}
	clear() {
		this._noLn = 0;
		this._level = 0;
		this._prevLevel = 0;
		this._numEmptyLines = 0;
		this._buf = new StringBuf();
	}
	indent() {
		this._level++;
	}
	unindent() {
		this._level--;
	}
	write(s) {
		if(s.length > 0) {
			if(this._beginLine > 0) {
				this.tab();
				this._beginLine = 0;
			}
			this._buf.b += s == null ? "null" : "" + s;
			this._lastChar = HxOverrides.cca(s,s.length - 1);
			let i = s.length - 1;
			while(i >= 0) {
				let c = HxOverrides.cca(s,i);
				if(c != 32 && c != 10 && c != 13 && c != 9) {
					this._lastVisibleChar = c;
					break;
				}
				--i;
			}
		}
		return this;
	}
	_writeln(s) {
		if(s == null) {
			s = "";
		}
		this.write(s);
		return this.newline();
	}
	newline() {
		if(this._beginLine < 2 && this._noLn == 0) {
			if(this._beginLine == 1) {
				this._numEmptyLines++;
			}
			this._buf.b += Std.string(this._newline);
			this._beginLine++;
		}
		return this;
	}
	tab() {
		let _g = 0;
		let _g1 = this._level;
		while(_g < _g1) {
			let _ = _g++;
			this._buf.b += Std.string(this._indent);
		}
		return this;
	}
	_line(s) {
		this.tab();
		this._buf.b += s == null ? "null" : "" + s;
		return this.newline();
	}
	toString() {
		return this._buf.b;
	}
	printStringLiteralAsReference(str) {
		let saved = this.enableComments;
		this.enableComments = false;
		this._noLn = 0;
		this._level = 0;
		this._prevLevel = 0;
		this._numEmptyLines = 0;
		this._buf = new StringBuf();
		this._beginLine = 1;
		this.printStringLiteral(str);
		this.enableComments = saved;
		let result = StringTools.trim(this.toString());
		result = result.split("\n").join("\\n");
		return result;
	}
	printStringLiteralAsText(str) {
		let saved = this.enableComments;
		this.enableComments = false;
		this._noLn = 0;
		this._level = 0;
		this._prevLevel = 0;
		this._numEmptyLines = 0;
		this._buf = new StringBuf();
		this._beginLine = 1;
		let _g = 0;
		let _g1 = str.parts;
		while(_g < _g1.length) {
			let part = _g1[_g];
			++_g;
			let _g2 = part.partType;
			switch(_g2._hx_index) {
			case 0:
				let text = _g2.text;
				if(str.quotes == 1) {
					this.writeQuotedRaw(text);
				} else {
					this.writeUnquotedRaw(text);
				}
				break;
			case 1:
				let expr = _g2.expr;
				let canBeSimple = this.isSimpleInterpolationExpr(expr);
				this.write("$");
				if(!canBeSimple) {
					this.write("{");
				}
				this.printNode(expr);
				if(!canBeSimple) {
					this.write("}");
				}
				break;
			case 2:
				let closing = _g2.closing;
				let content = _g2.expr;
				this.write(closing ? "</" : "<");
				this.printStringLiteral(content);
				this.write(">");
				break;
			}
		}
		this.enableComments = saved;
		let result = StringTools.trim(this.toString());
		result = result.split("\n").join("\\n");
		return result;
	}
	print(node) {
		this._noLn = 0;
		this._level = 0;
		this._prevLevel = 0;
		this._numEmptyLines = 0;
		this._buf = new StringBuf();
		this._beginLine = 1;
		this.printNode(node);
		return this.toString();
	}
	printNode(node,sameLine) {
		if(sameLine == null) {
			sameLine = false;
		}
		if(node == null) {
			return;
		}
		switch(js_Boot.getClass(node)) {
		case loreline_NAccess:
			this.printAccess(node);
			break;
		case loreline_NArrayAccess:
			this.printArrayAccess(node);
			break;
		case loreline_NAssign:
			this.printAssignment(node);
			break;
		case loreline_NBeatDecl:
			this.printBeatDecl(node);
			break;
		case loreline_NBinary:
			this.printBinary(node);
			break;
		case loreline_NCall:
			this.printCall(node);
			break;
		case loreline_NCharacterDecl:
			this.printCharacterDecl(node);
			break;
		case loreline_NChoiceOption:
			this.printChoiceOption(node);
			break;
		case loreline_NChoiceStatement:
			this.printChoiceStatement(node);
			break;
		case loreline_NDialogueStatement:
			this.printDialogueStatement(node);
			break;
		case loreline_NFunctionDecl:
			this.printFunctionDecl(node);
			break;
		case loreline_NIfStatement:
			this.printIfStatement(node);
			break;
		case loreline_NImportStatement:
			this.printImportStatement(node);
			break;
		case loreline_NInsertion:
			this.printInsertion(node);
			break;
		case loreline_NLiteral:
			this.printLiteral(node);
			break;
		case loreline_NStateDecl:
			this.printStateDecl(node);
			break;
		case loreline_NStringLiteral:
			this.printStringLiteral(node);
			break;
		case loreline_NTextStatement:
			this.printTextStatement(node);
			break;
		case loreline_NTransition:
			this.printTransition(node,sameLine);
			break;
		case loreline_NUnary:
			this.printUnary(node);
			break;
		case loreline_Script:
			this.printScript(node);
			break;
		default:
			let c = js_Boot.getClass(node);
			throw haxe_Exception.thrown("Unsupported node type: " + c.__name__);
		}
	}
	printLeadingComments(node) {
		if(this.enableComments && node.leadingComments != null) {
			let _g = 0;
			let _g1 = node.leadingComments;
			while(_g < _g1.length) {
				let comment = _g1[_g];
				++_g;
				if(comment.multiline) {
					this.write("/*" + comment.content + "*/");
					this.newline();
				} else if(comment.isHash) {
					this.write("#" + comment.content);
					this.newline();
				} else {
					this.write("//" + comment.content);
					this.newline();
				}
			}
		}
	}
	printHashTrailingComments(node) {
		if(this.enableComments && node.trailingComments != null) {
			let _g = 0;
			let _g1 = node.trailingComments;
			while(_g < _g1.length) {
				let comment = _g1[_g];
				++_g;
				if(comment.isHash) {
					if(this._lastChar != 32 && this._beginLine == 0) {
						this.write(" ");
					}
					this.write("#" + comment.content);
					this.newline();
				}
			}
		}
	}
	printTrailingComments(node) {
		if(this.enableComments && node.trailingComments != null) {
			let _g = 0;
			let _g1 = node.trailingComments;
			while(_g < _g1.length) {
				let comment = _g1[_g];
				++_g;
				if(this._lastChar != 32 && this._beginLine == 0) {
					this.write(" ");
				}
				if(comment.multiline) {
					this.write("/*" + comment.content + "*/ ");
				} else if(comment.isHash) {
					this.write("#" + comment.content);
					this.newline();
				} else {
					this.write("//" + comment.content);
					this.newline();
				}
			}
		}
	}
	printImport(imp) {
		this.printLeadingComments(imp);
		this.write("import \"" + Std.string(imp.path) + "\"");
		this.newline();
		this.printTrailingComments(imp);
	}
	printScript(script) {
		let _g = 0;
		let _g1 = script.body;
		while(_g < _g1.length) {
			let decl = _g1[_g];
			++_g;
			this._prevLevel = this._level;
			this.printNode(decl);
		}
	}
	printStateDecl(state) {
		this.newline();
		this.newline();
		this.printLeadingComments(state);
		if(state.temporary) {
			this.write("new ");
		}
		this.write("state ");
		this.printTrailingComments(state);
		if(state.style == 1) {
			this.write("{");
			this.newline();
		} else {
			this.newline();
		}
		this._level++;
		let first = true;
		let _g = 0;
		let _g1 = state.fields;
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			if(!first) {
				if(this._beginLine == 0) {
					this.newline();
				}
			}
			first = false;
			this.printLeadingComments(field);
			this.write("" + field.name + ": ");
			this.printTrailingComments(field);
			this.printNode(field.value);
		}
		this.newline();
		this._level--;
		if(state.style == 1) {
			this.write("}");
			this.newline();
		}
	}
	printCharacterDecl(char) {
		this.newline();
		this.newline();
		this.printLeadingComments(char);
		this.write("character " + char.name + " ");
		this.printTrailingComments(char);
		if(char.style == 1) {
			this.write("{");
			this.newline();
		} else {
			this.newline();
		}
		this._level++;
		let _g = 0;
		let _g1 = char.fields;
		while(_g < _g1.length) {
			let prop = _g1[_g];
			++_g;
			this.printLeadingComments(prop);
			this.write("" + prop.name + ": ");
			this.printTrailingComments(prop);
			this.printNode(prop.value);
			if(this._beginLine == 0) {
				this.newline();
			}
		}
		this._level--;
		if(char.style == 1) {
			this.write("}");
			this.newline();
		}
	}
	printBeatDecl(beat) {
		this.newline();
		this.newline();
		this.printLeadingComments(beat);
		this.write("beat " + beat.name + " ");
		this.printTrailingComments(beat);
		if(beat.style == 1) {
			this.write("{");
			this.newline();
		}
		this.newline();
		this.newline();
		this._level++;
		let _g = 0;
		let _g1 = beat.body.length;
		while(_g < _g1) {
			let i = _g++;
			this._prevLevel = this._level;
			this.printNode(beat.body[i]);
			if(i < beat.body.length - 1) {
				this.newline();
			}
		}
		this._level--;
		if(this._beginLine == 0) {
			this.newline();
		}
		if(this._lastVisibleChar != 125) {
			this.newline();
		}
		if(beat.style == 1) {
			this.write("}");
			this.newline();
		}
	}
	printFunctionDecl(func) {
		this.newline();
		this.newline();
		this.printLeadingComments(func);
		this.write(func.code);
		this.printTrailingComments(func);
	}
	printTextStatement(text) {
		if(this._level == this._prevLevel) {
			this.newline();
		}
		this.printLeadingComments(text);
		this.printNode(text.content);
		this.printTrailingComments(text);
	}
	printDialogueStatement(dialogue) {
		if(this._level == this._prevLevel) {
			this.newline();
		}
		this.printLeadingComments(dialogue);
		if(dialogue.content != null && this.hasRealNewlines(dialogue.content)) {
			this.write("" + dialogue.character + ":");
			this.printTrailingComments(dialogue);
			this.newline();
			this._level++;
			this.printNode(dialogue.content);
			this._level--;
		} else {
			this.write("" + dialogue.character + ": ");
			this.printTrailingComments(dialogue);
			this.printNode(dialogue.content);
		}
	}
	printChoiceStatement(choice) {
		this.newline();
		this.newline();
		this.printLeadingComments(choice);
		this.write("choice ");
		this.printTrailingComments(choice);
		if(choice.style == 1) {
			this.write("{");
			this.newline();
		} else {
			this.newline();
		}
		this._level++;
		if(choice.options.length > 0) {
			this._noLn++;
			let _g = 0;
			let _g1 = choice.options;
			while(_g < _g1.length) {
				let option = _g1[_g];
				++_g;
				this.printNode(option);
				this.newline();
			}
		}
		this._level--;
		if(choice.style == 1) {
			this.write("}");
			this.newline();
		}
	}
	printImportStatement(imp) {
		this.newline();
		this.newline();
		this.printLeadingComments(imp);
		this.write("import ");
		this.printStringLiteral(imp.path);
		this.printTrailingComments(imp);
	}
	printChoiceOption(option) {
		this.newline();
		this.newline();
		this._noLn = 0;
		this.printLeadingComments(option);
		if(option.insertion != null) {
			this.printNode(option.insertion);
		} else {
			this.printNode(option.text);
		}
		this.printTrailingComments(option);
		if(option.condition != null) {
			this.write(" if ");
			this.printInLineExpression(option.condition,option.conditionStyle == 2);
		}
		if(option.body.length > 0) {
			if(option.condition == null && option.body.length == 1 && ((option.body[0]) instanceof loreline_NTransition)) {
				this._prevLevel = this._level;
				this.write(" ");
				this.printNode(option.body[0],true);
				if(this._beginLine == 0) {
					this.newline();
				}
			} else {
				if(option.style == 1) {
					this.write(" {");
					this.newline();
				} else {
					this.newline();
				}
				this._prevLevel = this._level;
				this._level++;
				let _g = 0;
				let _g1 = option.body;
				while(_g < _g1.length) {
					let node = _g1[_g];
					++_g;
					this.printNode(node);
					if(this._beginLine == 0 && node != option.body[option.body.length - 1]) {
						this.newline();
					}
					this._prevLevel = this._level;
				}
				this._level--;
				this.newline();
				if(option.style == 1) {
					this.write("}");
					this.newline();
				}
			}
		} else {
			this.newline();
		}
	}
	printIfStatement(ifStmt,isElseIf) {
		if(isElseIf == null) {
			isElseIf = false;
		}
		if(this._level == this._prevLevel) {
			this.newline();
		}
		this.printLeadingComments(ifStmt);
		this.write("if ");
		this.printInLineExpression(ifStmt.condition,ifStmt.conditionStyle == 2);
		this.printTrailingComments(ifStmt);
		if(ifStmt.thenBranch.style == 1) {
			this.write(" {");
		}
		this.newline();
		this._prevLevel = this._level;
		this._level++;
		let emptyLinesBeforeIf = this._numEmptyLines;
		let _g = 0;
		let _g1 = ifStmt.thenBranch.body;
		while(_g < _g1.length) {
			let node = _g1[_g];
			++_g;
			this.printNode(node);
			this.newline();
			this._prevLevel = this._level;
		}
		this._level--;
		if(ifStmt.thenBranch.style == 1) {
			this.write("}");
		}
		if(ifStmt.elseBranch != null) {
			if(ifStmt.elseBranch.body.length == 1 && ((ifStmt.elseBranch.body[0]) instanceof loreline_NIfStatement)) {
				let subIf = ifStmt.elseBranch.body[0];
				if(this._numEmptyLines - emptyLinesBeforeIf > 0 || this.needsEmptyLines(subIf)) {
					this.newline();
				}
				this.write("else ");
				this.printIfStatement(ifStmt.elseBranch.body[0],true);
			} else {
				if(this._numEmptyLines - emptyLinesBeforeIf > 0) {
					this.newline();
				}
				if(ifStmt.elseBranch.style == 1) {
					this.write("else {");
					this.newline();
				} else {
					this.write("else");
					this.newline();
				}
				this._prevLevel = this._level;
				this._level++;
				let _g = 0;
				let _g1 = ifStmt.elseBranch.body;
				while(_g < _g1.length) {
					let node = _g1[_g];
					++_g;
					this.printNode(node);
					this.newline();
					this._prevLevel = this._level;
				}
				this._level--;
				if(ifStmt.elseBranch.style == 1) {
					this.write("}");
					this.newline();
				}
			}
		}
	}
	needsEmptyLines(node) {
		let printer = new loreline_Printer(this._indent,"\n");
		return printer.print(node).indexOf("\n\n") != -1;
	}
	printTransition(trans,sameLine) {
		if(!sameLine && this._prevLevel == this._level) {
			this.newline();
		}
		this.printLeadingComments(trans);
		this.write("-> " + trans.target);
		this.printTrailingComments(trans);
	}
	printInsertion(insert) {
		if(this._prevLevel == this._level) {
			this.newline();
		}
		this.printLeadingComments(insert);
		this.write("+ " + insert.target);
		this.printTrailingComments(insert);
	}
	printStringLiteral(str) {
		let surroundWithQuotes = str.quotes == 1;
		if(surroundWithQuotes) {
			this.printLeadingComments(str);
			this.write("\"");
		}
		let _g = 0;
		let _g1 = str.parts;
		while(_g < _g1.length) {
			let part = _g1[_g];
			++_g;
			let _g2 = part.partType;
			switch(_g2._hx_index) {
			case 0:
				let text = _g2.text;
				if(surroundWithQuotes) {
					this.writeQuotedRaw(text);
				} else {
					this.writeUnquotedRaw(text);
				}
				break;
			case 1:
				let expr = _g2.expr;
				let canBeSimple = this.isSimpleInterpolationExpr(expr);
				this.write("$");
				if(!canBeSimple) {
					this.write("{");
				}
				this.printNode(expr);
				if(!canBeSimple) {
					this.write("}");
				}
				break;
			case 2:
				let closing = _g2.closing;
				let content = _g2.expr;
				this.write(closing ? "</" : "<");
				this.printStringLiteral(content);
				this.write(">");
				break;
			}
		}
		if(surroundWithQuotes) {
			this.write("\"");
			this.printTrailingComments(str);
		} else {
			this.printHashTrailingComments(str);
		}
	}
	writeUnquotedRaw(text) {
		this.writeRawWithContinuation(text,true);
	}
	writeQuotedRaw(text) {
		if(text.indexOf("\n") == -1) {
			this.write(text);
			return;
		}
		let lines = text.split("\n");
		let _g = 0;
		let _g1 = lines.length;
		while(_g < _g1) {
			let i = _g++;
			if(i > 0) {
				this._buf.b += Std.string(this._newline);
			}
			let line = lines[i];
			if(line.length > 0 && HxOverrides.cca(line,line.length - 1) == 13) {
				line = line.substring(0,line.length - 1);
			}
			if(line.length > 0) {
				this._buf.b += line == null ? "null" : "" + line;
				this._lastChar = HxOverrides.cca(line,line.length - 1);
			}
		}
	}
	writeRawWithContinuation(text,stripIndent) {
		if(text.indexOf("\n") == -1) {
			this.write(text);
			return;
		}
		let lines = text.split("\n");
		let _g = 0;
		let _g1 = lines.length;
		while(_g < _g1) {
			let i = _g++;
			if(i > 0) {
				this._buf.b += Std.string(this._newline);
				this._beginLine = 1;
			}
			let line = lines[i];
			if(line.length > 0 && HxOverrides.cca(line,line.length - 1) == 13) {
				line = line.substring(0,line.length - 1);
			}
			if(stripIndent && i > 0) {
				let j = 0;
				while(j < line.length && (HxOverrides.cca(line,j) == 32 || HxOverrides.cca(line,j) == 9)) ++j;
				if(j > 0) {
					line = line.substring(j,null);
				}
			}
			if(line.length > 0) {
				this.write(line);
			}
		}
	}
	printLiteral(lit) {
		this.printLeadingComments(lit);
		let _g = lit.literalType;
		switch(_g._hx_index) {
		case 0:
			this.write(lit.value == null ? "null" : Std.string(lit.value));
			break;
		case 1:
			this.write(lit.value ? "true" : "false");
			break;
		case 2:
			this.write("null");
			break;
		case 3:
			let first = true;
			this.write("[");
			let _g1 = 0;
			let _g2 = lit.value;
			while(_g1 < _g2.length) {
				let elem = _g2[_g1];
				++_g1;
				if(!first) {
					this.write(", ");
				}
				first = false;
				this.printNode(elem);
			}
			this.write("]");
			break;
		case 4:
			let style = _g.style;
			if(style == 1) {
				this.write("{");
				this.newline();
			} else {
				this.newline();
			}
			this._level++;
			let first1 = true;
			let _g3 = 0;
			let _g4 = lit.value;
			while(_g3 < _g4.length) {
				let field = _g4[_g3];
				++_g3;
				if(!first1) {
					if(this._beginLine == 0) {
						this.newline();
					}
				}
				first1 = false;
				this.printLeadingComments(field);
				this.write("" + field.name + ": ");
				this.printTrailingComments(field);
				this.printNode(field.value);
			}
			this.newline();
			this._level--;
			if(style == 1) {
				this.write("}");
			}
			break;
		}
		this.printTrailingComments(lit);
	}
	printAccess(access) {
		this.printLeadingComments(access);
		if(access.target != null) {
			this.printNode(access.target);
			this.write(".");
		}
		this.write(access.name);
		this.printTrailingComments(access);
	}
	printArrayAccess(access) {
		this.printLeadingComments(access);
		this.printNode(access.target);
		this.write("[");
		this.printNode(access.index);
		this.write("]");
		this.printTrailingComments(access);
	}
	printCall(call) {
		this.printLeadingComments(call);
		this.printNode(call.target);
		this.write("(");
		let first = true;
		let _g = 0;
		let _g1 = call.args;
		while(_g < _g1.length) {
			let arg = _g1[_g];
			++_g;
			if(!first) {
				this.write(", ");
			}
			first = false;
			this.printNode(arg);
		}
		this.write(")");
		this.printTrailingComments(call);
	}
	printBinary(binary,skipParen) {
		if(skipParen == null) {
			skipParen = false;
		}
		this.printLeadingComments(binary);
		let needsParens;
		if(!skipParen) {
			let _g = binary.op;
			switch(_g._hx_index) {
			case 30:
				let word = _g.word;
				needsParens = true;
				break;
			case 31:
				let word1 = _g.word;
				needsParens = true;
				break;
			default:
				needsParens = false;
			}
		} else {
			needsParens = false;
		}
		if(needsParens) {
			this.write("(");
		}
		this.printNode(binary.left);
		this.write(" " + this.getOperator(binary.op) + " ");
		this.printNode(binary.right);
		if(needsParens) {
			this.write(")");
		}
		this.printTrailingComments(binary);
	}
	printUnary(unary) {
		this.printLeadingComments(unary);
		this.write(this.getOperator(unary.op));
		this.printTrailingComments(unary);
		this.printNode(unary.operand);
	}
	printAssignment(assign) {
		this.printLeadingComments(assign);
		this.printNode(assign.target);
		this.printTrailingComments(assign);
		this.write(" " + this.getOperator(assign.op) + " ");
		this.printNode(assign.value);
	}
	printInLineExpression(expr,parens) {
		let savedComments = this.enableComments;
		this.enableComments = false;
		if(parens) {
			this.write("(");
		}
		if(((expr) instanceof loreline_NBinary)) {
			this.printBinary(expr,true);
		} else {
			this.printNode(expr);
		}
		if(parens) {
			this.write(")");
		}
		this.enableComments = savedComments;
	}
	isSimpleInterpolationExpr(expr) {
		if(((expr) instanceof loreline_NAccess)) {
			let access = expr;
			if(access.target == null) {
				return true;
			}
			return this.isSimpleInterpolationExpr(access.target);
		}
		if(((expr) instanceof loreline_NArrayAccess)) {
			return this.isSimpleInterpolationExpr((js_Boot.__cast(expr , loreline_NArrayAccess)).target);
		}
		if(((expr) instanceof loreline_NCall)) {
			return this.isSimpleInterpolationExpr((js_Boot.__cast(expr , loreline_NCall)).target);
		}
		return false;
	}
	hasRealNewlines(node) {
		if(((node) instanceof loreline_NStringLiteral)) {
			let str = node;
			if(str.quotes == 1) {
				return false;
			}
			let _g = 0;
			let _g1 = str.parts;
			while(_g < _g1.length) {
				let part = _g1[_g];
				++_g;
				let _g2 = part.partType;
				if(_g2._hx_index == 0) {
					let text = _g2.text;
					if(text.indexOf("\n") != -1) {
						return true;
					}
				}
			}
		}
		return false;
	}
	getOperator(op) {
		switch(op._hx_index) {
		case 14:
			return "=";
		case 15:
			return "+=";
		case 16:
			return "-=";
		case 17:
			return "*=";
		case 18:
			return "/=";
		case 19:
			return "+";
		case 20:
			return "-";
		case 21:
			return "*";
		case 22:
			return "/";
		case 23:
			return "%";
		case 24:
			return "==";
		case 25:
			return "!=";
		case 26:
			return ">";
		case 27:
			return "<";
		case 28:
			return ">=";
		case 29:
			return "<=";
		case 30:
			if(op.word) {
				return "and";
			} else {
				return "&&";
			}
			break;
		case 31:
			if(op.word) {
				return "or";
			} else {
				return "||";
			}
			break;
		case 32:
			return "!";
		default:
			throw haxe_Exception.thrown("Unsupported operator: " + Std.string(op));
		}
	}
}
$hxClasses["loreline.Printer"] = loreline_Printer;
loreline_Printer.__name__ = "loreline.Printer";
Object.assign(loreline_Printer.prototype, {
	__class__: loreline_Printer
});
class loreline_Quotes {
	static toString(this1) {
		switch(this1) {
		case 0:
			return "Unquoted";
		case 1:
			return "DoubleQuotes";
		}
	}
}
class loreline_Random {
	constructor(seed) {
		if(seed == null) {
			seed = -1;
		}
		if(seed < 0) {
			let now = new Date().getTime() / 1000.0;
			seed = now * 1000000;
			seed += Math.random() * 100000;
			seed %= 2147483647;
		}
		this.seed = seed;
		this.initialSeed = this.seed;
	}
	next() {
		return (this.seed = this.seed * 16807 % 2147483647) / 2147483647 + 0.000000000233;
	}
	between(min,max) {
		return Math.floor(min + (max - min) * ((this.seed = this.seed * 16807 % 2147483647) / 2147483647 + 0.000000000233));
	}
	reset(initialSeed) {
		if(initialSeed != null) {
			this.initialSeed = initialSeed;
		}
		this.seed = this.initialSeed;
	}
}
$hxClasses["loreline.Random"] = loreline_Random;
loreline_Random.__name__ = "loreline.Random";
Object.assign(loreline_Random.prototype, {
	__class__: loreline_Random
});
class loreline_Script extends loreline_AstNode {
	constructor(id,pos,body) {
		loreline_Node._hx_skip_constructor = true;
		super();
		loreline_Node._hx_skip_constructor = false;
		this._hx_constructor(id,pos,body);
	}
	_hx_constructor(id,pos,body) {
		this.indentSize = 2;
		super._hx_constructor(id,pos);
		this.body = body;
	}
	toJson() {
		let json = super.toJson();
		let _g = [];
		let _g1 = 0;
		let _g2 = this.body;
		while(_g1 < _g2.length) {
			let decl = _g2[_g1];
			++_g1;
			_g.push(decl.toJson());
		}
		json.body = _g;
		return json;
	}
	type() {
		return "Script";
	}
	eachExcludingImported(handleNode) {
		super.each(handleNode);
		if(this.body != null) {
			let _g = 0;
			let _g1 = this.body;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				handleNode(child,this);
				if(!((child) instanceof loreline_NImportStatement)) {
					child.each(handleNode);
				}
			}
		}
	}
	each(handleNode) {
		super.each(handleNode);
		if(this.body != null) {
			let _g = 0;
			let _g1 = this.body;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				handleNode(child,this);
				child.each(handleNode);
			}
		}
	}
	iterator() {
		return new loreline__$Script_ScriptBodyIterator(this.body);
	}
}
$hxClasses["loreline.Script"] = $hx_exports["loreline"]["Script"] = loreline_Script;
loreline_Script.__name__ = "loreline.Script";
loreline_Script.__super__ = loreline_AstNode;
Object.assign(loreline_Script.prototype, {
	__class__: loreline_Script
});
class loreline__$Script_ScriptBodyIterator {
	constructor(body) {
		this.body = body;
		this.index = 0;
		this.flatBody = [];
		this.fillBody(body);
	}
	fillBody(body) {
		let _g = 0;
		let _g1 = body.length;
		while(_g < _g1) {
			let i = _g++;
			let node = body[i];
			if(((node) instanceof loreline_NImportStatement)) {
				let importNode = node;
				if(importNode.script != null) {
					this.fillBody(importNode.script.body);
				}
			}
			this.flatBody.push(body[i]);
		}
	}
	hasNext() {
		return this.index < this.flatBody.length;
	}
	next() {
		let v = this.flatBody[this.index];
		this.index++;
		return v;
	}
}
$hxClasses["loreline._Script.ScriptBodyIterator"] = loreline__$Script_ScriptBodyIterator;
loreline__$Script_ScriptBodyIterator.__name__ = "loreline._Script.ScriptBodyIterator";
Object.assign(loreline__$Script_ScriptBodyIterator.prototype, {
	__class__: loreline__$Script_ScriptBodyIterator
});
class loreline_Utf8 {
	static uLength(str) {
		return str.length;
	}
	static uSubstr(str,pos,len) {
		return HxOverrides.substr(str,pos,len);
	}
	static uSubstring(str,startIndex,endIndex) {
		return str.substring(startIndex,endIndex);
	}
	static uCharCodeAt(str,pos) {
		return HxOverrides.cca(str,pos);
	}
	static uIndexOf(str,substr,startIndex) {
		return str.indexOf(substr,startIndex);
	}
	static uLastIndexOf(str,substr,startIndex) {
		return str.lastIndexOf(substr,startIndex);
	}
	static uToChars(str) {
		return str.split("");
	}
	static uCharAt(str,pos) {
		return str.charAt(pos);
	}
}
$hxClasses["loreline.Utf8"] = loreline_Utf8;
loreline_Utf8.__name__ = "loreline.Utf8";
class loreline_WrappedError extends loreline_Error {
	constructor(wrapped,message,pos) {
		super(message,pos);
		this.wrapped = wrapped;
	}
}
$hxClasses["loreline.WrappedError"] = loreline_WrappedError;
loreline_WrappedError.__name__ = "loreline.WrappedError";
loreline_WrappedError.__super__ = loreline_Error;
Object.assign(loreline_WrappedError.prototype, {
	__class__: loreline_WrappedError
});
function loreline_lib_Library_main() {
}
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	Object.defineProperty(String.prototype,"__class__",{ value : $hxClasses["String"] = String, enumerable : false, writable : true});
	String.__name__ = "String";
	$hxClasses["Array"] = Array;
	Array.__name__ = "Array";
	Date.prototype.__class__ = $hxClasses["Date"] = Date;
	Date.__name__ = "Date";
	var Int = { };
	var Dynamic = { };
	var Float = Number;
	var Bool = Boolean;
	var Class = { };
	var Enum = { };
}
js_Boot.__toStr = ({ }).toString;
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Document = 6;
loreline_AstUtils.randomId_nonHexChars = "ghijklmnopqrstuvwxyz";
loreline_AstUtils.randomId_chars = "0123456789abcdefghijklmnopqrstuvwxyz";
loreline_CodeToHscriptStackType.ObjectBrace = 0;
loreline_CodeToHscriptStackType.ArrayBracket = 1;
loreline_CodeToHscriptStackType.Brace = 2;
loreline_CodeToHscriptStackType.Indent = 3;
loreline_CodeToHscriptStackType.Bracket = 4;
loreline_CodeToHscriptStackType.Paren = 5;
loreline_CodeToHscript.CONTROL_KEYWORDS = ["for","while","if","else","switch","catch"];
loreline_Int64Map.INITIAL_SIZE = 16;
loreline_Int64Map.LOAD_FACTOR = 0.75;
loreline_TokenStackType.ChoiceBrace = 0;
loreline_TokenStackType.ChoiceIndent = 1;
loreline_TokenStackType.StateBrace = 2;
loreline_TokenStackType.StateIndent = 3;
loreline_TokenStackType.CharacterBrace = 4;
loreline_TokenStackType.CharacterIndent = 5;
loreline_TokenStackType.BeatBrace = 6;
loreline_TokenStackType.BeatIndent = 7;
loreline_TokenStackType.Brace = 8;
loreline_TokenStackType.Indent = 9;
loreline_TokenStackType.Bracket = 10;
loreline_Lexer.hasNonSpecialChar_specialChars = " \t\"+=*/-(){}[]:\n\r";
loreline_Lexer.KEYWORDS = (function($this) {
	var $r;
	let _g = new haxe_ds_StringMap();
	_g.h["import"] = loreline_TokenType.KwImport;
	_g.h["state"] = loreline_TokenType.KwState;
	_g.h["beat"] = loreline_TokenType.KwBeat;
	_g.h["character"] = loreline_TokenType.KwCharacter;
	_g.h["choice"] = loreline_TokenType.KwChoice;
	_g.h["if"] = loreline_TokenType.KwIf;
	_g.h["else"] = loreline_TokenType.KwElse;
	_g.h["new"] = loreline_TokenType.KwNew;
	_g.h["true"] = loreline_TokenType.LBoolean(true);
	_g.h["false"] = loreline_TokenType.LBoolean(false);
	_g.h["null"] = loreline_TokenType.LNull;
	_g.h["and"] = loreline_TokenType.OpAnd(true);
	_g.h["or"] = loreline_TokenType.OpOr(true);
	$r = _g;
	return $r;
}(this));
loreline_NodeId.OFFSET = 32768;
loreline_NodeId.MAX = 65535;
loreline_NodeId.UNDEFINED = new loreline_NodeId(0,0,0,0);
loreline_Node._hx_skip_constructor = false;
loreline_BlockStyle.Plain = 0;
loreline_BlockStyle.Braces = 1;
loreline_ConditionStyle.Plain = 0;
loreline_ConditionStyle.Parens = 2;
loreline_Quotes.Unquoted = 0;
loreline_Quotes.DoubleQuotes = 1;
loreline_lib_Library_main();
})(runtime, globals);

export const Loreline = runtime.loreline.Loreline;
export const Interpreter = runtime.loreline.Interpreter;
export const Node = runtime.loreline.Node;
export const Script = runtime.loreline.Script;